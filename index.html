<!doctype html>
<html lang="pl">

<head>
    <meta charset="utf-8">
    <title>Programowanie Obiektowe - Nowa Wersja</title>
    <meta name="description" content="PO LAB">
    <meta name="author" content="Norbert Waszkowiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .row {
            display: flex;
        }

        .column {
            flex: 50%;
            padding: 10px;
        }

        .small-font pre {
            font-size: 13px;
            margin-left: 0;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <section data-background-gradient="linear-gradient(45deg, #2c3e50, #3498db)">

                <!-- 1. Slajd powitalny -->
                <section style="text-align: left;">
                    <h1>Programowanie Obiektowe</h1>

                    <div style="margin-top: 40px;">
                        <p><strong>ProwadzÄ…cy:</strong> por. mgr inÅ¼. Norbert Waszkowiak</p>

                        <div style="margin-top: 30px; font-size: 0.6em;">
                            <p>ğŸ“ <strong>Tel:</strong> 261 839 060</p>
                            <p>ğŸ“§ <strong>Email:</strong> norbert.waszkowiak@wat.edu.pl</p>
                            <p>ğŸ¢ <strong>PokÃ³j:</strong> bud. 100, pok. 254B</p>
                            <p>ğŸ’¬ <strong>Konsultacje:</strong> po wczeÅ›niejszym umÃ³wieniu (online/stacjonarnie)</p>
                        </div>
                    </div>

                </section>
            </section>

            <!-- 2. Historia programowania -->
            <section data-background-gradient="linear-gradient(37deg, #1e3c72, #2a5298)">

                <!-- Slajd tytuÅ‚owy -->
                <section>
                    <h2>Historia programowania</h2>
                    <h3>Programowanie proceduralne vs obiektowe</h3>
                    <aside class="notes">
                        Programowanie obiektowe nie powstaÅ‚o przypadkowo ani jako abstrakcyjna teoria akademicka.
                        Jest odpowiedziÄ… na konkretne problemy inÅ¼ynierskie, ktÃ³re wystÄ…piÅ‚y w praktyce 
                        tworzenia oprogramowania w latach 60. i 70. XX wieku.
                        
                        W tej czÄ™Å›ci wykÅ‚adu omÃ³wimy ewolucjÄ™ paradygmatÃ³w programowania oraz przyczyny,
                        dla ktÃ³rych programowanie obiektowe staÅ‚o siÄ™ dominujÄ…cym podejÅ›ciem w inÅ¼ynierii oprogramowania.
                        Analiza historyczna pozwoli zrozumieÄ‡, Å¼e OOP jest narzÄ™dziem rozwiÄ…zujÄ…cym realne problemy,
                        a nie jedynie teoretycznÄ… koncepcjÄ….
                    </aside>
                </section>

                <!-- Programowanie proceduralne -->
                <section>
                    <h3>Programowanie proceduralne</h3>
                    <p><strong>Lata 50-60. XX wieku</strong></p>
                    <ul>
                        <li>Program = lista instrukcji wykonywanych kolejno</li>
                        <li>Dane oddzielone od funkcji</li>
                        <li>PrzykÅ‚ady: Fortran, COBOL, C</li>
                    </ul>
                    <pre style="font-size: 16px; margin-top: 30px;"><code class="hljs c" data-trim>
int suma = 0;
for(int i = 0; i < 10; i++) {
    suma += i;
}
printf("Suma: %d", suma);
                    </code></pre>
                    <aside class="notes">
                        Programowanie proceduralne charakteryzuje siÄ™ sekwencyjnym wykonywaniem instrukcji.
                        Program skÅ‚ada siÄ™ ze zmiennych przechowujÄ…cych dane oraz procedur (funkcji) operujÄ…cych na tych danych.
                        KluczowÄ… cechÄ… tego paradygmatu jest separacja danych od logiki przetwarzania.
                        
                        JÄ™zyki takie jak Fortran (1957) sÅ‚uÅ¼yÅ‚y obliczeniom naukowym, COBOL (1959) 
                        zastosowaniom biznesowym, a C (1972) programowaniu systemowemu. Wszystkie opieraÅ‚y siÄ™
                        na paradygmacie proceduralnym.
                        
                        PodejÅ›cie to byÅ‚o efektywne dla programÃ³w o ograniczonej zÅ‚oÅ¼onoÅ›ci - rzÄ™du setek linii kodu.
                        Jednak wraz ze wzrostem skali oprogramowania zaczÄ™Å‚y ujawniaÄ‡ siÄ™ fundamentalne problemy tego modelu.
                    </aside>
                </section>

                <!-- Problem -->
                <section>
                    <h3>Problem: chaos w duÅ¼ych programach</h3>
                    <ul>
                        <li>ğŸ“ˆ TysiÄ…ce linii w jednym pliku</li>
                        <li>ğŸ”„ Zmienne globalne - kto je zmienia?</li>
                        <li>ğŸ› BÅ‚Ä…d w jednym miejscu = awaria caÅ‚oÅ›ci</li>
                        <li>ğŸ‘¥ WspÃ³Å‚praca w zespole? Koszmar!</li>
                        <li>â™»ï¸ Ponowne uÅ¼ycie kodu? NiemoÅ¼liwe</li>
                    </ul>
                    <p style="margin-top: 40px; color: #ffd93d;">
                        <em>"Spaghetti code"</em> - wszystko ze wszystkim poplÄ…tane
                    </p>
                    <aside class="notes">
                        W latach 70. XX wieku skala oprogramowania osiÄ…gnÄ™Å‚a dziesiÄ…tki i setki tysiÄ™cy linii kodu.
                        Systemy bankowe, systemy kontroli lotÃ³w, wczesne systemy operacyjne - wszystkie ujawniÅ‚y
                        fundamentalne ograniczenia podejÅ›cia proceduralnego.
                        
                        Zmienne globalne tworzyÅ‚y problem identyfikacji odpowiedzialnoÅ›ci. W programie liczÄ…cym
                        50 tysiÄ™cy linii kodu, zmienna globalna "saldo_konta" mogÅ‚a byÄ‡ modyfikowana przez dziesiÄ…tki
                        funkcji. Wykrycie ÅºrÃ³dÅ‚a nieprawidÅ‚owej wartoÅ›ci wymagaÅ‚o analizy caÅ‚ej bazy kodu.
                        
                        Silne sprzÄ™Å¼enie miÄ™dzy komponentami oznaczaÅ‚o, Å¼e bÅ‚Ä…d w jednej funkcji mÃ³gÅ‚ propagowaÄ‡ siÄ™
                        na pozornie niepowiÄ…zane obszary systemu. Funkcje operowaÅ‚y na tych samych globalnych strukturach danych.
                        
                        Praca zespoÅ‚owa byÅ‚a utrudniona - wielu programistÃ³w modyfikowaÅ‚o te same globalne zasoby,
                        co prowadziÅ‚o do konfliktÃ³w i bÅ‚Ä™dÃ³w integracyjnych.
                        
                        Ponowne wykorzystanie kodu byÅ‚o praktycznie niemoÅ¼liwe. Funkcje byÅ‚y Å›ciÅ›le zwiÄ…zane
                        z globalnymi zmiennymi konkretnego projektu, co uniemoÅ¼liwiaÅ‚o ich przeniesienie.
                        
                        Termin "spaghetti code" opisuje tÄ™ sytuacjÄ™ - kod tak splÄ…tany, Å¼e modyfikacja
                        jednego elementu wpÅ‚ywa nieprzewidywalnie na caÅ‚y system.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie -->
                <section>
                    <h3>Potrzeba nowego podejÅ›cia</h3>
                    <div class="row" style="margin-top: 40px;">
                        <div class="column">
                            <h4 style="color: #ff6b6b;">âŒ Problem</h4>
                            <ul style="font-size: 0.8em;">
                                <li>Dane osobno od funkcji</li>
                                <li>Wszystko globalne</li>
                                <li>Brak ochrony</li>
                                <li>Trudno skalowaÄ‡</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h4 style="color: #51cf66;">âœ“ RozwiÄ…zanie</h4>
                            <ul style="font-size: 0.8em;">
                                <li>Dane + funkcje razem</li>
                                <li>Kontrolowany dostÄ™p</li>
                                <li>Ukryte szczegÃ³Å‚y</li>
                                <li>Åatwe rozszerzanie</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Analiza problemÃ³w programowania proceduralnego doprowadziÅ‚a do fundamentalnej obserwacji:
                        dane i operacje na nich sÄ… naturalnie powiÄ…zane. Konto bankowe zawiera saldo oraz operacje
                        wpÅ‚aty, wypÅ‚aty i sprawdzenia stanu. Logicznie stanowiÄ… one jednÄ… caÅ‚oÅ›Ä‡.
                        
                        Programowanie proceduralne separowaÅ‚o te elementy - zmienna "saldo" istniaÅ‚a oddzielnie
                        od funkcji "wpÅ‚aÄ‡" i "wypÅ‚aÄ‡". To prowadzi do pytania: dlaczego kod nie odzwierciedla
                        naturalnej struktury problemu?
                        
                        Koncepcja grupowania danych z operacjami to fundament programowania obiektowego.
                        Zamiast separacji, otrzymujemy encjÄ™ "Konto", ktÃ³ra zawiera zarÃ³wno dane (saldo),
                        jak i metody (wpÅ‚aÄ‡, wypÅ‚aÄ‡).
                        
                        Konieczna byÅ‚a rÃ³wnieÅ¼ kontrola dostÄ™pu do danych. BezpoÅ›rednia modyfikacja
                        "saldo = -1000" powinna byÄ‡ niemoÅ¼liwa. Tylko odpowiednie metody, zawierajÄ…ce
                        logikÄ™ walidacji, powinny mieÄ‡ prawo zmiany stanu. To jest istota enkapsulacji -
                        ukrywania danych i kontrolowania dostÄ™pu poprzez zdefiniowany interfejs.
                        
                        Dodatkowo potrzebna byÅ‚a moÅ¼liwoÅ›Ä‡ rozszerzania funkcjonalnoÅ›ci bez przepisywania kodu.
                        Mechanizm dziedziczenia pozwala na stworzenie KontoOszczÄ™dnoÅ›ciowego rozszerzajÄ…cego
                        Konto, bez koniecznoÅ›ci duplikacji kodu bazowego.
                        
                        Te obserwacje doprowadziÅ‚y do powstania koncepcji programowania obiektowego.
                    </aside>
                </section>

                <!-- Simula -->
                <section>
                    <h3>1967: Simula</h3>
                    <p><strong>Ole-Johan Dahl i Kristen Nygaard (Norwegia)</strong></p>
                    <ul>
                        <li>Symulacje (kolejki, procesy)</li>
                        <li>Wprowadzili: <strong>klasy i obiekty</strong></li>
                        <li>Pierwszy jÄ™zyk obiektowy</li>
                    </ul>
                    <aside class="notes">
                        Rok 1967, Norwegian Computing Center w Oslo. Ole-Johan Dahl i Kristen Nygaard
                        pracujÄ… nad jÄ™zykiem do symulacji dyskretnych zdarzeÅ„ - kolejek w systemach obsÅ‚ugi,
                        procesÃ³w produkcyjnych, ruchu w portach.
                        
                        Podczas projektowania jÄ™zyka symulacji zauwaÅ¼yli fundamentalnÄ… wÅ‚aÅ›ciwoÅ›Ä‡:
                        symulowane systemy skÅ‚adajÄ… siÄ™ z bytÃ³w, z ktÃ³rych kaÅ¼dy posiada wÅ‚asny stan
                        (dane) oraz zachowanie (operacje). W symulacji sklepu naturalnymi bytami sÄ…:
                        klienci posiadajÄ…cy imiÄ™, wiek, koszyk zakupÃ³w; kasjerzy majÄ…cy stanowisko
                        i szybkoÅ›Ä‡ obsÅ‚ugi; produkty charakteryzujÄ…ce siÄ™ nazwÄ…, cenÄ… i kodem.
                        
                        KaÅ¼dy byt posiada nie tylko dane, ale rÃ³wnieÅ¼ zachowania: klient czeka w kolejce,
                        wybiera produkty, pÅ‚aci; kasjer obsÅ‚uguje klienta, skanuje produkty, wydaje resztÄ™.
                        
                        Ta obserwacja doprowadziÅ‚a do stworzenia jÄ™zyka Simula z fundamentalnymi koncepcjami:
                        klasÄ… jako szablonem definiujÄ…cym strukturÄ™ i zachowanie, oraz obiektem jako
                        konkretnÄ… instancjÄ… klasy. Klasa "Klient" definiuje, Å¼e kaÅ¼dy klient posiada
                        imiÄ™, wiek i koszyk. Obiekt "Jan Kowalski" jest konkretnÄ… instancjÄ… z wartoÅ›ciami:
                        imiÄ™="Jan", wiek=35, koszyk=[mleko, chleb].
                        
                        Simula wprowadziÅ‚a rÃ³wnieÅ¼ koncepcjÄ™ dziedziczenia - moÅ¼liwoÅ›ci tworzenia
                        specjalizowanych klas na bazie klas ogÃ³lnych.
                        
                        Mimo Å¼e Simula nie osiÄ…gnÄ™Å‚a szerokiego zastosowania komercyjnego, jej koncepcje
                        staÅ‚y siÄ™ fundamentem wszystkich wspÃ³Å‚czesnych jÄ™zykÃ³w obiektowych: C++, Java, Python, C#.
                        KluczowÄ… ideÄ… jest grupowanie danych z zachowaniami w spÃ³jne encje.
                    </aside>
                </section>

                <!-- Smalltalk -->
                <section>
                    <h3>1972: Smalltalk</h3>
                    <p><strong>Alan Kay (Xerox PARC)</strong></p>
                    <ul>
                        <li>WSZYSTKO jest obiektem (nawet liczby!)</li>
                        <li>Pierwsze GUI (okienka, mysz)</li>
                        <li>UkuÅ‚ termin "programowanie obiektowe"</li>
                    </ul>
                    <aside class="notes">
                        Rok 1972, Xerox Palo Alto Research Center. Alan Kay, informatyk i wizjoner,
                        rozwija koncepcjÄ™ programowania obiektowego do jej logicznej konkluzji, tworzÄ…c
                        jÄ™zyk Smalltalk.
                        
                        Fundamentalna zasada Smalltalk: wszystko jest obiektem. Nawet wartoÅ›ci prymitywne
                        takie jak liczba 5 sÄ… obiektami posiadajÄ…cymi metody. Liczba 5 posiada metody
                        dodawania, mnoÅ¼enia, konwersji do stringa. W notacji Smalltalk: 5 + 3 to wywoÅ‚anie
                        metody dodawania na obiekcie 5 z argumentem 3. WspÃ³Å‚czeÅ›nie ten model widzimy
                        w Pythonie, gdzie (5).__add__(3) jest poprawnym wywoÅ‚aniem.
                        
                        Kay wprowadziÅ‚ rÃ³wnieÅ¼ koncepcjÄ™ komunikacji poprzez wiadomoÅ›ci. Obiekty nie
                        "wywoÅ‚ujÄ… funkcji" - wysyÅ‚ajÄ… wiadomoÅ›ci do innych obiektÃ³w, ktÃ³re decydujÄ…
                        jak na nie odpowiedzieÄ‡. To fundamentalna zmiana paradygmatu.
                        
                        Smalltalk byÅ‚ rÃ³wnieÅ¼ rewolucyjny technologicznie - Kay stworzyÅ‚ pierwsze
                        graficzne Å›rodowisko uÅ¼ytkownika oparte na oknach, ikonach i myszy. To rozwiÄ…zanie,
                        zaprezentowane w Xerox PARC, zostaÅ‚o nastÄ™pnie zaadaptowane przez Apple
                        w Macintosh oraz Microsoft w Windows.
                        
                        Alan Kay ukuÅ‚ termin "object-oriented programming" - programowanie obiektowe.
                        
                        Mimo Å¼e Smalltalk nie osiÄ…gnÄ…Å‚ dominacji w przemyÅ›le ze wzglÄ™du na wymagania
                        wydajnoÅ›ciowe, jego czysta wizja OOP wpÅ‚ynÄ™Å‚a na projektowanie wszystkich
                        pÃ³Åºniejszych jÄ™zykÃ³w obiektowych. Zasady formuÅ‚owane przez Kaya pozostajÄ…
                        aktualne 50 lat pÃ³Åºniej.
                    </aside>
                </section>

                <!-- C++ -->
                <section>
                    <h3>1983: C++</h3>
                    <p><strong>Bjarne Stroustrup</strong></p>
                    <ul>
                        <li>PoÅ‚Ä…czyÅ‚ C (szybki) + OOP (zorganizowany)</li>
                        <li>"C with Classes" â†’ C++</li>
                        <li>ProgramiÅ›ci C mogli stopniowo przejÅ›Ä‡ na OOP</li>
                    </ul>
                    <aside class="notes">
                        Rok 1983, Bell Laboratories. Bjarne Stroustrup, informatyk duÅ„skiego pochodzenia,
                        stoi przed problemem: jak wprowadziÄ‡ koncepcje obiektowe do praktyki przemysÅ‚owej,
                        gdzie dominuje jÄ™zyk C znany z wydajnoÅ›ci i kontroli niskopoziomowej?
                        
                        RozwiÄ…zaniem byÅ‚o stworzenie C++ - jÄ™zyka Å‚Ä…czÄ…cego sprawdzonÄ… efektywnoÅ›Ä‡ C
                        z moÅ¼liwoÅ›ciami organizacyjnymi programowania obiektowego. To byÅ‚ strategiczny
                        kompromis pozwalajÄ…cy na ewolucyjne przyjÄ™cie nowego paradygmatu.
                        
                        ProgramiÅ›ci C mogli kontynuowaÄ‡ pisanie kodu proceduralnego, stopniowo wprowadzajÄ…c
                        elementy obiektowe. Nie byÅ‚o koniecznoÅ›ci rewolucyjnej zmiany caÅ‚ego podejÅ›cia.
                        Kod C pozostawaÅ‚ poprawnym kodem C++, zapewniajÄ…c kompatybilnoÅ›Ä‡ wstecznÄ….
                        
                        PoczÄ…tkowo jÄ™zyk nazywaÅ‚ siÄ™ "C with Classes". Zmiana nazwy na C++ (operator
                        inkrementacji w C oznacza zwiÄ™kszenie o 1) symbolizowaÅ‚a ewolucyjny charakter jÄ™zyka.
                        
                        C++ zachowaÅ‚ fundamentalne cechy C: bezpoÅ›redni dostÄ™p do pamiÄ™ci, wskaÅºniki,
                        moÅ¼liwoÅ›Ä‡ programowania niskopoziomowego. JednoczeÅ›nie wprowadziÅ‚ klasy, dziedziczenie,
                        polimorfizm, szablony. To poÅ‚Ä…czenie czyni C++ unikalnym - pozwala na
                        niskopoziomowÄ… kontrolÄ™ (zarzÄ…dzanie kaÅ¼dym bajtem pamiÄ™ci) oraz wysokopoziomowÄ…
                        organizacjÄ™ (eleganckie hierarchie klas).
                        
                        Zastosowania C++: systemy operacyjne (Windows, Linux), silniki gier (Unreal Engine),
                        oprogramowanie embedded (automotive, avionics), aplikacje wymagajÄ…ce wydajnoÅ›ci
                        (przeglÄ…darki Chrome, Firefox).
                        
                        C++ nie jest jÄ™zykiem stworzonym od podstaw dla OOP. Jest ewolucjÄ… C w kierunku
                        obiektowoÅ›ci, zachowujÄ…cÄ… kompatybilnoÅ›Ä‡ i wydajnoÅ›Ä‡. To wyjaÅ›nia wiele jego
                        osobliwoÅ›ci - koegzystencja struktur i klas, operatorÃ³w new/malloc, rÃ³Å¼ne
                        konwencje. Zrozumienie tej ewolucji jest kluczem do zrozumienia jÄ™zyka.
                    </aside>
                </section>

                <!-- Java -->
                <section>
                    <h3>1995: Java</h3>
                    <p><strong>James Gosling (Sun Microsystems)</strong></p>
                    <ul>
                        <li>"Write once, run anywhere" (JVM)</li>
                        <li>Automatyczne zarzÄ…dzanie pamiÄ™ciÄ…</li>
                        <li>Wymuszony OOP - wszystko w klasach</li>
                    </ul>
                    <aside class="notes">
                        Rok 1995, Sun Microsystems. Kontekst: ekspansja Internetu, heterogeniczne
                        Å›rodowiska sprzÄ™towe (PC, Mac, Unix), potrzeba przenoÅ›noÅ›ci oprogramowania.
                        James Gosling projektuje JavÄ™ z fundamentalnym zaÅ‚oÅ¼eniem: "Write once, run anywhere".
                        
                        Mechanizm realizacji: Java Virtual Machine (JVM). Kompilacja nie produkuje
                        kodu maszynowego specyficznego dla platformy, lecz bytecode - kod poÅ›redni.
                        JVM na kaÅ¼dej platformie interpretuje ten bytecode. Ten sam plik .class
                        wykonuje siÄ™ identycznie na Windows, macOS, Linux.
                        
                        Java wprowadziÅ‚a dwie fundamentalne zmiany wzglÄ™dem C++:
                        
                        Pierwsza: Garbage Collector - automatyczne zarzÄ…dzanie pamiÄ™ciÄ…. W C++ programista
                        musi pamiÄ™taÄ‡: new wymaga delete. Brak delete prowadzi do wycieku pamiÄ™ci - program
                        konsumuje coraz wiÄ™cej RAM. W Javie Garbage Collector automatycznie identyfikuje
                        i usuwa nieuÅ¼ywane obiekty. To znaczÄ…co upraszcza programowanie, kosztem mniejszej
                        kontroli i potencjalnie wolniejszego dziaÅ‚ania podczas zbierania Å›mieci.
                        
                        Druga: Wymuszony paradygmat obiektowy. W Javie nie moÅ¼na napisaÄ‡ kodu poza klasÄ….
                        Funkcja main() musi byÄ‡ metodÄ… statycznÄ… klasy. Zmienne globalne nie istniejÄ… -
                        muszÄ… byÄ‡ statycznymi polami klas. Wszystko musi byÄ‡ obiektem (z wyjÄ…tkiem
                        typÃ³w prymitywnych, ktÃ³re posiadajÄ… wrappery obiektowe: int â†’ Integer).
                        
                        To wymuszenie paradygmatu miaÅ‚o znaczÄ…cy efekt edukacyjny. W C++ moÅ¼na mieszaÄ‡
                        kod proceduralny z obiektowym. Java nie pozwala na kompromisy - tylko czyste OOP.
                        Miliony programistÃ³w uczÄ…cych siÄ™ Javy musiaÅ‚o opanowaÄ‡ wÅ‚aÅ›ciwe praktyki obiektowe.
                        
                        WspÃ³Å‚czesne zastosowania Javy: aplikacje webowe (backend - Spring, Hibernate),
                        Android (choÄ‡ obecnie Kotlin zyskuje przewagÄ™), systemy korporacyjne (bankowoÅ›Ä‡,
                        ubezpieczenia, gdzie dominuje Java Enterprise Edition).
                        
                        Dla programistÃ³w C++ Java reprezentuje alternatywnÄ… filozofiÄ™: rezygnacja
                        z niskopoziomowej kontroli w zamian za bezpieczeÅ„stwo i przenoÅ›noÅ›Ä‡. Oba podejÅ›cia
                        majÄ… uzasadnienie w odpowiednich kontekstach zastosowaÅ„.
                    </aside>
                </section>

                <!-- Dlaczego OOP wygraÅ‚o -->
                <section>
                    <h3>Dlaczego OOP?</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div style="margin: 20px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>âœ… Enkapsulacja</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Dane chronione - tylko metody mogÄ… je zmieniaÄ‡
                            </p>
                        </div>
                        <div style="margin: 20px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>âœ… ModularnoÅ›Ä‡</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                NiezaleÅ¼ne obiekty - Å‚atwiej debugowaÄ‡
                            </p>
                        </div>
                        <div style="margin: 20px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>âœ… Wielokrotne uÅ¼ycie</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Dziedziczenie - nie piszesz od zera
                            </p>
                        </div>
                        <div style="margin: 20px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>âœ… Naturalne myÅ›lenie</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Kod = rzeczywistoÅ›Ä‡ (Klient, Produkt, ZamÃ³wienie)
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Programowanie obiektowe rozwiÄ…zaÅ‚o fundamentalne problemy inÅ¼ynierii oprogramowania
                        na duÅ¼Ä… skalÄ™. Analiza czterech kluczowych zalet:
                        
                        ENKAPSULACJA - ukrywanie implementacji i kontrola dostÄ™pu.
                        
                        RozwaÅ¼my klasÄ™ BankAccount. Pole balance jest prywatne. DostÄ™p moÅ¼liwy wyÅ‚Ä…cznie
                        poprzez metody deposit() i withdraw(). Te metody zawierajÄ… logikÄ™ walidacji:
                        deposit() weryfikuje czy kwota jest dodatnia, withdraw() sprawdza czy saldo
                        jest wystarczajÄ…ce. BezpoÅ›rednie przypisanie balance = -1000000 jest niemoÅ¼liwe -
                        kompilator zgÅ‚osi bÅ‚Ä…d dostÄ™pu do prywatnego pola.
                        
                        To fundamentalna rÃ³Å¼nica wzglÄ™dem programowania proceduralnego, gdzie kaÅ¼da
                        zmienna globalna moÅ¼e byÄ‡ modyfikowana przez dowolny fragment kodu. Enkapsulacja
                        gwarantuje, Å¼e dane mogÄ… byÄ‡ zmieniane tylko w kontrolowany sposÃ³b.
                        
                        MODULARNOÅšÄ† - niezaleÅ¼noÅ›Ä‡ komponentÃ³w.
                        
                        KaÅ¼da klasa stanowi niezaleÅ¼ny moduÅ‚. Klasa User nie posiada wiedzy o klasie Invoice.
                        Modyfikacja implementacji User nie wpÅ‚ywa na Invoice, o ile interfejs publiczny
                        (publiczne metody) pozostaje niezmieniony. Reszta systemu nie zauwaÅ¼a wewnÄ™trznych zmian.
                        
                        W systemie skÅ‚adajÄ…cym siÄ™ ze stu klas, kaÅ¼da stanowi czarnÄ… skrzynkÄ™.
                        Interfejs publiczny definiuje wejÅ›cie i wyjÅ›cie, implementacja jest ukryta.
                        Debugowanie staje siÄ™ prostsze - bÅ‚Ä…d w klasie Payment wymaga analizy tylko tej klasy,
                        nie caÅ‚ego systemu.
                        
                        WIELOKROTNE UÅ»YCIE - dziedziczenie i kompozycja.
                        
                        Klasa Animal definiuje metody eat(), sleep(), makeSound(). Klasa Dog dziedziczy
                        po Animal, automatycznie otrzymujÄ…c te metody. Programista dodaje tylko metodÄ™ bark().
                        Nie ma duplikacji kodu bazowego.
                        
                        Kompozycja: klasa Car zawiera obiekt Engine. Ten sam Engine moÅ¼e byÄ‡ uÅ¼ywany
                        w klasie Motorcycle. Ponowne wykorzystanie bez kopiowania.
                        
                        W programowaniu proceduralnym ponowne uÅ¼ycie wymaga copy-paste. Modyfikacja
                        w jednym miejscu wymaga modyfikacji we wszystkich kopiach. To prowadzi do
                        bÅ‚Ä™dÃ³w i trudnoÅ›ci w utrzymaniu.
                        
                        NATURALNE MODELOWANIE - odzwierciedlenie rzeczywistoÅ›ci.
                        
                        ProjektujÄ…c system e-commerce, naturalnie identyfikujemy encje: Klient (imiÄ™, adres,
                        historia zamÃ³wieÅ„), Produkt (nazwa, cena, opis), Koszyk (lista produktÃ³w, suma),
                        ZamÃ³wienie (klient, produkty, status).
                        
                        OOP pozwala bezpoÅ›rednio zapisaÄ‡ tÄ™ strukturÄ™ w kodzie:
                        class Customer { }, class Product { }, class ShoppingCart { }, class Order { }
                        
                        Kod staje siÄ™ samodokumentujÄ…cym. Nowy programista analizujÄ…cy projekt
                        natychmiast rozumie strukturÄ™ systemu przez nazwy klas. Nie musi analizowaÄ‡
                        tysiÄ™cy linii funkcji o niejasnych nazwach.
                        
                        To sÄ… cztery filary programowania obiektowego: enkapsulacja, modularnoÅ›Ä‡,
                        wielokrotne uÅ¼ycie, naturalne modelowanie. Nie sÄ… abstrakcyjnymi koncepcjami -
                        to praktyczne narzÄ™dzia rozwiÄ…zujÄ…ce realne problemy inÅ¼ynierskie.
                    </aside>
                </section>

                <!-- PorÃ³wnanie -->
                <section>
                    <h3>PorÃ³wnanie: Proceduralne vs Obiektowe</h3>
                    <div class="row">
                        <div class="column">
                            <h4 style="color: #ff6b6b;">âŒ Proceduralnie</h4>
                            <pre style="font-size: 13px;"><code class="hljs c">int saldo = 1000;

void wplac(int kwota) {
    saldo += kwota;
}

void wyplac(int kwota) {
    saldo -= kwota;
}

// KaÅ¼dy moÅ¼e:
saldo = -5000; // Ups!
</code></pre>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">âœ… Obiektowo</h4>
                            <pre style="font-size: 13px;"><code class="hljs cpp">class Konto {
private:
    int saldo;
public:
    void wplac(int kwota) {
        if (kwota > 0)
            saldo += kwota;
    }
    void wyplac(int kwota) {
        if (kwota > 0 && kwota <= saldo)
            saldo -= kwota;
    }
};

// Chronione!
// k.saldo = -5000; // BÅÄ„D!
</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        PorÃ³wnanie implementacji konta bankowego w paradygmatach proceduralnym i obiektowym
                        ilustruje fundamentalne rÃ³Å¼nice.
                        
                        PODEJÅšCIE PROCEDURALNE:
                        
                        Zmienna "saldo" jest globalna. KaÅ¼dy fragment programu ma do niej dostÄ™p i moÅ¼e
                        jÄ… modyfikowaÄ‡. Funkcje wplac() i wyplac() operujÄ… na tej zmiennej. Problem:
                        identyfikacja wszystkich miejsc modyfikujÄ…cych saldo wymaga przeszukania caÅ‚ego kodu.
                        
                        Brak walidacji. Funkcja wyplac() nie weryfikuje czy saldo jest wystarczajÄ…ce.
                        Funkcja wplac() nie sprawdza czy kwota jest dodatnia. NajwiÄ™kszy problem:
                        bezpoÅ›rednie przypisanie saldo = -5000 jest poprawne skÅ‚adniowo.
                        
                        Kompilator akceptuje taki kod. Program kompiluje siÄ™ i uruchamia. BÅ‚Ä…d manifestuje
                        siÄ™ w runtime, potencjalnie po dÅ‚uÅ¼szym okresie dziaÅ‚ania systemu. System produkcyjny
                        moÅ¼e wykazaÄ‡ nieprawidÅ‚owe saldo klienta: -5000 zÅ‚.
                        
                        PODEJÅšCIE OBIEKTOWE:
                        
                        Klasa Konto. Pole saldo jest prywatne. DostÄ™p ma wyÅ‚Ä…cznie kod wewnÄ…trz klasy.
                        Z zewnÄ…trz dostÄ™p jest niemoÅ¼liwy.
                        
                        Metody wplac() i wyplac() sÄ… publiczne - stanowiÄ… interfejs klasy. ZawierajÄ…
                        logikÄ™ walidacji: wplac() weryfikuje if (kwota > 0), wyplac() sprawdza
                        if (kwota > 0 && kwota <= saldo).
                        
                        PrÃ³ba bezpoÅ›redniej modyfikacji k.saldo = -5000 jest bÅ‚Ä™dem kompilacji.
                        Kompilator zgÅ‚osi: "'saldo' is a private member of 'Konto'".
                        Program nie skompiluje siÄ™. BÅ‚Ä…d zostaje wykryty przed uruchomieniem, nie po
                        tygodniach dziaÅ‚ania w Å›rodowisku produkcyjnym.
                        
                        To ilustruje fundamentalnÄ… wartoÅ›Ä‡ OOP: kontrola i bezpieczeÅ„stwo. Projektant
                        klasy definiuje poprawne operacje. UÅ¼ytkownik klasy (inny programista, moÅ¼liwe
                        ten sam programista po upÅ‚ywie czasu) nie moÅ¼e naruszyÄ‡ niezmiennikÃ³w. Kompilator
                        egzekwuje reguÅ‚y.
                        
                        Ten przykÅ‚ad Ğ´ĞµĞ¼Ğ¾Ğ½struje nie teoretycznÄ… koncepcjÄ™, lecz praktyczne narzÄ™dzie.
                        BezpieczeÅ„stwo, kontrola, mniej bÅ‚Ä™dÃ³w, Å‚atwiejsze utrzymanie. To konkretne
                        korzyÅ›ci inÅ¼ynierskie, nie abstrakcje akademickie.
                    </aside>
                </section>

                <!-- Podsumowanie -->
                <section>
                    <h3>Podsumowanie</h3>
                    <p style="font-size: 1.1em; margin-bottom: 20px;">
                        <strong>OOP powstaÅ‚o, aby kod byÅ‚:</strong>
                    </p>
                    <ul style="font-size: 0.9em; line-height: 1.8;">
                        <li>ğŸ“¦ <strong>Bezpieczniejszy</strong> - chronione dane</li>
                        <li>ğŸ§© <strong>Modularny</strong> - Å‚atwiej zarzÄ…dzaÄ‡</li>
                        <li>â™»ï¸ <strong>Wielokrotnego uÅ¼ytku</strong> - dziedziczenie</li>
                        <li>ğŸŒ <strong>ZrozumiaÅ‚y</strong> - jak rzeczywistoÅ›Ä‡</li>
                    </ul>
                    <div style="margin-top: 30px; padding: 20px; background: rgba(52, 152, 219, 0.1); border-radius: 10px;">
                        <p style="font-size: 0.9em; text-align: center; font-style: italic;">
                            "Nie programujemy dla komputerÃ³w, programujemy dla ludzi."
                        </p>
                    </div>
                    <aside class="notes">
                        Podsumowanie analizy historycznej:
                        
                        Programowanie obiektowe nie jest arbitralnÄ… abstrakcjÄ… teoretycznÄ…. Jest odpowiedziÄ…
                        na konkretne problemy inÅ¼ynierskie, ktÃ³re ujawniÅ‚y siÄ™ w praktyce tworzenia
                        oprogramowania w latach 60-70 XX wieku.
                        
                        W poczÄ…tkowej fazie, gdy programy liczyÅ‚y setki linii kodu, paradygmat proceduralny
                        byÅ‚ wystarczajÄ…cy. Jednak wraz ze wzrostem skali - systemy osiÄ…gajÄ…ce miliony linii
                        kodu, takie jak Windows, Oracle, systemy bankowe - podejÅ›cie proceduralne okazaÅ‚o siÄ™
                        nieadekwatne. Potrzebna byÅ‚a lepsza organizacja i kontrola zÅ‚oÅ¼onoÅ›ci.
                        
                        Programowanie obiektowe dostarcza narzÄ™dzi do konstrukcji zÅ‚oÅ¼onych systemÃ³w
                        charakteryzujÄ…cych siÄ™: zrozumiaÅ‚oÅ›ciÄ… (klasy odzwierciedlajÄ… strukturÄ™ problemu),
                        bezpieczeÅ„stwem (enkapsulacja chroni niezmienniki), modularnoÅ›ciÄ… (Å‚atwiejsze
                        zarzÄ…dzanie i debugowanie), rozszerzalnoÅ›ciÄ… (dziedziczenie i polimorfizm).
                        
                        W kolejnych zajÄ™ciach teoria zostanie przeniesiona do praktyki. Studenci bÄ™dÄ…
                        implementowaÄ‡ klasy, stosowaÄ‡ enkapsulacjÄ™, konstruowaÄ‡ hierarchie dziedziczenia,
                        wykorzystywaÄ‡ polimorfizm. To nie bÄ™dzie teoretyczna abstrakcja - bÄ™dzie praktyczne
                        zastosowanie narzÄ™dzi inÅ¼ynierskich.
                        
                        NaleÅ¼y pamiÄ™taÄ‡: nauka programowania obiektowego jest procesem. PoczÄ…tkowo moÅ¼e
                        wydawaÄ‡ siÄ™ nadmiernie skomplikowane. Pytanie "dlaczego caÅ‚a klasa zamiast prostej
                        funkcji?" jest naturalne na poczÄ…tkowym etapie. Jednak wraz z doÅ›wiadczeniem,
                        szczegÃ³lnie przy projektach wiÄ™kszej skali, zalety OOP stajÄ… siÄ™ oczywiste.
                        
                        WspÃ³Å‚czesne oprogramowanie - 90% systemÃ³w produkcyjnych - wykorzystuje paradygmat
                        obiektowy. Od systemÃ³w operacyjnych (Windows, Linux), przez platformy mobilne
                        (Android), po systemy webowe (Facebook, Google). To nie przypadek. OOP sprawdza siÄ™
                        w praktyce inÅ¼ynierskiej.
                        
                        SkutecznoÅ›Ä‡ metody weryfikuje siÄ™ w praktyce, nie w teorii. OOP funkcjonuje
                        efektywnie w maÅ‚ych projektach (Ä‡wiczenia akademickie), Å›rednich (projekty
                        zaliczeniowe), i co najistotniejsze - w systemach przemysÅ‚owych o skali
                        milionÃ³w linii kodu.
                        
                        Cytat na zakoÅ„czenie: "Nie programujemy dla komputerÃ³w, programujemy dla ludzi."
                        
                        Komputer wykonuje kaÅ¼dy poprawny kod - proceduralny, obiektowy, assembly.
                        Jednak ludzie - programista za miesiÄ…c, kolega przejmujÄ…cy projekt, przyszÅ‚y
                        maintainer - wymagajÄ… kodu zrozumiaÅ‚ego.
                        
                        Programowanie obiektowe tworzy kod czytelny dla ludzi. Kod do ktÃ³rego moÅ¼na wrÃ³ciÄ‡
                        po roku i zrozumieÄ‡ jego strukturÄ™. Kod moÅ¼liwy do przekazania bez wielogodzinnych
                        sesji wyjaÅ›niajÄ…cych.
                        
                        WartoÅ›Ä‡ OOP nie tkwi w szybkoÅ›ci wykonania (choÄ‡ C++ jest efektywny) ani oszczÄ™dnoÅ›ci
                        pamiÄ™ci (choÄ‡ obiekty mogÄ… byÄ‡ kompaktowe). Fundamentalna wartoÅ›Ä‡ to: zrozumiaÅ‚oÅ›Ä‡,
                        utrzymywalnoÅ›Ä‡, skalowalnoÅ›Ä‡.
                        
                        NastÄ™pne zajÄ™cia: implementacja pierwszej klasy w C++.
                    </aside>
                </section>

            </section>
            <!-- Koniec sekcji: Historia programowania -->
             			<section data-background-color="black">
				<section data-auto-animate>
					<h2 style="color: white;">Zadanie domowe + kartkÃ³wka</h2>
					<p>ObejrzeÄ‡ materiaÅ‚y video, aby przygotowaÄ‡ sie do kartkÃ³wki.</p>
					<small>
						<ul>
							<li><a href="https://youtu.be/D6EI7EbEN4Q">Czym jest Git? - Kurs gita po polsku #1/12</a>
							</li>
							<li><a href="https://youtu.be/4bXuEv2R3W4">Jak zapisaÄ‡ zmiany - Kurs gita po polsku
									#2/12</a></li>
							<li><a href="https://youtu.be/gG80UsfMXsU">PrzestrzeÅ„ robocza i stage - Kurs gita po polsku
									#3/12</a></li>
							<li><a href="https://youtu.be/I8lQK0NK0lY">Czym jest branch? - Kurs git po polsku #8/12</a>
							</li>
							<li><a href="https://youtu.be/7myDXGfEnds">Zdalne repozytorium i fork - Kurs git po polsku
									#9/12</a></li>
							<li><a href="https://youtu.be/mxDN0rYQyGA">RozwiÄ…zywanie konfliktÃ³w - Kurs git po polsku
									#10/12</a></li>
						</ul>
					</small>
					<br />
					<small>PrzykÅ‚adowe pytania na kartkÃ³wkÄ™:
						<ul>
							<li>Co to jest system kontroli wersji?</li>
							<li>WymieÅ„ podstawowe podstawowe komendy Gita i ich przeznaczenie</li>
							<li>Co to jest repozytorium?</li>
							<li>Co to jest branch?</li>
							<li>Co to jest commit?</li>
						</ul>
					</small>

				</section>
			</section>

        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
        });
    </script>

</body>

</html>