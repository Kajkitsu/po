<!doctype html>
<html lang="pl">

<head>
    <meta charset="utf-8">
    <title>Programowanie Obiektowe - Nowa Wersja</title>
    <meta name="description" content="PO LAB">
    <meta name="author" content="Norbert Waszkowiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .row {
            display: flex;
        }

        .column {
            flex: 50%;
            padding: 10px;
        }

        .small-font pre {
            font-size: 13px;
            margin-left: 0;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <section data-background-gradient="linear-gradient(45deg, #2c3e50, #3498db)">

                <!-- 1. Slajd powitalny -->
                <section style="text-align: left;">
                    <h1>Programowanie Obiektowe</h1>

                    <div style="margin-top: 40px;">
                        <p><strong>ProwadzÄ…cy:</strong> por. mgr inÅ¼. Norbert Waszkowiak</p>

                        <div style="margin-top: 30px; font-size: 0.6em;">
                            <p>ğŸ“ <strong>Tel:</strong> 261 839 060</p>
                            <p>ğŸ“§ <strong>Email:</strong> norbert.waszkowiak@wat.edu.pl</p>
                            <p>ğŸ¢ <strong>PokÃ³j:</strong> bud. 100, pok. 254B</p>
                            <p>ğŸ’¬ <strong>Konsultacje:</strong> po wczeÅ›niejszym umÃ³wieniu (online/stacjonarnie)</p>
                        </div>
                    </div>

                </section>
            </section>

            <!-- 2. Historia programowania -->
            <section data-background-gradient="linear-gradient(37deg, #1e3c72, #2a5298)">

                <!-- Slajd tytuÅ‚owy -->
                <section>
                    <h2>Historia programowania</h2>
                    <h3>Programowanie proceduralne vs obiektowe</h3>
                    <aside class="notes">
                        Programowanie obiektowe nie powstaÅ‚o przypadkowo ani jako abstrakcyjna teoria akademicka.
                        Jest odpowiedziÄ… na konkretne problemy inÅ¼ynierskie, ktÃ³re wystÄ…piÅ‚y w praktyce
                        tworzenia oprogramowania w latach 60. i 70. XX wieku.

                        W tej czÄ™Å›ci wykÅ‚adu omÃ³wimy ewolucjÄ™ paradygmatÃ³w programowania oraz przyczyny,
                        dla ktÃ³rych programowanie obiektowe staÅ‚o siÄ™ dominujÄ…cym podejÅ›ciem w inÅ¼ynierii
                        oprogramowania.
                        Analiza historyczna pozwoli zrozumieÄ‡, Å¼e OOP jest narzÄ™dziem rozwiÄ…zujÄ…cym realne problemy,
                        a nie jedynie teoretycznÄ… koncepcjÄ….
                    </aside>
                </section>

                <!-- Programowanie proceduralne -->
                <section>
                    <h3>Programowanie proceduralne</h3>
                    <p><strong>Lata 50-60. XX wieku</strong></p>
                    <ul>
                        <li>Program = lista instrukcji wykonywanych kolejno</li>
                        <li>Dane oddzielone od funkcji</li>
                        <li>PrzykÅ‚ady: Fortran, COBOL, C</li>
                    </ul>
                    <pre style="font-size: 16px; margin-top: 30px;"><code class="hljs c" data-trim>
int suma = 0;
for(int i = 0; i < 10; i++) {
    suma += i;
}
printf("Suma: %d", suma);
                    </code></pre>
                    <aside class="notes">
                        Programowanie proceduralne charakteryzuje siÄ™ sekwencyjnym wykonywaniem instrukcji.
                        Program skÅ‚ada siÄ™ ze zmiennych przechowujÄ…cych dane oraz procedur (funkcji) operujÄ…cych na tych
                        danych.
                        KluczowÄ… cechÄ… tego paradygmatu jest separacja danych od logiki przetwarzania.

                        JÄ™zyki takie jak Fortran (1957) sÅ‚uÅ¼yÅ‚y obliczeniom naukowym, COBOL (1959)
                        zastosowaniom biznesowym, a C (1972) programowaniu systemowemu. Wszystkie opieraÅ‚y siÄ™
                        na paradygmacie proceduralnym.

                        PodejÅ›cie to byÅ‚o efektywne dla programÃ³w o ograniczonej zÅ‚oÅ¼onoÅ›ci - rzÄ™du setek linii kodu.
                        Jednak wraz ze wzrostem skali oprogramowania zaczÄ™Å‚y ujawniaÄ‡ siÄ™ fundamentalne problemy tego
                        modelu.
                    </aside>
                </section>

                <!-- Problem -->
                <section>
                    <h3>Problem: chaos w duÅ¼ych programach</h3>
                    <ul>
                        <li>ğŸ“ˆ TysiÄ…ce linii w jednym pliku</li>
                        <li>ğŸ”„ Zmienne globalne - kto je zmienia?</li>
                        <li>ğŸ› BÅ‚Ä…d w jednym miejscu = awaria caÅ‚oÅ›ci</li>
                        <li>ğŸ‘¥ WspÃ³Å‚praca w zespole? Koszmar!</li>
                        <li>â™»ï¸ Ponowne uÅ¼ycie kodu? NiemoÅ¼liwe</li>
                    </ul>
                    <p style="margin-top: 40px; color: #ffd93d;">
                        <em>"Spaghetti code"</em> - wszystko ze wszystkim poplÄ…tane
                    </p>
                    <aside class="notes">
                        W latach 70. XX wieku skala oprogramowania osiÄ…gnÄ™Å‚a dziesiÄ…tki i setki tysiÄ™cy linii kodu.
                        Systemy bankowe, systemy kontroli lotÃ³w, wczesne systemy operacyjne - wszystkie ujawniÅ‚y
                        fundamentalne ograniczenia podejÅ›cia proceduralnego.

                        Zmienne globalne tworzyÅ‚y problem identyfikacji odpowiedzialnoÅ›ci. W programie liczÄ…cym
                        50 tysiÄ™cy linii kodu, zmienna globalna "saldo_konta" mogÅ‚a byÄ‡ modyfikowana przez dziesiÄ…tki
                        funkcji. Wykrycie ÅºrÃ³dÅ‚a nieprawidÅ‚owej wartoÅ›ci wymagaÅ‚o analizy caÅ‚ej bazy kodu.

                        Silne sprzÄ™Å¼enie miÄ™dzy komponentami oznaczaÅ‚o, Å¼e bÅ‚Ä…d w jednej funkcji mÃ³gÅ‚ propagowaÄ‡ siÄ™
                        na pozornie niepowiÄ…zane obszary systemu. Funkcje operowaÅ‚y na tych samych globalnych
                        strukturach danych.

                        Praca zespoÅ‚owa byÅ‚a utrudniona - wielu programistÃ³w modyfikowaÅ‚o te same globalne zasoby,
                        co prowadziÅ‚o do konfliktÃ³w i bÅ‚Ä™dÃ³w integracyjnych.

                        Ponowne wykorzystanie kodu byÅ‚o praktycznie niemoÅ¼liwe. Funkcje byÅ‚y Å›ciÅ›le zwiÄ…zane
                        z globalnymi zmiennymi konkretnego projektu, co uniemoÅ¼liwiaÅ‚o ich przeniesienie.

                        Termin "spaghetti code" opisuje tÄ™ sytuacjÄ™ - kod tak splÄ…tany, Å¼e modyfikacja
                        jednego elementu wpÅ‚ywa nieprzewidywalnie na caÅ‚y system.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie -->
                <section>
                    <h3>Potrzeba nowego podejÅ›cia</h3>
                    <p style="font-size: 0.9em;">Analiza problemÃ³w programowania proceduralnego prowadzi do
                        fundamentalnej obserwacji:</p>
                    <div
                        style="margin-top: 30px; padding: 20px; background: rgba(52, 152, 219, 0.1); border-radius: 10px;">
                        <p style="font-size: 0.95em;">
                            <strong>Dane i operacje na nich sÄ… naturalnie powiÄ…zane!</strong>
                        </p>
                    </div>
                    <aside class="notes">
                        Analiza problemÃ³w programowania proceduralnego doprowadziÅ‚a do fundamentalnej obserwacji:
                        dane i operacje na nich sÄ… naturalnie powiÄ…zane.

                        W kolejnych slajdach zobaczymy konkretne przykÅ‚ady tego problemu i jego rozwiÄ…zania.
                    </aside>
                </section>

                <!-- PrzykÅ‚ad: Konto bankowe - problem proceduralny -->
                <section>
                    <h3>Problem: Dane oddzielone od operacji</h3>
                    <p style="font-size: 0.85em;">Konto bankowe w podejÅ›ciu proceduralnym:</p>
                    <pre style="font-size: 14px;"><code class="hljs c" data-trim>
// Dane
int saldo = 1000;
char* wlasciciel = "Jan Kowalski";

// Operacje (gdzieÅ› indziej w kodzie)
void wplac(int kwota) {
    saldo += kwota;
}

void wyplac(int kwota) {
    saldo -= kwota;
}

int sprawdz_saldo() {
    return saldo;
}
                    </code></pre>
                    <p style="font-size: 0.8em; color: #ff6b6b; margin-top: 20px;">
                        âŒ Zmienna <code>saldo</code> istnieje oddzielnie od funkcji <code>wpÅ‚aÄ‡</code> i
                        <code>wypÅ‚aÄ‡</code>
                    </p>
                    <aside class="notes">
                        Konto bankowe zawiera saldo oraz operacje wpÅ‚aty, wypÅ‚aty i sprawdzenia stanu.
                        Logicznie stanowiÄ… one jednÄ… caÅ‚oÅ›Ä‡.

                        Jednak programowanie proceduralne separuje te elementy - zmienna "saldo" istnieje
                        oddzielnie od funkcji "wpÅ‚aÄ‡" i "wypÅ‚aÄ‡".

                        To prowadzi do pytania: dlaczego kod nie odzwierciedla naturalnej struktury problemu?
                    </aside>
                </section>

                <!-- Naturalne grupowanie -->
                <section>
                    <h3>Naturalne grupowanie danych i operacji</h3>
                    <div class="row" style="margin-top: 30px;">
                        <div class="column">
                            <h4 style="color: #ff6b6b; font-size: 0.9em;">âŒ Proceduralnie</h4>
                            <pre style="font-size: 12px;"><code class="hljs c" data-trim>
// Dane
int saldo;
char* wlasciciel;

// Funkcje (oddzielnie)
void wplac(int kwota);
void wyplac(int kwota);
int sprawdz_saldo();
                            </code></pre>
                            <p style="font-size: 0.75em;">Separacja danych i logiki</p>
                        </div>
                        <div class="column">
                            <h4 style="color: #51cf66; font-size: 0.9em;">âœ“ Obiektowo</h4>
                            <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class Konto {
    // Dane + Metody razem
    int saldo;
    string wlasciciel;
    
    void wplac(int kwota);
    void wyplac(int kwota);
    int sprawdz_saldo();
};
                            </code></pre>
                            <p style="font-size: 0.75em;">Dane i logika w jednej encji</p>
                        </div>
                    </div>
                    <aside class="notes">
                        Koncepcja grupowania danych z operacjami to fundament programowania obiektowego.
                        Zamiast separacji, otrzymujemy encjÄ™ "Konto", ktÃ³ra zawiera zarÃ³wno dane (saldo, wÅ‚aÅ›ciciel),
                        jak i metody (wpÅ‚aÄ‡, wypÅ‚aÄ‡, sprawdÅº saldo).

                        To jest istota OOP - dane i zachowania razem tworzÄ… spÃ³jnÄ… caÅ‚oÅ›Ä‡.
                    </aside>
                </section>

                <!-- Problem: Brak kontroli dostÄ™pu -->
                <section>
                    <h3>Problem: Brak kontroli dostÄ™pu</h3>
                    <pre style="font-size: 14px;"><code class="hljs c" data-trim>
int saldo = 1000;

void wyplac(int kwota) {
    saldo -= kwota;  // Brak walidacji!
}

// W innym miejscu programu:
saldo = -1000000;  // KaÅ¼dy moÅ¼e to zrobiÄ‡!
wyplac(5000);      // Saldo teraz: -1005000
                    </code></pre>
                    <div
                        style="margin-top: 20px; padding: 15px; background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b;">
                        <p style="font-size: 0.85em;">
                            <strong>Problem:</strong> BezpoÅ›rednia modyfikacja <code>saldo = -1000000</code> jest
                            moÅ¼liwa!
                        </p>
                    </div>
                    <aside class="notes">
                        W podejÅ›ciu proceduralnym kaÅ¼da zmienna globalna moÅ¼e byÄ‡ modyfikowana przez dowolny fragment
                        kodu.
                        BezpoÅ›rednie przypisanie "saldo = -1000000" jest poprawne skÅ‚adniowo.

                        Kompilator akceptuje taki kod. Program kompiluje siÄ™ i uruchamia. BÅ‚Ä…d manifestuje
                        siÄ™ w runtime, potencjalnie po dÅ‚uÅ¼szym okresie dziaÅ‚ania systemu.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie: Enkapsulacja -->
                <section>
                    <h3>RozwiÄ…zanie: Enkapsulacja</h3>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
class Konto {
private:
    int saldo;  // Chronione!
    
public:
    void wplac(int kwota) {
        if (kwota > 0)  // Walidacja
            saldo += kwota;
    }
    
    void wyplac(int kwota) {
        if (kwota > 0 && kwota <= saldo)  // Walidacja
            saldo -= kwota;
    }
};

// Konto k;
// k.saldo = -1000000;  // BÅÄ„D KOMPILACJI!
                    </code></pre>
                    <div
                        style="margin-top: 15px; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                        <p style="font-size: 0.85em;">
                            âœ… <strong>Kontrola dostÄ™pu:</strong> tylko metody mogÄ… zmieniaÄ‡ dane
                        </p>
                    </div>
                    <aside class="notes">
                        Konieczna byÅ‚a kontrola dostÄ™pu do danych. BezpoÅ›rednia modyfikacja "saldo = -1000"
                        powinna byÄ‡ niemoÅ¼liwa. Tylko odpowiednie metody, zawierajÄ…ce logikÄ™ walidacji,
                        powinny mieÄ‡ prawo zmiany stanu.

                        To jest istota enkapsulacji - ukrywania danych i kontrolowania dostÄ™pu poprzez
                        zdefiniowany interfejs.

                        Pole saldo jest prywatne. PrÃ³ba bezpoÅ›redniej modyfikacji k.saldo=-1000000
                        jest bÅ‚Ä™dem kompilacji. Kompilator zgÅ‚osi bÅ‚Ä…d przed uruchomieniem programu.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie: RozszerzalnoÅ›Ä‡ -->
                <section>
                    <h3>RozwiÄ…zanie: RozszerzalnoÅ›Ä‡</h3>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
class Konto {
protected:
    int saldo;
public:
    void wplac(int kwota) { /* ... */ }
    void wyplac(int kwota) { /* ... */ }
};

// Rozszerzenie bez przepisywania!
class KontoOszczednosciowe : public Konto {
private:
    float oprocentowanie;
public:
    void nalicz_odsetki() {
        saldo += saldo * oprocentowanie;
    }
};
                    </code></pre>
                    <div
                        style="margin-top: 15px; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                        <p style="font-size: 0.85em;">
                            âœ… <strong>Dziedziczenie:</strong> rozszerzamy bez duplikacji kodu
                        </p>
                    </div>
                    <aside class="notes">
                        Potrzebna byÅ‚a moÅ¼liwoÅ›Ä‡ rozszerzania funkcjonalnoÅ›ci bez przepisywania kodu.
                        Mechanizm dziedziczenia pozwala na stworzenie KontoOszczÄ™dnoÅ›ciowego rozszerzajÄ…cego
                        Konto, bez koniecznoÅ›ci duplikacji kodu bazowego.

                        KontoOszczÄ™dnoÅ›ciowe automatycznie otrzymuje metody wpÅ‚aÄ‡ i wypÅ‚aÄ‡ z klasy bazowej,
                        dodajÄ…c tylko nowÄ… funkcjonalnoÅ›Ä‡ - naliczanie odsetek.
                    </aside>
                </section>

                <!-- Podsumowanie potrzeby OOP -->
                <section>
                    <h3>Czego potrzebowaliÅ›my?</h3>
                    <div class="row" style="margin-top: 40px;">
                        <div class="column">
                            <h4 style="color: #ff6b6b;">âŒ Problem</h4>
                            <ul style="font-size: 0.8em;">
                                <li>Dane osobno od funkcji</li>
                                <li>Wszystko globalne</li>
                                <li>Brak ochrony</li>
                                <li>Trudno skalowaÄ‡</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h4 style="color: #51cf66;">âœ“ RozwiÄ…zanie OOP</h4>
                            <ul style="font-size: 0.8em;">
                                <li>Dane + funkcje razem</li>
                                <li>Kontrolowany dostÄ™p</li>
                                <li>Ukryte szczegÃ³Å‚y (enkapsulacja)</li>
                                <li>Åatwe rozszerzanie (dziedziczenie)</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Te obserwacje - grupowanie danych z metodami, kontrola dostÄ™pu przez enkapsulacjÄ™,
                        rozszerzalnoÅ›Ä‡ przez dziedziczenie - doprowadziÅ‚y do powstania koncepcji
                        programowania obiektowego.

                        W nastÄ™pnych slajdach zobaczymy jak te idee zostaÅ‚y zrealizowane w pierwszych
                        jÄ™zykach obiektowych.
                    </aside>
                </section>

                <!-- Simula -->
                <section>
                    <h3>1967: Simula</h3>
                    <p><strong>Ole-Johan Dahl i Kristen Nygaard (Norwegia)</strong></p>
                    <ul>
                        <li>Symulacje (kolejki, procesy)</li>
                        <li>Wprowadzili: <strong>klasy i obiekty</strong></li>
                        <li>Pierwszy jÄ™zyk obiektowy</li>
                    </ul>
                    <aside class="notes">
                        Rok 1967, Norwegian Computing Center w Oslo. Ole-Johan Dahl i Kristen Nygaard
                        pracujÄ… nad jÄ™zykiem do symulacji dyskretnych zdarzeÅ„ - kolejek w systemach obsÅ‚ugi,
                        procesÃ³w produkcyjnych, ruchu w portach.

                        W kolejnych slajdach zobaczymy jak fundamentalna obserwacja doprowadziÅ‚a do stworzenia
                        koncepcji klas i obiektÃ³w.
                    </aside>
                </section>

                <!-- Simula: Problem symulacji -->
                <section>
                    <h3>Simula: Symulacja sklepu</h3>
                    <p style="font-size: 0.85em;">Naturalne byty w symulacji:</p>
                    <div style="text-align: left; margin: 20px; font-size: 0.8em;">
                        <div
                            style="margin: 15px 0; padding: 12px; background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db;">
                            <strong>ğŸ‘¤ Klient:</strong> imiÄ™, wiek, koszyk zakupÃ³w<br>
                            <em>Zachowania:</em> czeka w kolejce, wybiera produkty, pÅ‚aci
                        </div>
                        <div
                            style="margin: 15px 0; padding: 12px; background: rgba(46, 204, 113, 0.1); border-left: 3px solid #2ecc71;">
                            <strong>ğŸ’¼ Kasjer:</strong> stanowisko, szybkoÅ›Ä‡ obsÅ‚ugi<br>
                            <em>Zachowania:</em> obsÅ‚uguje klienta, skanuje produkty, wydaje resztÄ™
                        </div>
                        <div
                            style="margin: 15px 0; padding: 12px; background: rgba(155, 89, 182, 0.1); border-left: 3px solid #9b59b6;">
                            <strong>ğŸ“¦ Produkt:</strong> nazwa, cena, kod<br>
                            <em>Zachowania:</em> wyÅ›wietl informacje, oblicz rabat
                        </div>
                    </div>
                    <aside class="notes">
                        Podczas projektowania jÄ™zyka symulacji zauwaÅ¼yli fundamentalnÄ… wÅ‚aÅ›ciwoÅ›Ä‡:
                        symulowane systemy skÅ‚adajÄ… siÄ™ z bytÃ³w, z ktÃ³rych kaÅ¼dy posiada wÅ‚asny stan
                        (dane) oraz zachowanie (operacje).

                        W symulacji sklepu naturalnymi bytami sÄ…: klienci posiadajÄ…cy imiÄ™, wiek, koszyk zakupÃ³w;
                        kasjerzy majÄ…cy stanowisko i szybkoÅ›Ä‡ obsÅ‚ugi; produkty charakteryzujÄ…ce siÄ™ nazwÄ…, cenÄ… i
                        kodem.

                        KaÅ¼dy byt posiada nie tylko dane, ale rÃ³wnieÅ¼ zachowania: klient czeka w kolejce,
                        wybiera produkty, pÅ‚aci; kasjer obsÅ‚uguje klienta, skanuje produkty, wydaje resztÄ™.
                    </aside>
                </section>

                <!-- Simula: Klasa jako szablon -->
                <section>
                    <h3>Simula: Klasa jako szablon</h3>
                    <pre style="font-size: 13px;"><code class="hljs" data-trim>
! Klasa w Simula
CLASS Klient;
BEGIN
    TEXT imie;
    INTEGER wiek;
    REF(Koszyk) koszyk;
    
    PROCEDURE czekaj_w_kolejce;
    BEGIN
        ! kod czekania
    END;
    
    PROCEDURE plac;
    BEGIN
        ! kod pÅ‚acenia
    END;
END Klient;
                    </code></pre>
                    <p style="font-size: 0.8em; margin-top: 20px;">
                        ğŸ’¡ <strong>Klasa</strong> = szablon definiujÄ…cy strukturÄ™ i zachowanie
                    </p>
                    <aside class="notes">
                        Ta obserwacja doprowadziÅ‚a do stworzenia jÄ™zyka Simula z fundamentalnymi koncepcjami:
                        klasÄ… jako szablonem definiujÄ…cym strukturÄ™ i zachowanie.

                        Klasa "Klient" definiuje, Å¼e kaÅ¼dy klient posiada imiÄ™, wiek i koszyk.
                        Definiuje rÃ³wnieÅ¼ zachowania (procedury): czekaj_w_kolejce, plac.
                    </aside>
                </section>

                <!-- Simula: Obiekt jako instancja -->
                <section>
                    <h3>Simula: Obiekt jako instancja</h3>
                    <pre style="font-size: 13px;"><code class="hljs" data-trim>
! Tworzenie obiektÃ³w (instancji klasy Klient)
REF(Klient) jan, anna;

jan :- NEW Klient;
jan.imie := "Jan Kowalski";
jan.wiek := 35;

anna :- NEW Klient;
anna.imie := "Anna Nowak";
anna.wiek := 28;

! KaÅ¼dy obiekt ma wÅ‚asne dane
jan.plac;   ! Jan pÅ‚aci
anna.plac;  ! Anna pÅ‚aci
                    </code></pre>
                    <p style="font-size: 0.8em; margin-top: 20px;">
                        ğŸ’¡ <strong>Obiekt</strong> = konkretna instancja klasy z wÅ‚asnymi wartoÅ›ciami
                    </p>
                    <aside class="notes">
                        Obiekt jako konkretnÄ… instancjÄ… klasy. Klasa "Klient" definiuje, Å¼e kaÅ¼dy klient
                        posiada imiÄ™, wiek i koszyk.

                        Obiekt "Jan Kowalski" jest konkretnÄ… instancjÄ… z wartoÅ›ciami: imiÄ™="Jan", wiek=35,
                        koszyk=[mleko, chleb].

                        KaÅ¼dy obiekt ma wÅ‚asne wartoÅ›ci, ale wspÃ³lnÄ… strukturÄ™ i zachowania zdefiniowane w klasie.
                    </aside>
                </section>

                <!-- Simula: Dziedziczenie -->
                <section>
                    <h3>Simula: Dziedziczenie</h3>
                    <pre style="font-size: 12px;"><code class="hljs" data-trim>
! Klasa bazowa
CLASS Osoba;
BEGIN
    TEXT imie;
    INTEGER wiek;
    
    PROCEDURE przedstaw_sie;
    BEGIN
        OutText("Nazywam siÄ™ ");
        OutText(imie);
    END;
END Osoba;

! Klasa pochodna (dziedziczy po Osoba)
Osoba CLASS Klient;  ! Klient rozszerza Osoba
BEGIN
    REF(Koszyk) koszyk;
    
    PROCEDURE rob_zakupy;
    BEGIN
        ! kod zakupÃ³w
    END;
END Klient;
                    </code></pre>
                    <aside class="notes">
                        Simula wprowadziÅ‚a rÃ³wnieÅ¼ koncepcjÄ™ dziedziczenia - moÅ¼liwoÅ›ci tworzenia
                        specjalizowanych klas na bazie klas ogÃ³lnych.

                        Klient dziedziczy po Osoba, otrzymujÄ…c automatycznie pola (imie, wiek) i metody
                        (przedstaw_sie), dodajÄ…c wÅ‚asne rozszerzenia (koszyk, rob_zakupy).
                    </aside>
                </section>

                <!-- Simula: WpÅ‚yw -->
                <section>
                    <h3>Simula: WpÅ‚yw na przyszÅ‚oÅ›Ä‡</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>Koncepcje wprowadzone przez Simula:</strong>
                            <ul style="font-size: 0.85em; margin-top: 10px;">
                                <li>âœ… Klasa jako szablon</li>
                                <li>âœ… Obiekt jako instancja</li>
                                <li>âœ… Dziedziczenie</li>
                                <li>âœ… Polimorfizm (wirtualne procedury)</li>
                            </ul>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>WpÅ‚ynÄ™Å‚a na:</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                C++, Java, Python, C#, JavaScript...
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Mimo Å¼e Simula nie osiÄ…gnÄ™Å‚a szerokiego zastosowania komercyjnego, jej koncepcje
                        staÅ‚y siÄ™ fundamentem wszystkich wspÃ³Å‚czesnych jÄ™zykÃ³w obiektowych: C++, Java, Python, C#.

                        KluczowÄ… ideÄ… jest grupowanie danych z zachowaniami w spÃ³jne encje - klasy i obiekty.
                    </aside>
                </section>

                <!-- Smalltalk -->
                <section>
                    <h3>1972: Smalltalk</h3>
                    <p><strong>Alan Kay (Xerox PARC)</strong></p>
                    <ul>
                        <li>WSZYSTKO jest obiektem (nawet liczby!)</li>
                        <li>Pierwsze GUI (okienka, mysz)</li>
                        <li>UkuÅ‚ termin "programowanie obiektowe"</li>
                    </ul>
                    <aside class="notes">
                        Rok 1972, Xerox Palo Alto Research Center. Alan Kay, informatyk i wizjoner,
                        rozwija koncepcjÄ™ programowania obiektowego do jej logicznej konkluzji, tworzÄ…c
                        jÄ™zyk Smalltalk.

                        W kolejnych slajdach zobaczymy rewolucyjne podejÅ›cie Smalltalk.
                    </aside>
                </section>

                <!-- Smalltalk: Wszystko jest obiektem -->
                <section>
                    <h3>Smalltalk: Wszystko jest obiektem</h3>
                    <p style="font-size: 0.85em;">Nawet liczby sÄ… obiektami z metodami!</p>
                    <pre style="font-size: 14px;"><code class="hljs smalltalk" data-trim>
"Liczby jako obiekty"
5 + 3.          "Wynik: 8"
10 - 7.         "Wynik: 3"
4 * 6.          "Wynik: 24"

"To jest tak naprawdÄ™ wywoÅ‚anie metod:"
5 plus: 3.      "Metoda 'plus:' z argumentem 3"
10 minus: 7.    "Metoda 'minus:' z argumentem 7"

"Liczby majÄ… rÃ³Å¼ne metody:"
5 squared.      "Wynik: 25 (podniesienie do kwadratu)"
10 factorial.   "Wynik: 3628800"
7 isPrime.      "Wynik: true (czy pierwsza?)"
                    </code></pre>
                    <p style="font-size: 0.75em; margin-top: 20px; color: #3498db;">
                        ğŸ’¡ W Smalltalk <code>5 + 3</code> to wysÅ‚anie wiadomoÅ›ci <code>+</code> do obiektu
                        <code>5</code> z argumentem <code>3</code>
                    </p>
                    <aside class="notes">
                        Fundamentalna zasada Smalltalk: wszystko jest obiektem. Nawet wartoÅ›ci prymitywne
                        takie jak liczba 5 sÄ… obiektami posiadajÄ…cymi metody.

                        Liczba 5 posiada metody dodawania, mnoÅ¼enia, konwersji do stringa. W notacji Smalltalk:
                        5 + 3 to wywoÅ‚anie metody dodawania na obiekcie 5 z argumentem 3.

                        WspÃ³Å‚czeÅ›nie ten model widzimy w Pythonie, gdzie (5).__add__(3) jest poprawnym wywoÅ‚aniem.
                    </aside>
                </section>

                <!-- Smalltalk: Komunikacja przez wiadomoÅ›ci -->
                <section>
                    <h3>Smalltalk: Komunikacja przez wiadomoÅ›ci</h3>
                    <pre style="font-size: 13px;"><code class="hljs smalltalk" data-trim>
"Definiowanie klasy"
Object subclass: #Konto
    instanceVariableNames: 'saldo wlasciciel'
    
"Definiowanie metod"
Konto >> wplac: kwota
    saldo := saldo + kwota.

Konto >> wyplac: kwota
    (kwota <= saldo)
        ifTrue: [ saldo := saldo - kwota ]
        ifFalse: [ self error: 'NiewystarczajÄ…ce saldo' ].

"Tworzenie obiektu i wysyÅ‚anie wiadomoÅ›ci"
mojeKonto := Konto new.
mojeKonto wplac: 1000.    "WysyÅ‚anie wiadomoÅ›ci 'wplac:' z argumentem 1000"
mojeKonto wyplac: 500.    "WysyÅ‚anie wiadomoÅ›ci 'wyplac:' z argumentem 500"
                    </code></pre>
                    <aside class="notes">
                        Kay wprowadziÅ‚ koncepcjÄ™ komunikacji poprzez wiadomoÅ›ci. Obiekty nie
                        "wywoÅ‚ujÄ… funkcji" - wysyÅ‚ajÄ… wiadomoÅ›ci do innych obiektÃ³w, ktÃ³re decydujÄ…
                        jak na nie odpowiedzieÄ‡. To fundamentalna zmiana paradygmatu.

                        Zamiast "wywoÅ‚aj funkcjÄ™ wplac na koncie", mÃ³wimy "wyÅ›lij wiadomoÅ›Ä‡ wplac: do obiektu konto".
                    </aside>
                </section>

                <!-- Smalltalk: PorÃ³wnanie z innymi jÄ™zykami -->
                <section>
                    <h3>Smalltalk vs inne jÄ™zyki</h3>
                    <div class="row" style="margin-top: 20px;">
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Smalltalk (czyste OOP)</h4>
                            <pre style="font-size: 11px;"><code class="hljs smalltalk" data-trim>
"Wszystko jest obiektem"
5 + 3.
'tekst' size.
true ifTrue: [ 'tak' ].

"Nawet klasy sÄ… obiektami!"
String new.
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Python (inspirowany Smalltalk)</h4>
                            <pre style="font-size: 11px;"><code class="hljs python" data-trim>
# Liczby jako obiekty
(5).__add__(3)
"tekst".upper()

# Klasy teÅ¼ sÄ… obiektami
type(str)  # <class 'type'>
                            </code></pre>
                        </div>
                    </div>
                    <p style="font-size: 0.75em; margin-top: 20px;">
                        ğŸ’¡ WspÃ³Å‚czesne jÄ™zyki jak Python przejÄ™Å‚y filozofiÄ™ Smalltalk
                    </p>
                    <aside class="notes">
                        WspÃ³Å‚czeÅ›nie ten model widzimy w Pythonie, gdzie (5).__add__(3) jest poprawnym wywoÅ‚aniem.
                        Python, podobnie jak Smalltalk, traktuje wszystko jako obiekty, wÅ‚Ä…cznie z klasami.

                        To pokazuje jak daleko siÄ™gajÄ…cy byÅ‚ wpÅ‚yw Smalltalk na rozwÃ³j jÄ™zykÃ³w programowania.
                    </aside>
                </section>

                <!-- Smalltalk: GUI -->
                <section>
                    <h3>Smalltalk: Rewolucja w interfejsach</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>Pierwsze graficzne GUI (1973):</strong>
                            <ul style="font-size: 0.85em; margin-top: 10px;">
                                <li>ğŸ–¼ï¸ Okna (nakÅ‚adajÄ…ce siÄ™)</li>
                                <li>ğŸ–±ï¸ ObsÅ‚uga myszy</li>
                                <li>ğŸ“‹ Menu rozwijane</li>
                                <li>ğŸ¨ Ikony</li>
                            </ul>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>WpÅ‚yw:</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                â†’ Apple Macintosh (1984)<br>
                                â†’ Microsoft Windows (1985)<br>
                                â†’ Wszystkie wspÃ³Å‚czesne GUI
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Smalltalk byÅ‚ rÃ³wnieÅ¼ rewolucyjny technologicznie - Kay stworzyÅ‚ pierwsze
                        graficzne Å›rodowisko uÅ¼ytkownika oparte na oknach, ikonach i myszy.

                        To rozwiÄ…zanie, zaprezentowane w Xerox PARC, zostaÅ‚o nastÄ™pnie zaadaptowane przez Apple
                        w Macintosh oraz Microsoft w Windows.

                        Bez Smalltalk nie mielibyÅ›my wspÃ³Å‚czesnych interfejsÃ³w graficznych!
                    </aside>
                </section>

                <!-- Smalltalk: Dziedzictwo -->
                <section>
                    <h3>Smalltalk: Dziedzictwo</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>ğŸ’¡ Alan Kay ukuÅ‚ termin:</strong>
                            <p style="margin-top: 10px; font-size: 1.2em; font-weight: bold; color: #2ecc71;">
                                "Object-Oriented Programming"
                            </p>
                            <p style="margin-top: 10px; font-style: italic;">
                                Programowanie Obiektowe
                            </p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>WpÅ‚yw na jÄ™zyki:</strong>
                            <p style="margin-top: 10px;">
                                Ruby (bardzo inspirowany Smalltalk)<br>
                                Python (filozofia "wszystko jest obiektem")<br>
                                JavaScript (prototypy, dynamicznoÅ›Ä‡)<br>
                                Swift (nowoczesna skÅ‚adnia, opcjonalne typy)
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Alan Kay ukuÅ‚ termin "object-oriented programming" - programowanie obiektowe.

                        Mimo Å¼e Smalltalk nie osiÄ…gnÄ™Å‚a dominacji w przemyÅ›le ze wzglÄ™du na wymagania
                        wydajnoÅ›ciowe, jego czysta wizja OOP wpÅ‚ynÄ™Å‚a na projektowanie wszystkich
                        pÃ³Åºniejszych jÄ™zykÃ³w obiektowych.

                        Zasady formuÅ‚owane przez Kaya pozostajÄ… aktualne 50 lat pÃ³Åºniej.

                        Wiele wspÃ³Å‚czesnych jÄ™zykÃ³w przejÄ™Å‚o filozofiÄ™ Smalltalk - Ruby jest niemal
                        bezpoÅ›rednim spadkobiercÄ…, Python przyjÄ…Å‚ koncepcjÄ™ "wszystko jest obiektem",
                        JavaScript wykorzystaÅ‚ dynamiczne wysyÅ‚anie wiadomoÅ›ci.
                    </aside>
                </section>

                <!-- C++ -->
                <section>
                    <h3>1983: C++</h3>
                    <p><strong>Bjarne Stroustrup</strong></p>
                    <ul>
                        <li>PoÅ‚Ä…czyÅ‚ C (szybki) + OOP (zorganizowany)</li>
                        <li>"C with Classes" â†’ C++</li>
                        <li>ProgramiÅ›ci C mogli stopniowo przejÅ›Ä‡ na OOP</li>
                    </ul>
                    <aside class="notes">
                        Rok 1983, Bell Laboratories. Bjarne Stroustrup, informatyk duÅ„skiego pochodzenia,
                        stoi przed problemem: jak wprowadziÄ‡ koncepcje obiektowe do praktyki przemysÅ‚owej,
                        gdzie dominuje jÄ™zyk C znany z wydajnoÅ›ci i kontroli niskopoziomowej?

                        W kolejnych slajdach zobaczymy jak C++ Å‚Ä…czy Å›wiat C z paradygmatem obiektowym.
                    </aside>
                </section>

                <!-- C++: Problem do rozwiÄ…zania -->
                <section>
                    <h3>C++: Wyzwanie</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>ğŸ¯ Problem:</strong>
                            <p style="margin-top: 10px;">
                                Jak wprowadziÄ‡ OOP do Å›wiata, gdzie dominuje C?
                            </p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>Wymagania:</strong>
                            <ul style="margin-top: 10px;">
                                <li>âœ… ZachowaÄ‡ wydajnoÅ›Ä‡ C</li>
                                <li>âœ… ZachowaÄ‡ kontrolÄ™ niskopoziomowÄ…</li>
                                <li>âœ… DodaÄ‡ moÅ¼liwoÅ›ci organizacyjne OOP</li>
                                <li>âœ… KompatybilnoÅ›Ä‡ z istniejÄ…cym kodem C</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        RozwiÄ…zaniem byÅ‚o stworzenie C++ - jÄ™zyka Å‚Ä…czÄ…cego sprawdzonÄ… efektywnoÅ›Ä‡ C
                        z moÅ¼liwoÅ›ciami organizacyjnymi programowania obiektowego. To byÅ‚ strategiczny
                        kompromis pozwalajÄ…cy na ewolucyjne przyjÄ™cie nowego paradygmatu.

                        ProgramiÅ›ci C mogli kontynuowaÄ‡ pisanie kodu proceduralnego, stopniowo wprowadzajÄ…c
                        elementy obiektowe. Nie byÅ‚o koniecznoÅ›ci rewolucyjnej zmiany caÅ‚ego podejÅ›cia.
                    </aside>
                </section>

                <!-- C++: Ewolucja, nie rewolucja -->
                <section>
                    <h3>C++: Ewolucja, nie rewolucja</h3>
                    <div class="row" style="margin-top: 20px;">
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Kod C (dziaÅ‚a w C++)</h4>
                            <pre style="font-size: 11px;"><code class="hljs c" data-trim>
// Czysty C
#include <stdio.h>

int suma(int a, int b) {
    return a + b;
}

int main() {
    int wynik = suma(5, 3);
    printf("%d\n", wynik);
    return 0;
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Kod C++ (z klasami)</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
// C++ z klasÄ…
#include <iostream>
using namespace std;

class Kalkulator {
public:
    int suma(int a, int b) {
        return a + b;
    }
};

int main() {
    Kalkulator k;
    cout << k.suma(5, 3) << endl;
    return 0;
}
                            </code></pre>
                        </div>
                    </div>
                    <p style="font-size: 0.75em; margin-top: 20px;">
                        ğŸ’¡ Kod C pozostawaÅ‚ poprawnym kodem C++ - kompatybilnoÅ›Ä‡ wsteczna!
                    </p>
                    <aside class="notes">
                        Kod C pozostawaÅ‚ poprawnym kodem C++, zapewniajÄ…c kompatybilnoÅ›Ä‡ wstecznÄ….
                        ProgramiÅ›ci mogli stopniowo wprowadzaÄ‡ klasy i obiekty, nie przepisujÄ…c
                        caÅ‚ego projektu od zera.

                        PoczÄ…tkowo jÄ™zyk nazywaÅ‚ siÄ™ "C with Classes". Zmiana nazwy na C++ (operator
                        inkrementacji w C oznacza zwiÄ™kszenie o 1) symbolizowaÅ‚a ewolucyjny charakter jÄ™zyka.
                    </aside>
                </section>

                <!-- C++: Klasy w C++ -->
                <section>
                    <h3>C++: Wprowadzenie klas</h3>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
// Klasa w C++
class Konto {
private:
    double saldo;
    string wlasciciel;
    
public:
    // Konstruktor
    Konto(string w, double s) : wlasciciel(w), saldo(s) {}
    
    void wplac(double kwota) {
        if (kwota > 0)
            saldo += kwota;
    }
    
    void wyplac(double kwota) {
        if (kwota > 0 && kwota <= saldo)
            saldo -= kwota;
    }
    
    double pobierz_saldo() const {
        return saldo;
    }
};
                    </code></pre>
                    <aside class="notes">
                        C++ wprowadziÅ‚ klasy z peÅ‚nÄ… enkapsulacjÄ… - pola prywatne, metody publiczne,
                        konstruktory. JednoczeÅ›nie zachowaÅ‚ wszystkie moÅ¼liwoÅ›ci C - wskaÅºniki,
                        bezpoÅ›redni dostÄ™p do pamiÄ™ci, struktury.
                    </aside>
                </section>

                <!-- C++: WskaÅºniki + OOP -->
                <section>
                    <h3>C++: Niskopoziomowa kontrola + OOP</h3>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class Osoba {
private:
    string imie;
    int wiek;
public:
    Osoba(string i, int w) : imie(i), wiek(w) {}
    void wyswietl() { cout << imie << ", " << wiek << endl; }
};

int main() {
    // Obiekt na stosie (jak w C)
    Osoba p1("Jan", 30);
    
    // Obiekt na stercie (wskaÅºnik jak w C)
    Osoba* p2 = new Osoba("Anna", 25);
    
    p1.wyswietl();
    p2->wyswietl();
    
    // Manualne zarzÄ…dzanie pamiÄ™ciÄ… (jak w C)
    delete p2;  // Musimy pamiÄ™taÄ‡!
    
    return 0;
}
                    </code></pre>
                    <aside class="notes">
                        C++ zachowaÅ‚ fundamentalne cechy C: bezpoÅ›redni dostÄ™p do pamiÄ™ci, wskaÅºniki,
                        moÅ¼liwoÅ›Ä‡ programowania niskopoziomowego. JednoczeÅ›nie wprowadziÅ‚ klasy, dziedziczenie,
                        polimorfizm, szablony.

                        To poÅ‚Ä…czenie czyni C++ unikalnym - pozwala na niskopoziomowÄ… kontrolÄ™
                        (zarzÄ…dzanie kaÅ¼dym bajtem pamiÄ™ci) oraz wysokopoziomowÄ… organizacjÄ™
                        (eleganckie hierarchie klas).
                    </aside>
                </section>

                <!-- C++: Dziedziczenie -->
                <section>
                    <h3>C++: Dziedziczenie i polimorfizm</h3>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class Pojazd {
protected:
    string marka;
public:
    Pojazd(string m) : marka(m) {}
    virtual void jedz() {  // Metoda wirtualna
        cout << "Pojazd jedzie" << endl;
    }
};

class Samochod : public Pojazd {
private:
    int liczba_drzwi;
public:
    Samochod(string m, int d) : Pojazd(m), liczba_drzwi(d) {}
    void jedz() override {  // Nadpisanie
        cout << "SamochÃ³d " << marka << " jedzie" << endl;
    }
};

// Polimorfizm
Pojazd* p = new Samochod("Toyota", 4);
p->jedz();  // WywoÅ‚uje Samochod::jedz()
                    </code></pre>
                    <aside class="notes">
                        C++ wprowadziÅ‚ peÅ‚ne wsparcie dla dziedziczenia i polimorfizmu. Metody wirtualne
                        umoÅ¼liwiajÄ… dynamiczne wiÄ…zanie - wywoÅ‚anie odpowiedniej metody w runtime
                        w zaleÅ¼noÅ›ci od rzeczywistego typu obiektu.

                        To wszystko przy zachowaniu wydajnoÅ›ci - programista moÅ¼e wybraÄ‡ czy chce
                        polimorfizm (metody wirtualne) czy maksymalnÄ… wydajnoÅ›Ä‡ (metody niewirtualne).
                    </aside>
                </section>

                <!-- C++: Zastosowania -->
                <section>
                    <h3>C++: Gdzie siÄ™ sprawdza?</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>ğŸ–¥ï¸ Systemy operacyjne:</strong>
                            <p style="margin-top: 10px;">Windows, Linux - wydajnoÅ›Ä‡ + organizacja</p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>ğŸ® Silniki gier:</strong>
                            <p style="margin-top: 10px;">Unreal Engine - kontrola kaÅ¼dego klatki na sekundÄ™</p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>ğŸš— Embedded/Automotive:</strong>
                            <p style="margin-top: 10px;">Systemy kontroli w samochodach, samolotach</p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>ğŸŒ PrzeglÄ…darki:</strong>
                            <p style="margin-top: 10px;">Chrome, Firefox - wydajnoÅ›Ä‡ krytyczna</p>
                        </div>
                    </div>
                    <aside class="notes">
                        Zastosowania C++: systemy operacyjne (Windows, Linux), silniki gier (Unreal Engine),
                        oprogramowanie embedded (automotive, avionics), aplikacje wymagajÄ…ce wydajnoÅ›ci
                        (przeglÄ…darki Chrome, Firefox).

                        WszÄ™dzie tam, gdzie liczy siÄ™ wydajnoÅ›Ä‡ i niskopoziomowa kontrola, ale jednoczeÅ›nie
                        potrzebna jest dobra organizacja duÅ¼ego projektu.
                    </aside>
                </section>

                <!-- C++: Charakterystyka -->
                <section>
                    <h3>C++: Ewolucja C</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>ğŸ’¡ Kluczowa idea:</strong>
                            <p style="margin-top: 10px;">
                                C++ nie jest jÄ™zykiem stworzonym od podstaw dla OOP.<br>
                                Jest <strong>ewolucjÄ… C w kierunku obiektowoÅ›ci</strong>.
                            </p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>To wyjaÅ›nia:</strong>
                            <ul style="margin-top: 10px;">
                                <li>WspÃ³Å‚istnienie struktur i klas</li>
                                <li>Operatory <code>new</code> i <code>malloc</code></li>
                                <li>RÃ³Å¼ne konwencje i style</li>
                                <li>WieloÅ›Ä‡ paradygmatÃ³w (proceduralny, obiektowy, generyczny)</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        C++ nie jest jÄ™zykiem stworzonym od podstaw dla OOP. Jest ewolucjÄ… C w kierunku
                        obiektowoÅ›ci, zachowujÄ…cÄ… kompatybilnoÅ›Ä‡ i wydajnoÅ›Ä‡.

                        To wyjaÅ›nia wiele jego osobliwoÅ›ci - koegzystencja struktur i klas, operatorÃ³w
                        new/malloc, rÃ³Å¼ne konwencje. Zrozumienie tej ewolucji jest kluczem do zrozumienia jÄ™zyka.
                    </aside>
                </section>

                <!-- Java -->
                <section>
                    <h3>1995: Java</h3>
                    <p><strong>James Gosling (Sun Microsystems)</strong></p>
                    <ul>
                        <li>"Write once, run anywhere" (JVM)</li>
                        <li>Automatyczne zarzÄ…dzanie pamiÄ™ciÄ…</li>
                        <li>Wymuszony OOP - wszystko w klasach</li>
                    </ul>
                    <aside class="notes">
                        Rok 1995, Sun Microsystems. Kontekst: ekspansja Internetu, heterogeniczne
                        Å›rodowiska sprzÄ™towe (PC, Mac, Unix), potrzeba przenoÅ›noÅ›ci oprogramowania.

                        James Gosling projektuje JavÄ™ z fundamentalnym zaÅ‚oÅ¼eniem: "Write once, run anywhere".

                        W kolejnych slajdach zobaczymy jak Java rÃ³Å¼ni siÄ™ od C++.
                    </aside>
                </section>

                <!-- Java: Problem przenoÅ›noÅ›ci -->
                <section>
                    <h3>Java: Problem do rozwiÄ…zania</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(231, 76, 60, 0.1); border-left: 4px solid #e74c3c;">
                            <strong>ğŸŒ Problem lat 90.:</strong>
                            <p style="margin-top: 10px;">
                                RÃ³Å¼ne platformy: Windows, macOS, Unix, Solaris...<br>
                                KaÅ¼da wymaga osobnej kompilacji i testowania!
                            </p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>C++ problem:</strong>
                            <pre style="font-size: 11px; margin-top: 10px;"><code class="hljs bash" data-trim>
# Trzeba kompilowaÄ‡ osobno dla kaÅ¼dej platformy!
g++ program.cpp -o program_windows.exe    # Windows
g++ program.cpp -o program_mac            # macOS  
g++ program.cpp -o program_linux          # Linux
                            </code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        Kontekst: ekspansja Internetu, heterogeniczne Å›rodowiska sprzÄ™towe (PC, Mac, Unix),
                        potrzeba przenoÅ›noÅ›ci oprogramowania. James Gosling projektuje JavÄ™ z fundamentalnym
                        zaÅ‚oÅ¼eniem: "Write once, run anywhere".

                        W C++ ten sam kod trzeba kompilowaÄ‡ osobno dla kaÅ¼dej platformy. To generuje
                        ogromne koszty testowania i dystrybucji.
                    </aside>
                </section>

                <!-- Java: JVM -->
                <section>
                    <h3>Java: RozwiÄ…zanie - JVM</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.8em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>Java Virtual Machine:</strong>
                            <p style="margin-top: 10px;">
                                1. Kompilujesz raz â†’ bytecode (.class)<br>
                                2. JVM na kaÅ¼dej platformie uruchamia ten sam bytecode
                            </p>
                        </div>
                    </div>
                    <pre style="font-size: 12px;"><code class="hljs java" data-trim>
// Program.java
public class Program {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// Kompilacja (raz!)
javac Program.java  â†’ Program.class (bytecode)

// Uruchomienie (na dowolnej platformie!)
java Program  // Windows
java Program  // macOS
java Program  // Linux
                    </code></pre>
                    <aside class="notes">
                        Mechanizm realizacji: Java Virtual Machine (JVM). Kompilacja nie produkuje
                        kodu maszynowego specyficznego dla platformy, lecz bytecode - kod poÅ›redni.

                        JVM na kaÅ¼dej platformie interpretuje ten bytecode. Ten sam plik .class
                        wykonuje siÄ™ identycznie na Windows, macOS, Linux.

                        To byÅ‚a rewolucja w dystrybucji oprogramowania!
                    </aside>
                </section>

                <!-- Java: Garbage Collector -->
                <section>
                    <h3>Java: Automatyczne zarzÄ…dzanie pamiÄ™ciÄ…</h3>
                    <div class="row" style="margin-top: 20px;">
                        <div class="column">
                            <h4 style="font-size: 0.8em; color: #e74c3c;">C++ (manualnie)</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
Osoba* p = new Osoba("Jan");
// ... uÅ¼ywamy obiektu ...

delete p;  // MUSISZ PAMIÄ˜TAÄ†!

// ZapomniaÅ‚eÅ›? 
// â†’ Wyciek pamiÄ™ci! ğŸ’¥
                            </code></pre>
                            <p style="font-size: 0.7em; margin-top: 10px;">âŒ Åatwo o bÅ‚Ä™dy!</p>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.8em; color: #2ecc71;">Java (automatycznie)</h4>
                            <pre style="font-size: 11px;"><code class="hljs java" data-trim>
Osoba p = new Osoba("Jan");
// ... uÅ¼ywamy obiektu ...

// Koniec! Nie musisz nic robiÄ‡!
// Garbage Collector sam usuwa âœ…
                            </code></pre>
                            <p style="font-size: 0.7em; margin-top: 10px;">âœ… Bezpieczniejsze!</p>
                        </div>
                    </div>
                    <aside class="notes">
                        Java wprowadziÅ‚a pierwszÄ… fundamentalnÄ… zmianÄ™ wzglÄ™dem C++:

                        Garbage Collector - automatyczne zarzÄ…dzanie pamiÄ™ciÄ…. W C++ programista
                        musi pamiÄ™taÄ‡: new wymaga delete. Brak delete prowadzi do wycieku pamiÄ™ci - program
                        konsumuje coraz wiÄ™cej RAM.

                        W Javie Garbage Collector automatycznie identyfikuje i usuwa nieuÅ¼ywane obiekty.
                        To znaczÄ…co upraszcza programowanie, kosztem mniejszej kontroli i potencjalnie
                        wolniejszego dziaÅ‚ania podczas zbierania Å›mieci.
                    </aside>
                </section>

                <!-- Java: Wymuszony OOP -->
                <section>
                    <h3>Java: Wymuszony paradygmat OOP</h3>
                    <pre style="font-size: 13px;"><code class="hljs java" data-trim>
// W Javie WSZYSTKO musi byÄ‡ w klasie!
public class Program {
    // Nawet main() jest metodÄ… klasy
    public static void main(String[] args) {
        System.out.println("Hello!");
    }
}

// To NIE zadziaÅ‚a w Javie:
// void funkcja() { ... }  // âŒ Musi byÄ‡ w klasie!
// int x = 5;              // âŒ Musi byÄ‡ polem klasy!

// Poprawnie:
public class MojaKlasa {
    private int x = 5;        // âœ… Pole klasy
    
    public void funkcja() {   // âœ… Metoda klasy
        // ...
    }
}
                    </code></pre>
                    <aside class="notes">
                        Druga fundamentalna zmiana: Wymuszony paradygmat obiektowy. W Javie nie moÅ¼na
                        napisaÄ‡ kodu poza klasÄ…. Funkcja main() musi byÄ‡ metodÄ… statycznÄ… klasy.
                        Zmienne globalne nie istniejÄ… - muszÄ… byÄ‡ statycznymi polami klas.

                        To wymuszenie paradygmatu miaÅ‚o znaczÄ…cy efekt edukacyjny. W C++ moÅ¼na mieszaÄ‡
                        kod proceduralny z obiektowym. Java nie pozwala na kompromisy - tylko czyste OOP.
                    </aside>
                </section>

                <!-- Java: Wszystko obiektowe -->
                <section>
                    <h3>Java: Prawie wszystko jest obiektem</h3>
                    <pre style="font-size: 13px;"><code class="hljs java" data-trim>
// Typy prymitywne (wyjÄ…tek)
int liczba = 5;
boolean prawda = true;

// Ale majÄ… obiektowe wrappery!
Integer liczbaObj = 5;        // Autoboxing
Boolean prawdaObj = true;

// MogÄ… uÅ¼ywaÄ‡ metod obiektowych
String text = liczbaObj.toString();
int wartosc = liczbaObj.intValue();

// Kolekcje wymagajÄ… obiektÃ³w
ArrayList<Integer> lista = new ArrayList<>();
lista.add(5);  // int â†’ Integer automatycznie!

// ArrayList<int> lista;  // âŒ NIE ZADZIAÅA!
                    </code></pre>
                    <aside class="notes">
                        Wszystko musi byÄ‡ obiektem (z wyjÄ…tkiem typÃ³w prymitywnych, ktÃ³re posiadajÄ…
                        wrappery obiektowe: int â†’ Integer).

                        Miliony programistÃ³w uczÄ…cych siÄ™ Javy musiaÅ‚o opanowaÄ‡ wÅ‚aÅ›ciwe praktyki obiektowe.
                        To miaÅ‚o ogromny wpÅ‚yw edukacyjny - Java wymusiÅ‚ myÅ›lenie obiektowe.
                    </aside>
                </section>

                <!-- Java: Klasa w Javie -->
                <section>
                    <h3>Java: PrzykÅ‚ad klasy</h3>
                    <pre style="font-size: 12px;"><code class="hljs java" data-trim>
public class Konto {
    // Pola (zawsze prywatne!)
    private double saldo;
    private String wlasciciel;
    
    // Konstruktor
    public Konto(String wlasciciel, double saldo) {
        this.wlasciciel = wlasciciel;
        this.saldo = saldo;
    }
    
    // Metody publiczne
    public void wplac(double kwota) {
        if (kwota > 0) {
            saldo += kwota;
        }
    }
    
    public void wyplac(double kwota) {
        if (kwota > 0 && kwota <= saldo) {
            saldo -= kwota;
        }
    }
    
    // Getter
    public double getSaldo() {
        return saldo;
    }
}
                    </code></pre>
                    <aside class="notes">
                        Typowa klasa w Javie: pola prywatne, konstruktor publiczny, metody publiczne,
                        gettery/settery. To jest standard w Javie - enkapsulacja jest wymuszona
                        przez konwencje jÄ™zyka i dobre praktyki.
                    </aside>
                </section>

                <!-- Java: PorÃ³wnanie C++ vs Java -->
                <section>
                    <h3>Java vs C++: Filozofie</h3>
                    <div class="row" style="margin-top: 20px; font-size: 0.75em;">
                        <div class="column">
                            <h4 style="color: #9b59b6;">C++</h4>
                            <ul style="font-size: 0.9em;">
                                <li>âœ… Maksymalna wydajnoÅ›Ä‡</li>
                                <li>âœ… Kontrola niskopoziomowa</li>
                                <li>âœ… WskaÅºniki, pamiÄ™Ä‡</li>
                                <li>âš ï¸ Manualne delete</li>
                                <li>âš ï¸ Kompilacja dla platform</li>
                            </ul>
                            <p style="margin-top: 15px; font-style: italic;">
                                "PeÅ‚na kontrola + odpowiedzialnoÅ›Ä‡"
                            </p>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">Java</h4>
                            <ul style="font-size: 0.9em;">
                                <li>âœ… PrzenoÅ›noÅ›Ä‡ (JVM)</li>
                                <li>âœ… Automatyczny GC</li>
                                <li>âœ… BezpieczeÅ„stwo</li>
                                <li>âš ï¸ Mniejsza kontrola</li>
                                <li>âš ï¸ Wolniejsze (czasem)</li>
                            </ul>
                            <p style="margin-top: 15px; font-style: italic;">
                                "BezpieczeÅ„stwo + prostota"
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Dla programistÃ³w C++ Java reprezentuje alternatywnÄ… filozofiÄ™: rezygnacja
                        z niskopoziomowej kontroli w zamian za bezpieczeÅ„stwo i przenoÅ›noÅ›Ä‡.

                        Oba podejÅ›cia majÄ… uzasadnienie w odpowiednich kontekstach zastosowaÅ„.
                    </aside>
                </section>

                <!-- Java: Zastosowania -->
                <section>
                    <h3>Java: Gdzie siÄ™ sprawdza?</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>ğŸŒ Aplikacje webowe (backend):</strong>
                            <p style="margin-top: 10px;">Spring, Hibernate - systemy korporacyjne</p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>ğŸ“± Android:</strong>
                            <p style="margin-top: 10px;">WiÄ™kszoÅ›Ä‡ aplikacji (choÄ‡ Kotlin zyskuje)</p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>ğŸ¦ Systemy enterprise:</strong>
                            <p style="margin-top: 10px;">BankowoÅ›Ä‡, ubezpieczenia - Java EE dominuje</p>
                        </div>
                        <div
                            style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>â˜ï¸ Big Data:</strong>
                            <p style="margin-top: 10px;">Hadoop, Apache Spark - ekosystem JVM</p>
                        </div>
                    </div>
                    <aside class="notes">
                        WspÃ³Å‚czesne zastosowania Javy: aplikacje webowe (backend - Spring, Hibernate),
                        Android (choÄ‡ obecnie Kotlin zyskuje przewagÄ™), systemy korporacyjne (bankowoÅ›Ä‡,
                        ubezpieczenia, gdzie dominuje Java Enterprise Edition).

                        Java sprawdza siÄ™ wszÄ™dzie tam, gdzie przenoÅ›noÅ›Ä‡ i bezpieczeÅ„stwo sÄ… waÅ¼niejsze
                        niÅ¼ maksymalna wydajnoÅ›Ä‡.
                    </aside>
                </section>

                <!-- Dlaczego OOP wygraÅ‚o -->
                <section>
                    <h3>Dlaczego OOP?</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div data-id="enkapsulacja"
                            style="margin: 20px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>âœ… Enkapsulacja</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Dane chronione - tylko metody mogÄ… je zmieniaÄ‡
                            </p>
                        </div>
                        <div data-id="modularnosc"
                            style="margin: 20px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>âœ… ModularnoÅ›Ä‡</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                NiezaleÅ¼ne obiekty - Å‚atwiej debugowaÄ‡
                            </p>
                        </div>
                        <div data-id="wielokrotne"
                            style="margin: 20px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>âœ… Wielokrotne uÅ¼ycie</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Dziedziczenie - nie piszesz od zera
                            </p>
                        </div>
                        <div data-id="naturalne"
                            style="margin: 20px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>âœ… Naturalne myÅ›lenie</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Kod = rzeczywistoÅ›Ä‡ (Klient, Produkt, ZamÃ³wienie)
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Programowanie obiektowe rozwiÄ…zaÅ‚o fundamentalne problemy inÅ¼ynierii oprogramowania
                        na duÅ¼Ä… skalÄ™.

                        W kolejnych slajdach szczegÃ³Å‚owo omÃ³wimy kaÅ¼dy z czterech filarÃ³w OOP.
                    </aside>
                </section>

                <!-- Enkapsulacja - szczegÃ³Å‚y -->
                <section>
                    <div data-id="enkapsulacja"
                        style="padding: 20px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… Enkapsulacja</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            Ukrywanie implementacji i kontrola dostÄ™pu
                        </p>
                    </div>
                    <div class="row" style="margin-top: 20px; font-size: 0.8em;">
                        <div class="column">
                            <h4 style="color: #e74c3c;">âŒ Bez enkapsulacji</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
class BankAccount {
public:
    double balance; // KaÅ¼dy ma dostÄ™p!
};

BankAccount acc;
acc.balance = -1000000; // ğŸ’¥ MoÅ¼liwe!
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">âœ… Z enkapsulacjÄ…</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
class BankAccount {
private:
    double balance; // Chronione!
public:
    void deposit(double amount) {
        if (amount > 0) // Walidacja
            balance += amount;
    }
    void withdraw(double amount) {
        if (amount > 0 && amount <= balance)  // Walidacja
            balance -= amount;
    }
};

// Chronione!
// k.saldo = -5000; // BÅÄ„D!
                            </code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        ENKAPSULACJA - ukrywanie implementacji i kontrola dostÄ™pu.

                        RozwaÅ¼my klasÄ™ BankAccount. Pole balance jest prywatne. DostÄ™p moÅ¼liwy wyÅ‚Ä…cznie
                        poprzez metody deposit() i withdraw(). Te metody zawierajÄ… logikÄ™ walidacji:
                        deposit() weryfikuje czy kwota jest dodatnia, withdraw() sprawdza
                        czy saldo jest wystarczajÄ…ce. BezpoÅ›rednie przypisanie balance = -1000000 jest niemoÅ¼liwe -
                        kompilator zgÅ‚osi bÅ‚Ä…d dostÄ™pu do prywatnego pola.

                        To fundamentalna rÃ³Å¼nica wzglÄ™dem programowania proceduralnego, gdzie kaÅ¼da
                        zmienna globalna moÅ¼e byÄ‡ modyfikowana przez dowolny fragment kodu. Enkapsulacja
                        gwarantuje, Å¼e dane mogÄ… byÄ‡ zmieniane tylko w kontrolowany sposÃ³b.
                    </aside>
                </section>

                <!-- ModularnoÅ›Ä‡ - szczegÃ³Å‚y -->
                <section>
                    <div data-id="modularnosc"
                        style="padding: 20px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… ModularnoÅ›Ä‡</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            NiezaleÅ¼noÅ›Ä‡ komponentÃ³w
                        </p>
                    </div>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class User {
private:
    string name;
    string email;
public:
    string getName() { return name; }
    void setName(string n) { name = n; }
};

class Invoice {
private:
    double amount;
    User* customer;
public:
    void generatePDF() { /* ... */ }
};

// User nie wie o Invoice, Invoice uÅ¼ywa tylko interfejsu User
// Zmiana implementacji User nie wpÅ‚ywa na Invoice!
                    </code></pre>
                    <div
                        style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 10px; font-size: 0.85em;">
                        ğŸ’¡ KaÅ¼da klasa to niezaleÅ¼ny moduÅ‚ - Å‚atwiejsze debugowanie i utrzymanie
                    </div>
                    <aside class="notes">
                        MODULARNOÅšÄ† - niezaleÅ¼noÅ›Ä‡ komponentÃ³w.

                        KaÅ¼da klasa stanowi niezaleÅ¼ny moduÅ‚. Klasa User nie posiada wiedzy o klasie Invoice.
                        Modyfikacja implementacji User nie wpÅ‚ywa na Invoice, o ile interfejs publiczny
                        (publiczne metody) pozostaje niezmieniony. Reszta systemu nie zauwaÅ¼a wewnÄ™trznych zmian.

                        W systemie skÅ‚adajÄ…cym siÄ™ ze stu klas, kaÅ¼da stanowi czarnÄ… skrzynkÄ™.
                        Interfejs publiczny definiuje wejÅ›cie i wyjÅ›cie, implementacja jest ukryta.
                        Debugowanie staje siÄ™ prostsze - bÅ‚Ä…d w klasie Payment wymaga analizy tylko tej klasy,
                        nie caÅ‚ego systemu.
                    </aside>
                </section>

                <!-- Wielokrotne uÅ¼ycie - szczegÃ³Å‚y -->
                <section>
                    <div data-id="wielokrotne"
                        style="padding: 20px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… Wielokrotne uÅ¼ycie</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            Dziedziczenie i kompozycja
                        </p>
                    </div>
                    <div class="row" style="margin-top: 20px; font-size: 0.75em;">
                        <div class="column">
                            <h4 style="font-size: 0.9em;">Dziedziczenie</h4>
                            <pre style="font-size: 10px;"><code class="hljs cpp" data-trim>
class Animal {
protected:
    string name;
public:
    void eat() { /*...*/ }
    void sleep() { /*...*/ }
};

class Dog : public Animal {
public:
    void bark() { /*...*/ }
    // Otrzymuje eat() i sleep()
    // automatycznie!
};
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.9em;">Kompozycja</h4>
                            <pre style="font-size: 10px;"><code class="hljs cpp" data-trim>
class Engine {
public:
    void start() { /*...*/ }
    void stop() { /*...*/ }
};

class Car {
private:
    Engine engine; // Zawiera Engine
public:
    void drive() {
        engine.start();
        // ...
    }
};
// Ten sam Engine w Motorcycle!
                            </code></pre>
                        </div>
                    </div>
                    <div
                        style="margin-top: 20px; padding: 15px; background: rgba(155, 89, 182, 0.1); border-radius: 10px; font-size: 0.85em;">
                        ğŸ’¡ Ponowne wykorzystanie bez duplikacji kodu
                    </div>
                    <aside class="notes">
                        WIELOKROTNE UÅ»YCIE - dziedziczenie i kompozycja.

                        Klasa Animal definiuje metody eat(), sleep(), makeSound(). Klasa Dog dziedziczy
                        po Animal, automatycznie otrzymujÄ…c te metody. Programista dodaje tylko metodÄ™ bark().
                        Nie ma duplikacji kodu bazowego.

                        Kompozycja: klasa Car zawiera obiekt Engine. Ten sam Engine moÅ¼e byÄ‡ uÅ¼ywany
                        w klasie Motorcycle. Ponowne wykorzystanie bez kopiowania.

                        W programowaniu proceduralnym ponowne uÅ¼ycie wymaga copy-paste. Modyfikacja
                        w jednym miejscu wymaga modyfikacji we wszystkich kopiach. To prowadzi do
                        bÅ‚Ä™dÃ³w i trudnoÅ›ci w utrzymaniu.
                    </aside>
                </section>

                <!-- Naturalne modelowanie - szczegÃ³Å‚y -->
                <section>
                    <div data-id="naturalne"
                        style="padding: 20px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… Naturalne myÅ›lenie</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            Odzwierciedlenie rzeczywistoÅ›ci w kodzie
                        </p>
                    </div>
                    <div style="text-align: left; margin: 20px; font-size: 0.8em;">
                        <div
                            style="margin: 15px 0; padding: 12px; background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db;">
                            <strong>ğŸ›’ System e-commerce - naturalne encje:</strong>
                        </div>
                        <pre style="font-size: 11px; margin-top: 15px;"><code class="hljs cpp" data-trim>
class Customer {
    string name, address;
    vector<Order> orderHistory;
};

class Product {
    string name, description;
    double price;
};

class ShoppingCart {
    vector<Product> items;
    double calculateTotal();
};

class Order {
    Customer* customer;
    vector<Product> products;
    string status; // "pending", "shipped", "delivered"
};
                        </code></pre>
                        <div
                            style="margin-top: 15px; padding: 12px; background: rgba(230, 126, 34, 0.1); border-radius: 10px;">
                            ğŸ’¡ Kod = bezpoÅ›rednie odzwierciedlenie struktury biznesowej
                        </div>
                    </div>
                    <aside class="notes">
                        NATURALNE MODELOWANIE - odzwierciedlenie rzeczywistoÅ›ci.

                        ProjektujÄ…c system e-commerce, naturalnie identyfikujemy encje: Klient (imiÄ™, adres,
                        historia zamÃ³wieÅ„), Produkt (nazwa, cena, opis), Koszyk (lista produktÃ³w, suma),
                        ZamÃ³wienie (klient, produkty, status).

                        OOP pozwala bezpoÅ›rednio zapisaÄ‡ tÄ™ strukturÄ™ w kodzie:
                        class Customer { }, class Product { }, class ShoppingCart { }, class Order { }

                        Kod staje siÄ™ samodokumentujÄ…cym. Nowy programista analizujÄ…cy projekt
                        natychmiast rozumie strukturÄ™ systemu przez nazwy klas. Nie musi analizowaÄ‡
                        tysiÄ™cy linii funkcji o niejasnych nazwach.

                        To sÄ… cztery filary programowania obiektowego: enkapsulacja, modularnoÅ›Ä‡,
                        wielokrotne uÅ¼ycie, naturalne modelowanie. Nie sÄ… abstrakcyjnymi koncepcjami -
                        to praktyczne narzÄ™dzia rozwiÄ…zujÄ…ce realne problemy inÅ¼ynierskie.
                    </aside>
                </section>

                <!-- PorÃ³wnanie: Proceduralne vs Obiektowe -->
                <section>
                    <h3>PorÃ³wnanie: Proceduralne vs Obiektowe</h3>
                    <div class="row">
                        <div class="column">
                            <h4 style="color: #ff6b6b;">âŒ Proceduralnie</h4>
                            <pre style="font-size: 13px;"><code class="hljs c">int saldo = 1000;

void wplac(int kwota) {
    saldo += kwota;
}

void wyplac(int kwota) {
    saldo -= kwota;
}

// KaÅ¼dy moÅ¼e:
saldo = -5000; // Ups!
</code></pre>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">âœ… Obiektowo</h4>
                            <pre style="font-size: 13px;"><code class="hljs cpp">class Konto {
private:
    int saldo;
public:
    void wplac(int kwota) {
        if (kwota > 0)
            saldo += kwota;
    }
    void wyplac(int kwota) {
        if (kwota > 0 && kwota <= saldo)
            saldo -= kwota;
    }
};

// Chronione!
// k.saldo = -5000; // BÅÄ„D!
</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        PorÃ³wnanie implementacji konta bankowego w paradygmatach proceduralnym i obiektowym
                        ilustruje fundamentalne rÃ³Å¼nice.

                        PODEJÅšCIE PROCEDURALNE:

                        Zmienna "saldo" jest globalna. KaÅ¼dy fragment programu ma do niej dostÄ™p i moÅ¼e
                        jÄ… modyfikowaÄ‡. Funkcje wplac() i wyplac() operujÄ… na tej zmiennej. Problem:
                        identyfikacja wszystkich miejsc modyfikujÄ…cych saldo wymaga przeszukania caÅ‚ego kodu.

                        Brak walidacji. Funkcja wyplac() nie weryfikuje czy saldo jest wystarczajÄ…ce.
                        Funkcja wplac() nie sprawdza czy kwota jest dodatnia. NajwiÄ™kszy problem:
                        bezpoÅ›rednie przypisanie saldo = -5000 jest poprawne skÅ‚adniowo.

                        Kompilator akceptuje taki kod. Program kompiluje siÄ™ i uruchamia. BÅ‚Ä…d manifestuje
                        siÄ™ w runtime, potencjalnie po dÅ‚uÅ¼szym okresie dziaÅ‚ania systemu. System produkcyjny
                        moÅ¼e wykazaÄ‡ nieprawidÅ‚owe saldo klienta: -5000 zÅ‚.

                        PODEJÅšCIE OBIEKTOWE:

                        Klasa Konto. Pole saldo jest prywatne. DostÄ™p ma wyÅ‚Ä…cznie kod wewnÄ…trz klasy.
                        Z zewnÄ…trz dostÄ™p jest niemoÅ¼liwy.

                        Metody wplac() i wyplac() sÄ… publiczne - stanowiÄ… interfejs klasy. ZawierajÄ…
                        logikÄ™ walidacji: wplac() weryfikuje if (kwota > 0), wyplac() sprawdza
                        if (kwota > 0 && kwota <= saldo). PrÃ³ba bezpoÅ›redniej modyfikacji k.saldo=-5000 jest bÅ‚Ä™dem
                            kompilacji. Kompilator zgÅ‚osi bÅ‚Ä…d przed uruchomieniem, nie po tygodniach dziaÅ‚ania w
                            Å›rodowisku produkcyjnym. To ilustruje fundamentalnÄ… wartoÅ›Ä‡ OOP: kontrola i bezpieczeÅ„stwo.
                            Projektant klasy definiuje poprawne operacje. UÅ¼ytkownik klasy (inny programista, moÅ¼liwe
                            ten sam programista po upÅ‚ywie czasu) nie moÅ¼e naruszyÄ‡ niezmiennikÃ³w. Kompilator egzekwuje
                            reguÅ‚y. Ten przykÅ‚ad demonstruje nie teoretycznÄ… koncepcjÄ™, lecz praktyczne narzÄ™dzie.
                            BezpieczeÅ„stwo, kontrola, mniej bÅ‚Ä™dÃ³w, Å‚atwiejsze utrzymanie. To konkretne korzyÅ›ci
                            inÅ¼ynierskie, nie abstrakcje akademickie. </aside>
                </section>

                <!-- Podsumowanie -->
                <section>
                    <h3>Podsumowanie</h3>
                    <p style="font-size: 1.1em; margin-bottom: 20px;">
                        <strong>OOP powstaÅ‚o, aby kod byÅ‚:</strong>
                    </p>
                    <ul style="font-size: 0.9em; line-height: 1.8;">
                        <li>ğŸ“¦ <strong>Bezpieczniejszy</strong> - chronione dane</li>
                        <li>ğŸ§© <strong>Modularny</strong> - Å‚atwiej zarzÄ…dzaÄ‡</li>
                        <li>â™»ï¸ <strong>Wielokrotnego uÅ¼ytku</strong> - dziedziczenie</li>
                        <li>ğŸŒ <strong>ZrozumiaÅ‚y</strong> - jak rzeczywistoÅ›Ä‡</li>
                    </ul>
                    <div
                        style="margin-top: 30px; padding: 20px; background: rgba(52, 152, 219, 0.1); border-radius: 10px;">
                        <p style="font-size: 0.9em; text-align: center; font-style: italic;">
                            "Nie programujemy dla komputerÃ³w, programujemy dla ludzi."
                        </p>
                    </div>
                    <aside class="notes">
                        Podsumowanie analizy historycznej:

                        Programowanie obiektowe nie jest arbitralnÄ… abstrakcjÄ… teoretycznÄ…. Jest odpowiedziÄ…
                        na konkretne problemy inÅ¼ynierskie, ktÃ³re ujawniÅ‚y siÄ™ w praktyce tworzenia
                        oprogramowania w latach 60-70 XX wieku.

                        W poczÄ…tkowej fazie, gdy programy liczyÅ‚y setki linii kodu, paradygmat proceduralny
                        byÅ‚ wystarczajÄ…cy. Jednak wraz ze wzrostem skali - systemy osiÄ…gajÄ…ce miliony linii
                        kodu, takie jak Windows, Oracle, systemy bankowe - podejÅ›cie proceduralne okazaÅ‚o siÄ™
                        nieadekwatne. Potrzebna byÅ‚a lepsza organizacja i kontrola zÅ‚oÅ¼onoÅ›ci.

                        Programowanie obiektowe dostarcza narzÄ™dzi do konstrukcji zÅ‚oÅ¼onych systemÃ³w
                        charakteryzujÄ…cych siÄ™: zrozumiaÅ‚oÅ›ciÄ… (klasy odzwierciedlajÄ… strukturÄ™ problemu),
                        bezpieczeÅ„stwem (enkapsulacja chroni niezmienniki), modularnoÅ›ciÄ… (Å‚atwiej
                        zarzÄ…dzaÄ‡ i debugowaÄ‡), rozszerzalnoÅ›ciÄ… (dziedziczenie i polimorfizm).

                        W kolejnych zajÄ™ciach teoria zostanie przeniesiona do praktyki. Studenci bÄ™dÄ…
                        implementowaÄ‡ klasy, stosowaÄ‡ enkapsulacjÄ™, konstruowaÄ‡ hierarchie dziedziczenia,
                        wykorzystywaÄ‡ polimorfizm. To nie bÄ™dzie teoretyczna abstrakcja - bÄ™dzie praktyczne
                        zastosowanie narzÄ™dzi inÅ¼ynierskich.

                        NaleÅ¼y pamiÄ™taÄ‡: nauka programowania obiektowego jest procesem. PoczÄ…tkowo moÅ¼e
                        wydawaÄ‡ siÄ™ nadmiernie skomplikowane. Pytanie "dlaczego caÅ‚a klasa zamiast prostej
                        funkcji?" jest naturalne na poczÄ…tkowym etapie. Jednak wraz z doÅ›wiadczeniem,
                        szczegÃ³lnie przy projektach wiÄ™kszej skali, zalety OOP stajÄ… siÄ™ oczywiste.

                        WspÃ³Å‚czesne oprogramowanie - 90% systemÃ³w produkcyjnych - wykorzystuje paradygmat
                        obiektowy. Od systemÃ³w operacyjnych (Windows, Linux), przez platformy mobilne
                        (Android), po systemy webowe (Facebook, Google). To nie przypadek. OOP sprawdza siÄ™
                        w praktyce inÅ¼ynierskiej.

                        SkutecznoÅ›Ä‡ metody weryfikuje siÄ™ w praktyce, nie w teorii. OOP funkcjonuje
                        efektywnie w maÅ‚ych projektach (Ä‡wiczenia akademickie), Å›rednich (projekty
                        zaliczeniowe), i co najistotniejsze - w systemach przemysÅ‚owych o skali
                        milionÃ³w linii kodu.

                        Cytat na zakoÅ„czenie: "Nie programujemy dla komputerÃ³w, programujemy dla ludzi."

                        Komputer wykonuje kaÅ¼dy poprawny kod - proceduralny, obiektowy, assembly.
                        Jednak ludzie - programista za miesiÄ…c, kolega przejmujÄ…cy projekt, przyszÅ‚y
                        maintainer - wymagajÄ… kodu zrozumiaÅ‚ego.

                        Programowanie obiektowe tworzy kod czytelny dla ludzi. Kod do ktÃ³rego moÅ¼na wrÃ³ciÄ‡
                        po roku i zrozumieÄ‡ jego strukturÄ™. Kod moÅ¼liwy do przekazania bez wielogodzinnych
                        sesji wyjaÅ›niajÄ…cych.

                        WartoÅ›Ä‡ OOP nie tkwi w szybkoÅ›ci wykonania (choÄ‡ C++ jest efektywny) ani oszczÄ™dnoÅ›ci
                        pamiÄ™ci (choÄ‡ obiekty mogÄ… byÄ‡ kompaktowe). Fundamentalna wartoÅ›Ä‡ to: zrozumiaÅ‚oÅ›Ä‡,
                        utrzymywalnoÅ›Ä‡, skalowalnoÅ›Ä‡.

                        NastÄ™pne zajÄ™cia: implementacja pierwszej klasy w C++.
                    </aside>
                </section>

            </section>
            <!-- Koniec sekcji: Historia programowania -->
            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">Zadanie domowe + kartkÃ³wka</h2>
                    <p>ObejrzeÄ‡ materiaÅ‚y video, aby przygotowaÄ‡ sie do kartkÃ³wki.</p>
                    <small>
                        <ul>
                            <li><a href="https://youtu.be/D6EI7EbEN4Q">Czym jest Git? - Kurs gita po polsku #1/12</a>
                            </li>
                            <li><a href="https://youtu.be/4bXuEv2R3W4">Jak zapisaÄ‡ zmiany - Kurs gita po polsku
                                    #2/12</a></li>
                            <li><a href="https://youtu.be/gG80UsfMXsU">PrzestrzeÅ„ robocza i stage - Kurs gita po polsku
                                    #3/12</a></li>
                            <li><a href="https://youtu.be/I8lQK0NK0lY">Czym jest branch? - Kurs git po polsku #8/12</a>
                            </li>
                            <li><a href="https://youtu.be/7myDXGfEnds">Zdalne repozytorium i fork - Kurs git po polsku
                                    #9/12</a></li>
                            <li><a href="https://youtu.be/mxDN0rYQyGA">RozwiÄ…zywanie konfliktÃ³w - Kurs git po polsku
                                    #10/12</a></li>
                        </ul>
                    </small>
                    <br />
                    <small>PrzykÅ‚adowe pytania na kartkÃ³wkÄ™:
                        <ul>
                            <li>Co to jest system kontroli wersji?</li>
                            <li>WymieÅ„ podstawowe podstawowe komendy Gita i ich przeznaczenie</li>
                            <li>Co to jest repozytorium?</li>
                            <li>Co to jest branch?</li>
                            <li>Co to jest commit?</li>
                        </ul>
                    </small>

                </section>
            </section>
            <section data-background-gradient="linear-gradient(67deg, #1e5799, #7db9e8)">
                <section>
                    <h2>ZAJÄ˜CIA 2: Pierwsza klasa w C++</h2>
                    <p>Od struktury do klasy</p>
                </section>

                <!-- 6. Przypomnienie: struktura w C++ -->
                <section>
                    <h2>Przypomnienie: struktura w C++</h2>
                    <pre><code class="cpp" data-trim>
struct Point {
    int x;
    int y;
};

Point p1;
p1.x = 10;
p1.y = 20;
        </code></pre>
                    <ul style="font-size: 0.85em; margin-top: 20px;">
                        <li>Grupowanie danych</li>
                        <li>Wszystko publiczne</li>
                        <li>Brak kontroli dostÄ™pu</li>
                    </ul>
                </section>

                <!-- 7. Przechodzimy do klasy - minimalistyczny przykÅ‚ad -->
                <section>
                    <h2>Przechodzimy do klasy</h2>
                    <h3 style="font-size: 0.9em;">Minimalistyczny przykÅ‚ad</h3>
                    <pre><code class="cpp" data-trim>
class Point {
public:
    int x;
    int y;
};

Point p1;
p1.x = 10;
p1.y = 20;
        </code></pre>
                    <div
                        style="margin-top: 30px; padding: 15px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107;">
                        <p style="font-size: 0.85em;"><strong>RÃ³Å¼nica:</strong> domyÅ›lnie prywatne vs publiczne</p>
                        <p style="font-size: 0.75em; margin-top: 10px;">Na razie uÅ¼ywamy <code>public</code> - Å¼eby byÅ‚o
                            podobnie do struktury</p>
                    </div>
                </section>

                <!-- 8. Dodajemy pierwszÄ… metodÄ™ -->
                <section>
                    <h2>Dodajemy pierwszÄ… metodÄ™</h2>
                    <pre><code class="cpp" data-trim>
class Point {
public:
    int x;
    int y;
    
    void print() {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};
        </code></pre>
                    <ul style="font-size: 0.85em; margin-top: 20px;">
                        <li>Metoda to funkcja "naleÅ¼Ä…ca" do klasy</li>
                        <li>MoÅ¼e korzystaÄ‡ z pÃ³l <code>x</code> i <code>y</code></li>
                        <li>WywoÅ‚ujemy jÄ… na obiekcie: <code>p1.print()</code></li>
                    </ul>
                </section>

                <!-- 9. UÅ¼ywanie klasy -->
                <section>
                    <h2>UÅ¼ywanie klasy</h2>
                    <pre><code class="cpp" data-trim>
int main() {
    Point p1;
    p1.x = 10;
    p1.y = 20;
    p1.print();  // (10, 20)
    
    Point p2;
    p2.x = 5;
    p2.y = 15;
    p2.print();  // (5, 15)
    
    return 0;
}
        </code></pre>
                    <p style="font-size: 0.85em; margin-top: 20px;">
                        KaÅ¼dy obiekt ma wÅ‚asne wartoÅ›ci <code>x</code> i <code>y</code>
                    </p>
                </section>

                <!-- 10. Ä†wiczenie praktyczne 1 (WOLNO!) -->
                <section>
                    <h2>Ä†wiczenie praktyczne 1</h2>
                    <a href="https://classroom.github.com/a/moiVpWpi">LINK</a>
                    <div
                        style="text-align: left; padding: 20px; background: rgba(46, 204, 113, 0.1); border-radius: 10px;">
                        <h3 style="font-size: 1em; color: #2ecc71;">Zadanie:</h3>
                        <ul style="font-size: 0.85em; line-height: 1.8;">
                            <li>Napisz klasÄ™ <code>Point</code></li>
                            <li>Pola public: <code>x</code>, <code>y</code> (typu int)</li>
                            <li>Metoda: <code>print()</code> wyÅ›wietlajÄ…ca punkt w formacie <code>(x, y)</code></li>
                            <li>StwÃ³rz 2-3 obiekty i wyÅ›wietl ich wartoÅ›ci</li>
                        </ul>

                    </div>
                </section>
            </section>
            <!-- ZAJÄ˜CIA 3: SkÅ‚adowe klasy w C++ (wersja rozszerzona) -->
            <section data-background-gradient="linear-gradient(67deg, #1e5799, #7db9e8)">

                <!-- Slajd tytuÅ‚owy -->
                <section>
                    <h2>ZAJÄ˜CIA 3</h2>
                    <h3>SkÅ‚adowe klasy w C++</h3>
                    <p style="font-size: 0.8em; margin-top: 15px;">
                        SkÅ‚adnia klasy, modyfikatory dostÄ™pu, konstruktory, gettery i settery,
                        metody obliczajÄ…ce i wyÅ›wietlajÄ…ce, sÅ‚owo kluczowe <code>const</code>.
                    </p>
                </section>

                <!-- Klasa jako przepis na obiekt -->
                <section>
                    <h2>Klasa â€“ przepis na obiekt</h2>
                    <pre><code class="hljs cpp" data-trim>
            class User {
                // tutaj bÄ™dzie opis tego,
                // co kaÅ¼dy "uÅ¼ytkownik" posiada i co potrafi
            };
                </code></pre>
                    <ul style="font-size:0.8em; line-height:1.5; margin-top: 10px;">
                        <li>Klasa to przepis (szablon), wedÅ‚ug ktÃ³rego tworzone sÄ… obiekty.</li>
                        <li>Obiekt to konkretny egzemplarz klasy, np. konkretny uÅ¼ytkownik, konkretny pracownik,
                            konkretne
                            zamÃ³wienie.</li>
                        <li>W klasie opisujemy: jakie dane przechowuje obiekt (pola) oraz jakie operacje moÅ¼na na nim
                            wykonywaÄ‡
                            (metody).</li>
                    </ul>
                    <p style="font-size:0.75em; margin-top: 8px;">
                        Kod <code>class User { ... };</code> nie tworzy jeszcze Å¼adnego obiektu â€“ tylko nowy typ,
                        ktÃ³rego pÃ³Åºniej
                        uÅ¼yjemy.
                    </p>
                </section>

                <!-- SkÅ‚adnia klasy - kaÅ¼dy element -->
                <section>
                    <h2>SkÅ‚adnia klasy w C++</h2>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
            class User {
            private:
                // pola â€“ dane wewnÄ™trzne obiektu
                std::string login;
                std::string role;
            
            public:
                // konstruktory
                User();                          // konstruktor domyÅ›lny
                User(const std::string&amp; l);      // konstruktor z parametrem
            
                // metody publiczne
                void setRole(const std::string&amp; newRole);
                std::string getRole() const;
            
            protected:
                // elementy widoczne w klasach pochodnych
                void resetRoleToDefault();
            }; // Å›rednik jest obowiÄ…zkowy
                </code></pre>
                    <ul style="font-size:0.75em; margin-top:10px; line-height:1.5;">
                        <li><code>class</code> â€“ sÅ‚owo kluczowe, po nim nazwa klasy (zwykle z duÅ¼ej litery).</li>
                        <li>WewnÄ…trz klamerek <code>{ }</code> opisujemy kolejno pola i metody, grupujÄ…c je wedÅ‚ug
                            dostÄ™pu:
                            <code>private</code>, <code>public</code>, <code>protected</code>.
                        </li>
                        <li>Po definicji klasy musi byÄ‡ Å›rednik <code>;</code> â€“ to czÄ™sty bÅ‚Ä…d poczÄ…tkujÄ…cych.</li>
                    </ul>
                </section>

                <!-- Modyfikatory dostÄ™pu - idea -->
                <section>
                    <h3 style="font-size: 1.3em;">Modyfikatory dostÄ™pu</h3>
                    <div class="row" style="font-size:0.75em; margin-top: 5px;">
                        <div class="column" style="padding: 5px;">
                            <h4 style="color:#e74c3c; font-size:0.95em; margin: 5px 0;">private</h4>
                            <ul style="line-height:1.3; margin-top: 5px;">
                                <li>DostÄ™p tylko z metod tej samej klasy (oraz ewentualnie zaprzyjaÅºnionych).</li>
                                <li>NajczÄ™Å›ciej uÅ¼ywane dla pÃ³l â€“ ukrywamy szczegÃ³Å‚y dziaÅ‚ania.</li>
                                <li>Chroni przed przypadkowÄ… zmianÄ… stanu obiektu z zewnÄ…trz.</li>
                            </ul>
                        </div>
                        <div class="column" style="padding: 5px;">
                            <h4 style="color:#2ecc71; font-size:0.95em; margin: 5px 0;">public</h4>
                            <ul style="line-height:1.3; margin-top: 5px;">
                                <li>Widoczne wszÄ™dzie tam, gdzie widoczna jest klasa.</li>
                                <li>Definiuje â€interfejs" klasy â€“ to, czego mogÄ… uÅ¼ywaÄ‡ inni.</li>
                                <li>Typowe miejsce na konstruktory, metody obsÅ‚ugi i gettery/settery.</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 8px; font-size:0.75em;">
                        <h4 style="color:#9b59b6; font-size:0.95em; margin: 5px 0;">protected</h4>
                        <ul style="line-height:1.3; margin-top: 5px;">
                            <li>Niewidoczne z zewnÄ…trz, ale dostÄ™pne w klasach dziedziczÄ…cych.</li>
                            <li>Przydatne, gdy projektujemy rodzinÄ™ klas (bazowa + pochodne).</li>
                        </ul>
                    </div>
                    <p style="font-size:0.7em; margin-top:6px;">
                        Dobra praktyka: pola zwykle sÄ… <code>private</code>, a metody, ktÃ³rych ma uÅ¼ywaÄ‡ uÅ¼ytkownik
                        klasy, sÄ…
                        <code>public</code>.
                    </p>
                </section>

                <!-- private / public w praktyce -->
                <section>
                    <h3 style="font-size: 1.3em; margin-bottom: 10px;">private i public w praktyce</h3>
                    <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
            class Employee {
            private:
                std::string name;
                double monthlySalary;
            
            public:
                // publiczny interfejs â€“ to moÅ¼e zrobiÄ‡ "Å›wiat zewnÄ™trzny"
                void setName(const std::string&amp; newName) {
                    name = newName;   // dostÄ™p OK â€“ jesteÅ›my w Å›rodku klasy
                }
            
                void setMonthlySalary(double salary) {
                    if (salary &gt;= 0) {   // walidacja danych
                        monthlySalary = salary;
                    }
                }
            
                void print() const {
                    std::cout &lt;&lt; "Pracownik: " &lt;&lt; name
                              &lt;&lt; ", pensja: " &lt;&lt; monthlySalary
                              &lt;&lt; std::endl;
                }
            };
                </code></pre>
                    <ul style="font-size:0.75em; margin-top: 8px; line-height:1.4;">
                        <li>Z kodu zewnÄ™trznego nie moÅ¼na napisaÄ‡ <code>emp.name = "...";</code> â€“ pole jest prywatne.
                        </li>
                        <li>Zmiana pensji i imienia jest moÅ¼liwa tylko przez metody <code>setName</code> i
                            <code>setMonthlySalary</code>, ktÃ³re mogÄ… sprawdzaÄ‡ poprawnoÅ›Ä‡ danych.
                        </li>
                    </ul>
                </section>

                <!-- Gettery i settery - po co -->
                <section>
                    <h2>Gettery i settery â€“ po co?</h2>
                    <ul style="font-size:0.8em; line-height:1.6; margin-top: 10px;">
                        <li><strong>Getter</strong> â€“ metoda, ktÃ³ra zwraca wartoÅ›Ä‡ pola (tylko odczyt).</li>
                        <li><strong>Setter</strong> â€“ metoda, ktÃ³ra zmienia wartoÅ›Ä‡ pola (zapis + ewentualna walidacja).
                        </li>
                        <li>DziÄ™ki getterom i setterom moÅ¼emy:
                            <ul style="margin-top: 4px;">
                                <li>ukryÄ‡ pola przed Å›wiatem zewnÄ™trznym (<code>private</code>),</li>
                                <li>dodawaÄ‡ sprawdzanie poprawnoÅ›ci danych,</li>
                                <li>zmieniÄ‡ sposÃ³b przechowywania danych bez zmiany kodu, ktÃ³ry uÅ¼ywa klasy.</li>
                            </ul>
                        </li>
                    </ul>
                    <p style="font-size:0.75em; margin-top:8px;">
                        Bez getterÃ³w/setterÃ³w kaÅ¼dy mÃ³gÅ‚by dowolnie zmieniaÄ‡ pola, co szybko prowadzi do bÅ‚Ä™dÃ³w trudnych
                        do
                        znalezienia.
                    </p>
                </section>

                <!-- Gettery i settery - przykÅ‚ad -->
                <section>
                    <h2>Gettery i settery â€“ przykÅ‚ad</h2>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
            class Account {
            private:
                std::string owner;
                double balance;
            
            public:
                // konstruktor z parametrami domyÅ›lnymi
                Account(const std::string&amp; ownerName, double initialBalance)
                    : owner(ownerName), balance(initialBalance) {}
            
                // getter â€“ tylko odczyt
                std::string getOwner() const {
                    return owner;
                }
            
                double getBalance() const {
                    return balance;
                }
            
                // setter (poÅ›rednio) â€“ zmiana stanu z walidacjÄ…
                void deposit(double amount) {
                    if (amount &gt; 0) {
                        balance += amount;
                    }
                }
            };
                </code></pre>
                    <p style="font-size:0.8em; margin-top: 10px;">
                        ZauwaÅ¼, Å¼e <code>getOwner</code> i <code>getBalance</code> sÄ… metodami <code>const</code> â€“
                        tylko czytajÄ…
                        stan obiektu.
                    </p>
                </section>

                <!-- Metody obliczajÄ…ce i wyÅ›wietlajÄ…ce - idea -->
                <section>
                    <h2>Metody obliczajÄ…ce i wyÅ›wietlajÄ…ce</h2>
                    <ul style="font-size:0.8em; line-height:1.6; margin-top: 10px;">
                        <li><strong>Metoda obliczajÄ…ca</strong> â€“ na podstawie pÃ³l obiektu liczy jakÄ…Å› wartoÅ›Ä‡ i jÄ…
                            zwraca, np.
                            caÅ‚kowity koszt, Å›redniÄ…, liczbÄ™ dni itp.</li>
                        <li><strong>Metoda wyÅ›wietlajÄ…ca</strong> â€“ wypisuje czytelny opis obiektu (np. na ekran, do
                            logÃ³w).</li>
                        <li>CzÄ™sto metoda wyÅ›wietlajÄ…ca wewnÄ…trz uÅ¼ywa metody obliczajÄ…cej, Å¼eby nie duplikowaÄ‡ logiki
                            obliczeÅ„.
                        </li>
                    </ul>
                    <p style="font-size:0.75em; margin-top:8px;">
                        Obie te metody zwykle nie zmieniajÄ… stanu obiektu, wiÄ™c powinny byÄ‡ oznaczone jako
                        <code>const</code>.
                    </p>
                </section>

                <!-- Metody obliczajÄ…ce i wyÅ›wietlajÄ…ce - przykÅ‚ad -->
                <section>
                    <h3 style="font-size: 1.3em; margin-bottom: 10px;">Metody obliczajÄ…ce â€“ przykÅ‚ad</h3>
                    <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
            class Order {
            private:
                std::string customerName;
                int itemCount;
                double itemPrice;
            
            public:
                Order(const std::string&amp; customer, int count, double price)
                    : customerName(customer), itemCount(count), itemPrice(price) {}
            
                // metoda obliczajÄ…ca
                double getTotalCost() const {
                    return itemCount * itemPrice;
                }
            
                // metoda wyÅ›wietlajÄ…ca
                void printSummary() const {
                    std::cout &lt;&lt; "Klient: " &lt;&lt; customerName
                              &lt;&lt; ", sztuk: " &lt;&lt; itemCount
                              &lt;&lt; ", cena/szt: " &lt;&lt; itemPrice
                              &lt;&lt; ", razem: " &lt;&lt; getTotalCost()
                              &lt;&lt; std::endl;
                }
            };
                </code></pre>
                    <ul style="font-size:0.75em; margin-top: 8px; line-height:1.4;">
                        <li>Metoda <code>getTotalCost</code> nie zmienia Å¼adnego pola â€“ tylko liczy i zwraca wynik.</li>
                        <li>Metoda <code>printSummary</code> wyÅ›wietla dane oraz wynik obliczeÅ„, korzystajÄ…c z
                            <code>getTotalCost</code>.
                        </li>
                    </ul>
                </section>

                <!-- Konstruktory - ogÃ³lne wprowadzenie -->
                <section>
                    <h2>Konstruktory â€“ ogÃ³lna idea</h2>
                    <ul style="font-size:0.8em; line-height:1.6; margin-top: 10px;">
                        <li>Konstruktor to specjalna metoda wywoÅ‚ywana automatycznie przy tworzeniu obiektu.</li>
                        <li>Ma takÄ… samÄ… nazwÄ™ jak klasa i nie ma typu zwracanego (nawet <code>void</code>).</li>
                        <li>Jego zadanie: ustawiÄ‡ sensowny stan poczÄ…tkowy obiektu (np. wartoÅ›ci startowe pÃ³l).</li>
                        <li>W C++ moÅ¼na mieÄ‡ kilka konstruktorÃ³w w jednej klasie â€“ rÃ³Å¼niÄ… siÄ™ listÄ… parametrÃ³w.</li>
                    </ul>
                    <p style="font-size:0.75em; margin-top:8px;">
                        WyrÃ³Å¼nimy tutaj dwa podstawowe typy: konstruktor domyÅ›lny oraz konstruktor z parametrami.
                    </p>
                </section>

                <!-- Konstruktor domyÅ›lny - wyjaÅ›nienie -->
                <section>
                    <h3 style="font-size: 1.3em; margin-bottom: 10px;">Konstruktor domyÅ›lny</h3>
                    <small>
                        <ul style="font-size:0.75em; line-height:1.5; margin-top: 8px;">
                            <li>Konstruktor, ktÃ³ry moÅ¼na wywoÅ‚aÄ‡ bez Å¼adnych argumentÃ³w.</li>
                            <li>MoÅ¼e byÄ‡ zdefiniowany jawnie przez programistÄ™, albo wygenerowany automatycznie przez
                                kompilator (jeÅ›li
                                nie ma Å¼adnego innego konstruktora).</li>
                            <li>CzÄ™sto ustawia â€bezpieczne" wartoÅ›ci poczÄ…tkowe (np. zera, wartoÅ›ci pustych tekstÃ³w).
                            </li>
                        </ul>
                        <pre><code class="hljs cpp" data-trim>
            class Profile {
            private:
                std::string nickname;
                int age;
            
            public:
                // konstruktor domyÅ›lny â€“ bez parametrÃ³w
                Profile()
                    : nickname("anonymous"), age(0) {
                    // ciaÅ‚o konstruktora (opcjonalne dziaÅ‚ania)
                }
            };
            
            int main() {
                Profile p;      // wywoÅ‚anie konstruktora domyÅ›lnego
            }
                </code></pre>
                        <p style="font-size:0.7em; margin-top:6px;">
                            Po utworzeniu <code>Profile p;</code> obiekt ma juÅ¼ ustawione sensowne wartoÅ›ci startowe.
                        </p>
                    </small>
                </section>

                <!-- Konstruktor z parametrami - wyjaÅ›nienie -->
                <section>
                    <h3 style="font-size: 1.3em; margin-bottom: 10px;">Konstruktor z parametrami</h3>
                    <small>
                        <ul style="font-size:0.75em; line-height:1.5; margin-top: 8px;">
                            <li>Pozwala od razu przy tworzeniu obiektu przekazaÄ‡ konkretne wartoÅ›ci pÃ³l.</li>
                            <li>DziÄ™ki temu obiekt jest â€od razu gotowy do uÅ¼ycia" â€“ nie trzeba osobno ustawiaÄ‡ kaÅ¼dego
                                pola.</li>
                            <li>CzÄ™sto uÅ¼ywany razem z listÄ… inicjalizacyjnÄ… (po <code>:</code>), aby wydajnie
                                zainicjalizowaÄ‡ pola.
                            </li>
                        </ul>
                        <pre><code class="hljs cpp" data-trim>
            class Device {
            private:
                std::string id;
                bool online;
            
            public:
                // konstruktor z parametrami
                Device(const std::string&amp; deviceId, bool startOnline)
                    : id(deviceId), online(startOnline) {}
            
                void printStatus() const {
                    std::cout &lt;&lt; "UrzÄ…dzenie " &lt;&lt; id
                              &lt;&lt; " online? " &lt;&lt; std::boolalpha &lt;&lt; online
                              &lt;&lt; std::endl;
                }
            };
            
            int main() {
                Device d1("A-123", true);
                Device d2("B-777", false);
                d1.printStatus();
                d2.printStatus();
            }
                </code></pre>
                        <p style="font-size:0.7em; margin-top:6px;">
                            RÃ³Å¼ne argumenty konstruktora dajÄ… rÃ³Å¼ne stany poczÄ…tkowe obiektÃ³w tej samej klasy.
                        </p>
                    </small>
                </section>

                <!-- Konstruktor z parametrami i wartoÅ›ci domyÅ›lne -->
                <section>
                    <h4>Konstruktor z wartoÅ›ciami domyÅ›lnymi</h4>
                    <small>
                        <ul style="font-size:0.75em; line-height:1.5; margin-top: 8px;">
                            <li>Parametry konstruktora mogÄ… mieÄ‡ wartoÅ›ci domyÅ›lne â€“ wtedy czÄ™Å›Ä‡ argumentÃ³w moÅ¼na
                                pominÄ…Ä‡.</li>
                            <li>To pozwala uniknÄ…Ä‡ pisania kilku bardzo podobnych konstruktorÃ³w.</li>
                        </ul>
                        <pre><code class="hljs cpp" data-trim>
            class Session {
            private:
                std::string user;
                int timeoutMinutes;
            
            public:
                // jeden konstruktor z parametrami domyÅ›lnymi
                Session(const std::string&amp; userName = "guest", int timeout = 30)
                    : user(userName), timeoutMinutes(timeout) {}
            
                void printInfo() const {
                    std::cout &lt;&lt; "UÅ¼ytkownik: " &lt;&lt; user
                              &lt;&lt; ", timeout: " &lt;&lt; timeoutMinutes &lt;&lt; " min"
                              &lt;&lt; std::endl;
                }
            };
            
            int main() {
                Session s1;                 // uÅ¼yje "guest", 30
                Session s2("admin");        // uÅ¼yje "admin", 30
                Session s3("user", 5);      // uÅ¼yje "user", 5
                s1.printInfo();
                s2.printInfo();
                s3.printInfo();
            }
                </code></pre>
                        <p style="font-size:0.7em; margin-top:6px;">
                            Wszystkie te trzy obiekty powstajÄ… z jednego konstruktora, ale z innymi danymi wejÅ›ciowymi.
                        </p>
                    </small>
                </section>

                <!-- const przy metodach - idea -->
                <section>
                    <h2>Metoda jako const â€“ idea</h2>
                    <ul style="font-size:0.8em; line-height:1.6; margin-top: 10px;">
                        <li>JeÅ›li metoda nie powinna zmieniaÄ‡ Å¼adnych pÃ³l obiektu, oznaczamy jÄ… jako <code>const</code>
                            po
                            nawiasach.</li>
                        <li>Kompilator bÄ™dzie pilnowaÅ‚, aby taka metoda nie modyfikowaÅ‚a stanu obiektu.</li>
                        <li>Metody <code>const</code> moÅ¼na wywoÅ‚ywaÄ‡ takÅ¼e na obiektach zadeklarowanych jako
                            <code>const</code>.
                        </li>
                        <li>PrzykÅ‚ady metod, ktÃ³re zwykle sÄ… <code>const</code>: gettery, metody obliczajÄ…ce, metody
                            wyÅ›wietlajÄ…ce.
                        </li>
                    </ul>
                </section>

                <!-- const przy metodach - przykÅ‚ad -->
                <section>
                    <h2>Metody const â€“ przykÅ‚ad</h2>
                    <small>
                        <pre><code class="hljs cpp" data-trim>
            class Report {
            private:
                std::string title;
                int pageCount;
            
            public:
                Report(const std::string&amp; t, int pages)
                    : title(t), pageCount(pages) {}
            
                // metoda tylko do odczytu â€“ const
                std::string getTitle() const {
                    // title = "nowy tytuÅ‚";  // BÅÄ„D â€“ nie wolno zmieniaÄ‡ w const
                    return title;
                }
            
                int getPageCount() const {
                    return pageCount;
                }
            
                void print() const {
                    std::cout &lt;&lt; "Raport: " &lt;&lt; title
                              &lt;&lt; " (" &lt;&lt; pageCount &lt;&lt; " stron)" &lt;&lt; std::endl;
                }
            };
            
            void showReport(const Report&amp; rep) {
                // moÅ¼emy wywoÅ‚aÄ‡ tylko metody const
                std::cout &lt;&lt; rep.getTitle() &lt;&lt; std::endl;
                // rep.print(); // teÅ¼ OK, bo print() jest const
                // rep.setTitle("X"); // byÅ‚by BÅÄ„D, gdyby istniaÅ‚ nie-const setter
            }
                </code></pre>
                        <p style="font-size:0.75em; margin-top:8px;">
                            DziÄ™ki <code>const</code> mamy gwarancjÄ™, Å¼e funkcje takie jak <code>showReport</code>
                            nie zmieniÄ… obiektu, ktÃ³ry dostaÅ‚y do odczytu.
                        </p>
                    </small>
                </section>

                <!-- Podsumowanie kluczowych elementÃ³w klasy -->
                <section>
                    <h2>Podstawowe elementy klasy</h2>
                    <ul style="font-size:0.8em; line-height:1.6; margin-top: 10px;">
                        <li>Pola (zwykle <code>private</code>) â€“ trzymajÄ… stan obiektu.</li>
                        <li>Metody publiczne â€“ tworzÄ… interfejs klasy (co obiekt potrafi).</li>
                        <li>Konstruktor domyÅ›lny â€“ pozwala utworzyÄ‡ obiekt bez parametrÃ³w.</li>
                        <li>Konstruktor z parametrami â€“ od razu ustawia konkretny stan poczÄ…tkowy.</li>
                        <li>Gettery i settery â€“ kontrolowany dostÄ™p do pÃ³l.</li>
                        <li>Metody obliczajÄ…ce/wyÅ›wietlajÄ…ce â€“ operacje na danych obiektu, zwykle <code>const</code>.
                        </li>
                    </ul>
                </section>

            </section>

            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">Zadanie PO/lab0-rectangle</h2>
                    <a href="https://classroom.github.com/a/HgQ5yLLi">LINK</a>
                    <p style="color: red;">Notatka dla prowadzÄ…cego: usunÄ…Ä‡ pliki nagÅ‚owkowe. Zostana wprowadzone
                        pÃ³Åºniej!!</p>

                </section>
            </section>
            <section data-background-gradient="linear-gradient(67deg, #1e5799, #7db9e8)">
                <section data-auto-animate>
                    <h3>Diagram klas</h3>
                    <img style="max-height: 600px;" src="assets/class_diagram_Zad1.png">
                </section>
                <section data-auto-animate>
                    <h3>Jak czytaÄ‡ diagramy klas?</h3>
                    <img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
                    <small>
                        <ul>
                            <li><b>Klasy</b>: ProstokÄ…ty reprezentujÄ… klasy. Nazwa klasy jest umieszczona na gÃ³rze
                                prostokÄ…ta.
                            </li>
                            <li><b>Atrybuty</b>: PoniÅ¼ej nazwy klasy znajdujÄ… siÄ™ atrybuty (pola, zmienne), ktÃ³re
                                przechowujÄ…
                                dane. SÄ…
                                one zazwyczaj oznaczone
                                symbolem + dla publicznych lub - dla prywatnych.</li>
                            <li><b>Metody</b>: Jeszcze niÅ¼ej umieszczone sÄ… metody (funkcje), ktÃ³re definiujÄ… zachowanie
                                klasy.
                                Podobnie jak atrybuty, metody
                                mogÄ… byÄ‡ oznaczone jako publiczne (+) lub prywatne (-).</li>
                        </ul>
                    </small>
                </section>
                <section data-auto-animate>
                    <h3>Jak czytaÄ‡ diagramy klas?</h3>
                    <img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
                    <small>
                        <ul>
                            <li><b>Relacje</b>: Linie Å‚Ä…czÄ…ce klasy reprezentujÄ… rÃ³Å¼ne typy relacji miÄ™dzy nimi. Na
                                przykÅ‚ad:
                            </li>
                            <li><b>Asocjacja</b>: ZwykÅ‚a linia oznacza, Å¼e dwie klasy sÄ… w jakiÅ› sposÃ³b powiÄ…zane.
                                StrzaÅ‚ki
                                mogÄ…
                                wskazywaÄ‡ kierunek asocjacji,
                                a liczby (np. "1" lub "*") okreÅ›lajÄ… krotnoÅ›Ä‡ (ile obiektÃ³w jednej klasy moÅ¼e byÄ‡
                                powiÄ…zanych z
                                obiektem drugiej klasy).</li>
                        </ul>
                    </small>
                </section>
                <section data-auto-animate>
                    <h3>Jak czytaÄ‡ diagramy klas?</h3>
                    <img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
                    <small>
                        <ul>
                            <li><b>Dziedziczenie</b>: Linia zakoÅ„czona pustym trÃ³jkÄ…tem wskazuje na dziedziczenie lub
                                relacjÄ™
                                typu
                                "jest rodzajem".</li>
                            <li><b>KrotnoÅ›Ä‡</b>: Przy relacjach, liczby takie jak "1" lub "" okreÅ›lajÄ…, ile instancji
                                jednej
                                klasy moÅ¼e
                                byÄ‡ powiÄ…zanych z
                                instancjÄ… drugiej klasy. Na przykÅ‚ad "1" oznacza pojedynczÄ… instancjÄ™, a "" oznacza
                                wiele
                                instancji.</li>
                        </ul>
                    </small>
                </section>
                <section data-auto-animate>
                    <h3>Jak czytaÄ‡ diagramy klas?</h3>
                    <img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
                    <small>
                        Na podstawie tego diagramu moÅ¼emy zobaczyÄ‡, Å¼e klasa Article zawiera prywatne atrybuty takie jak
                        title, author,
                        publicationYear, journal i publiczne metody takie jak konstruktory, displayInfo(), getTitle(),
                        getAuthor(),
                        getPublicationYear(), getJournal(). Podobnie dla klas Author, Book i Chapter. Ponadto, relacje
                        miÄ™dzy klasami wskazujÄ…,
                        Å¼e Article, Book i Chapter zawierajÄ… obiekty klasy Author, a Book zawiera rÃ³wnieÅ¼ kolekcjÄ™
                        obiektÃ³w Chapter.
                    </small>
                </section>
                <section>
                    <h3><b>&&&</b> ?</h3>
                    <small>
                        W jÄ™zyku C++ symbol <b>&</b> w kontekÅ›cie parametru funkcji oznacza referencjÄ™. Referencje
                        pozwalajÄ… funkcjom na dostÄ™p do
                        obiektÃ³w przekazanych do nich bez koniecznoÅ›ci kopiowania tych obiektÃ³w. To znaczy, Å¼e funkcja
                        moÅ¼e operowaÄ‡
                        bezpoÅ›rednio na oryginalnym obiekcie, a nie na jego kopii, co jest wydajniejsze, szczegÃ³lnie dla
                        duÅ¼ych obiektÃ³w.
                    </small>
                    <small>
                        W kontekÅ›cie diagramu klas UML, ktÃ³ry przedstawiono, <b>&other</b> w konstruktorze kopiujÄ…cym
                        oznacza, Å¼e konstruktor przyjmuje
                        referencjÄ™ do innego obiektu tej samej klasy. Na przykÅ‚ad:
                    </small>
                    <pre style="font-size: 16px" data-id="code-animation">
						<code class="hljs cpp"><script type="text/template">
						Article::Article(const Article &other)
						</script>
						</code>
						</pre>
                    <small>
                        Ten konstruktor kopiujÄ…cy Article przyjmuje referencjÄ™ do innego obiektu Article i uÅ¼ywa jego
                        wartoÅ›ci do zainicjowania
                        nowego obiektu. To jest standardowy sposÃ³b implementacji konstruktora kopiujÄ…cego w C++, ktÃ³ry
                        zapewnia, Å¼e nowy obiekt
                        jest kopiÄ… istniejÄ…cego obiektu.
                    </small>
                </section>

                <section>
                    <h3>Referencja (&) vs WskaÅºnik (*)</h3>
                    <div class="row" style="font-size: 0.75em;">
                        <div class="column">
                            <h4 style="color: #3498db;">Referencja (&)</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
void modify(Article& art) {
    art.setTitle("Nowy tytuÅ‚");
    // UÅ¼ywamy jak zwykÅ‚y obiekt
}

Article a("Stary tytuÅ‚");
modify(a);  // Przekazanie przez referencjÄ™
// a ma teraz "Nowy tytuÅ‚"
                            </code></pre>
                            <ul style="font-size: 0.85em; line-height: 1.4;">
                                <li>âœ… SkÅ‚adnia jak zwykÅ‚y obiekt</li>
                                <li>âœ… Nie moÅ¼e byÄ‡ NULL</li>
                                <li>âœ… Musi byÄ‡ zainicjalizowana</li>
                                <li>âœ… Nie moÅ¼na zmieniÄ‡, na co wskazuje</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h4 style="color: #e67e22;">WskaÅºnik (*)</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
void modify(Article* art) {
    if (art != nullptr) {
        art->setTitle("Nowy tytuÅ‚");
        // UÅ¼ywamy operator ->
    }
}

Article a("Stary tytuÅ‚");
modify(&a);  // Przekazanie adresu
// a ma teraz "Nowy tytuÅ‚"
                            </code></pre>
                            <ul style="font-size: 0.85em; line-height: 1.4;">
                                <li>âš ï¸ SkÅ‚adnia ze strzaÅ‚kÄ… (->)</li>
                                <li>âš ï¸ MoÅ¼e byÄ‡ NULL/nullptr</li>
                                <li>âš ï¸ MoÅ¼e byÄ‡ niezainicjalizowany</li>
                                <li>âœ… MoÅ¼na zmieniÄ‡, na co wskazuje</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Kiedy uÅ¼ywaÄ‡ & a kiedy *?</h3>
                    <div style="text-align: left; font-size: 0.75em;">
                        <div
                            style="margin: 10px 0; padding: 12px; background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db;">
                            <strong>UÅ¼ywaj referencji (&) gdy:</strong>
                            <ul style="margin-top: 8px; line-height: 1.5;">
                                <li>Obiekt zawsze musi istnieÄ‡ (nie moÅ¼e byÄ‡ NULL)</li>
                                <li>Chcesz prostszej skÅ‚adni (brak -> i *)</li>
                                <li>Parametry funkcji (zwÅ‚aszcza const&)</li>
                                <li>Operator przypisania i konstruktor kopiujÄ…cy</li>
                            </ul>
                            <pre style="font-size: 10px; margin-top: 8px;"><code class="hljs cpp" data-trim>
void display(const Article& art);  // Nie kopiujemy, tylko czytamy
Article& operator=(const Article& other);  // Operator przypisania
                            </code></pre>
                        </div>
                        <div
                            style="margin: 10px 0; padding: 12px; background: rgba(230, 126, 34, 0.1); border-left: 3px solid #e67e22;">
                            <strong>UÅ¼ywaj wskaÅºnika (*) gdy:</strong>
                            <ul style="margin-top: 8px; line-height: 1.5;">
                                <li>Obiekt moÅ¼e nie istnieÄ‡ (opcjonalny)</li>
                                <li>Potrzebujesz zmieniÄ‡ na co wskazuje</li>
                                <li>Dynamiczna alokacja pamiÄ™ci (new/delete)</li>
                                <li>ZgodnoÅ›Ä‡ z C lub starszym kodem</li>
                            </ul>
                            <pre style="font-size: 10px; margin-top: 8px;"><code class="hljs cpp" data-trim>
Article* findArticle(const std::string& title);  // MoÅ¼e zwrÃ³ciÄ‡ nullptr
Article* articles = new Article[10];  // Dynamiczna tablica
                            </code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>PrzykÅ‚ad porÃ³wnawczy</h3>
                    <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
class Book {
private:
    Article* mainArticle;      // WskaÅºnik - moÅ¼e byÄ‡ nullptr
    std::vector<Article> articles;  // Wektor przechowuje obiekty

public:
    // Konstruktor przyjmuje referencjÄ™ (obiekt musi istnieÄ‡)
    Book(const Article& main) {
        mainArticle = new Article(main);  // Tworzymy kopiÄ™
    }
    
    // Metoda przyjmuje wskaÅºnik (artykuÅ‚ moÅ¼e byÄ‡ opcjonalny)
    void setMainArticle(Article* art) {
        if (art != nullptr) {
            delete mainArticle;
            mainArticle = new Article(*art);
        }
    }
    
    // Metoda zwraca referencjÄ™ (artykuÅ‚ zawsze istnieje)
    Article& getArticle(int index) {
        return articles[index];
    }
    
    // Metoda zwraca wskaÅºnik (moÅ¼e nie znaleÅºÄ‡)
    Article* findArticle(const std::string& title) {
        for (auto& art : articles) {
            if (art.getTitle() == title)
                return &art;  // Zwracamy adres
        }
        return nullptr;  // Nie znaleziono
    }
    
    ~Book() {
        delete mainArticle;  // Zwalniamy pamiÄ™Ä‡
    }
};
                    </code></pre>
                </section>
            </section>
            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">Zadanie PO/lab1-article</h2>
                    <a href="https://classroom.github.com/a/4RgTCcBl">LINK</a>

                </section>
            </section>
            <section data-background-gradient="linear-gradient(175deg, #09bc8a, #565896)" data-auto-animate>
                <section>
                    <h2>ZarzÄ…dzanie pamiÄ™ciÄ… w programowaniu obiektowym:<h2>
                            </h3>Wprowadzenie do operatorÃ³w new i delete</h3>
                </section>
                <section>
                    <h3>Alokacja pamiÄ™ci dynamicznej</h3>
                    <p>
                        Alokacja pamiÄ™ci dynamicznej to proces przydzielania pamiÄ™ci w trakcie dziaÅ‚ania programu. W
                        przeciwieÅ„stwie do
                        pamiÄ™ci statycznej, ktÃ³ra jest przydzielana na etapie kompilacji, pamiÄ™Ä‡ dynamiczna jest
                        przydzielana na Å¼Ä…danie
                        i moÅ¼e byÄ‡ zwalniana, gdy nie jest juÅ¼ potrzebna. Pozwala to na tworzenie struktur danych,
                        ktÃ³re
                        mogÄ… zmieniaÄ‡
                        rozmiar w trakcie dziaÅ‚ania programu, takich jak listy dynamiczne i drzewa.
                    </p>
                </section>
                <section>
                    <h3>Zwalnianie pamiÄ™ci dynamicznej</h3>
                    <ul>
                        <li>
                            <small>Zwalnianie pamiÄ™ci dynamicznej to proces odzyskiwania pamiÄ™ci, ktÃ³ra zostaÅ‚a
                                wczeÅ›niej zaalokowana
                                dynamicznie. Jest to waÅ¼ne, poniewaÅ¼ pamiÄ™Ä‡, ktÃ³ra nie jest zwolniona po uÅ¼yciu,
                                moÅ¼e
                                prowadziÄ‡ do
                                wyciekÃ³w pamiÄ™ci.</small>
                        </li>
                        <li>
                            <small>W programowaniu obiektowym, zwalnianie pamiÄ™ci jest czÄ™sto zwiÄ…zane z
                                destruktorami -
                                specjalnymi
                                funkcjami, ktÃ³re sÄ… wywoÅ‚ywane, gdy obiekt jest niszczony. Destruktory sÄ…
                                odpowiedzialne
                                za zwalnianie
                                wszelkich zasobÃ³w, ktÃ³re obiekt mÃ³gÅ‚ zaalokowaÄ‡ podczas swojego istnienia.</small>
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Wprowadzenie do zarzÄ…dzania pamiÄ™ciÄ…</h3>
                    <p>
                        ZarzÄ…dzanie pamiÄ™ciÄ… to kluczowy aspekt programowania, ktÃ³ry polega na kontrolowaniu i
                        koordynowaniu dostÄ™pu do
                        pamiÄ™ci komputera. W programowaniu obiektowym, zarzÄ…dzanie pamiÄ™ciÄ… jest szczegÃ³lnie
                        waÅ¼ne, poniewaÅ¼ obiekty
                        czÄ™sto wymagajÄ… alokacji i zwalniania pamiÄ™ci dynamicznej.
                    </p>
                </section>
                <section>
                    <h3>Operator new</h3>
                    <p>
                        Operator <b>new</b> jest uÅ¼ywany w programowaniu obiektowym do alokacji, czyli przydzielania
                        pamiÄ™ci dla
                        nowych obiektÃ³w. Jest to specjalna funkcja, ktÃ³ra tworzy miejsce w pamiÄ™ci komputera na
                        przechowywanie danych
                        obiektu.
                    </p>
                    <p>
                        Kiedy tworzony jest nowy obiekt za pomocÄ… operatora <b>new</b>, system najpierw znajduje
                        wystarczajÄ…co duÅ¼o
                        pamiÄ™ci, aby pomieÅ›ciÄ‡ obiekt, a nastÄ™pnie zwraca adres tego miejsca w pamiÄ™ci. MoÅ¼na
                        nastÄ™pnie
                        uÅ¼yÄ‡ tego
                        adresu do odwoÅ‚ywania siÄ™ do obiektu.
                    </p>
                </section>
                <section>
                    <h3>Operator delete</h3>
                    <p>
                        Operator <b>delete</b> jest uÅ¼ywany do zwalniania, czyli odzyskiwania pamiÄ™ci, ktÃ³ra zostaÅ‚a
                        wczeÅ›niej
                        zaalokowana za pomocÄ… operatora <b>new</b>. Kiedy obiekt nie jest juÅ¼ potrzebny, moÅ¼na uÅ¼yÄ‡
                        operatora
                        <b>delete</b>, ktÃ³ry zwalnia pamiÄ™Ä‡, ktÃ³rÄ… obiekt zajmuje, co pozwala na jej ponowne uÅ¼ycie.
                    </p>
                    <p>
                        Jest to waÅ¼ne, poniewaÅ¼ niezwolnienie pamiÄ™ci, ktÃ³ra nie jest juÅ¼ potrzebna, moÅ¼e prowadziÄ‡
                        do
                        wyciekÃ³w pamiÄ™ci.
                        Wycieki pamiÄ™ci mogÄ… spowodowaÄ‡, Å¼e program bÄ™dzie dziaÅ‚aÅ‚ wolniej, a w skrajnych
                        przypadkach
                        moÅ¼e nawet
                        doprowadziÄ‡ do awarii programu.
                    </p>
                </section>
                <section>
                    <h3>KorzyÅ›ci z tworzenia obiektÃ³w za pomocÄ… operatora new</h3>
                    <ul>
                        <li>
                            <small>Dynamiczna alokacja pamiÄ™ci: Operator <code>new</code> pozwala na dynamicznÄ…
                                alokacjÄ™
                                pamiÄ™ci, co
                                oznacza, Å¼e pamiÄ™Ä‡ jest przydzielana w trakcie dziaÅ‚ania programu. DziÄ™ki temu
                                moÅ¼emy
                                tworzyÄ‡ obiekty o
                                rozmiarze nieznanych nam na etapie kompilacji.</small>
                        </li>
                        <li>
                            <small>Å»ywotnoÅ›Ä‡ obiektu: Obiekty utworzone za pomocÄ… operatora <code>new</code>
                                istniejÄ… do
                                momentu ich
                                usuniÄ™cia za pomocÄ… operatora <code>delete</code>. To oznacza, Å¼e obiekt utworzony
                                za
                                pomocÄ…
                                <code>new</code> moÅ¼e przetrwaÄ‡ dÅ‚uÅ¼ej niÅ¼ obiekt utworzony za pomocÄ… klasycznego
                                konstruktora, ktÃ³ry
                                jest zniszczony, gdy opuszcza swÃ³j zakres (scope).</small>
                        </li>
                        <li>
                            <small>FlexybilnoÅ›Ä‡: Operator <code>new</code> daje wiÄ™kszÄ… kontrolÄ™ nad procesem
                                tworzenia
                                obiektÃ³w, co
                                moÅ¼e byÄ‡ przydatne w niektÃ³rych zaawansowanych scenariuszach programowania.</small>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>PrzykÅ‚ad uÅ¼ycia operatorÃ³w new i delete</h3>
                    <small>
                        PoniÅ¼ej znajduje siÄ™ przykÅ‚ad kodu w jÄ™zyku C++, ktÃ³ry pokazuje, jak uÅ¼ywaÄ‡ operatorÃ³w
                        <code>new</code> i
                        <code>delete</code>:
                    </small>
                    <pre style="font-size: 16px;"><code>
// Definicja klasy
class MyClass {
public:
		MyClass() {
				std::cout << "Obiekt MyClass zostaÅ‚ utworzony.\n";
		}
		~MyClass() {
				std::cout << "Obiekt MyClass zostaÅ‚ zniszczony.\n";
		}
};

int main() {
  // UÅ¼ycie operatora new do utworzenia obiektu MyClass
  MyClass* myObject = new MyClass();

  // UÅ¼ycie operatora delete do zniszczenia obiektu MyClass
  delete myObject;
};

					    </code></pre>
                    <small>
                        W tym przykÅ‚adzie, najpierw definiujemy klasÄ™ <code>MyClass</code> z konstruktorem i
                        destruktorem. NastÄ™pnie
                        uÅ¼ywamy operatora <code>new</code> do utworzenia nowego obiektu <code>MyClass</code> i
                        zapisujemy adres tego
                        obiektu w zmiennej <code>myObject</code>. Na koÅ„cu uÅ¼ywamy operatora <code>delete</code> do
                        zniszczenia obiektu
                        i zwolnienia pamiÄ™ci.
                    </small>
                </section>
                <section>
                    <h3>Zaawansowany przykÅ‚ad uÅ¼ycia operatorÃ³w new i delete</h3>
                    <small>
                        PoniÅ¼ej znajduje siÄ™ zaawansowany przykÅ‚ad kodu w jÄ™zyku C++, ktÃ³ry pokazuje, jak uÅ¼ywaÄ‡
                        operatorÃ³w
                        <code>new</code> i <code>delete</code> do dynamicznego zarzÄ…dzania tablicÄ… obiektÃ³w:
                    </small>
                    <pre style="font-size: 16px;"><code>
// Definicja klasy
class MyClass {
public:
		MyClass() {
				std::cout << "Obiekt MyClass zostaÅ‚ utworzony.\n";
		}
		~MyClass() {
				std::cout << "Obiekt MyClass zostaÅ‚ zniszczony.\n";
		}
};
int main() {
		// UÅ¼ycie operatora new do utworzenia tablicy obiektÃ³w MyClass
		MyClass* myObjects = new MyClass[10];

		// UÅ¼ycie operatora delete[] do zniszczenia tablicy obiektÃ³w MyClass
		delete[] myObjects;
};
					    </code></pre>
                    <small>
                        W tym przykÅ‚adzie, najpierw definiujemy klasÄ™ <code>MyClass</code> z konstruktorem i
                        destruktorem. NastÄ™pnie
                        uÅ¼ywamy operatora <code>new</code> do utworzenia tablicy 10 obiektÃ³w <code>MyClass</code> i
                        zapisujemy adres tej
                        tablicy w zmiennej <code>myObjects</code>. Na koÅ„cu uÅ¼ywamy operatora <code>delete[]</code>
                        do
                        zniszczenia
                        tablicy obiektÃ³w i zwolnienia pamiÄ™ci.
                    </small>
                    <small>
                        Ten przykÅ‚ad pokazuje, jak operator <code>new</code> moÅ¼e byÄ‡ uÅ¼ywany do dynamicznego
                        tworzenia
                        tablic obiektÃ³w,
                        co jest jednym z kluczowych aspektÃ³w programowania obiektowego.
                    </small>
                </section>
                <section>
                    <h3>Zaawansowany przykÅ‚ad uÅ¼ycia destruktora</h3>
                    <small>
                        PoniÅ¼ej znajduje siÄ™ zaawansowany przykÅ‚ad kodu w jÄ™zyku C++, ktÃ³ry pokazuje, jak uÅ¼ywaÄ‡
                        destruktora do
                        zwalniania zasobÃ³w:
                    </small>
                    <div>
                        <pre style="font-size: 16px;"><code style="max-height: 300px;">
// Definicja klasy
class MyClass {
public:
		int* myArray;

		MyClass() {
				myArray = new int[10];
				std::cout << "Obiekt MyClass zostaÅ‚ utworzony i pamiÄ™Ä‡ zostaÅ‚a zaalokowana.\n";
		}

		~MyClass() {
				delete[] myArray;
				std::cout << "Obiekt MyClass zostaÅ‚ zniszczony i pamiÄ™Ä‡ zostaÅ‚a zwolniona.\n";
		}
};

int	main() {
		// UÅ¼ycie operatora new do utworzenia obiektu MyClass
		MyClass* myObject = new MyClass();

		// UÅ¼ycie operatora delete do zniszczenia obiektu MyClass
		delete myObject;
};
    </code></pre>
                    </div>
                    <small>
                        W tym przykÅ‚adzie, klasa <code>MyClass</code> ma konstruktor, ktÃ³ry alokuje pamiÄ™Ä‡ dla
                        tablicy
                        10 liczb
                        caÅ‚kowitych, i destruktor, ktÃ³ry zwalnia tÄ™ pamiÄ™Ä‡. Kiedy tworzymy nowy obiekt
                        <code>MyClass</code> za pomocÄ…
                        operatora <code>new</code>, konstruktor jest wywoÅ‚ywany i pamiÄ™Ä‡ jest alokowana. Kiedy
                        niszczymy
                        obiekt za
                        pomocÄ… operatora <code>delete</code>, destruktor jest wywoÅ‚ywany i pamiÄ™Ä‡ jest zwalniana.
                        Ten przykÅ‚ad pokazuje, jak destruktor moÅ¼e byÄ‡ uÅ¼ywany do automatycznego zwalniania zasobÃ³w,
                        co
                        jest kluczowym
                        aspektem zarzÄ…dzania pamiÄ™ciÄ… w programowaniu obiektowym.
                    </small>
                </section>
            </section>
            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">PO/lab2-library</h2>
                    <a href="https://classroom.github.com/a/Bzu7fDl_">LINK</a>

                </section>
            </section>
            			<section data-background-gradient="linear-gradient(175deg, #009b72, #43447b)">

				<section>
					<h2>Polimorfizm</h2>
					<h3>PrzeciÄ…zanie funkcji i metod</h3>
				</section>
				<section data-auto-animate>
					<h3>PrzeciÄ…Å¼anie funkcji</h3>
					<small>
						PrzeciÄ…Å¼anie funkcji to technika programowania, ktÃ³ra pozwala na definiowanie wielu funkcji o
						tej samej nazwie,
						ale rÃ³Å¼niÄ…cych siÄ™ typami i/lub liczbÄ… argumentÃ³w. Kompilator wybiera odpowiedniÄ… funkcjÄ™ do
						wywoÅ‚ania na
						podstawie argumentÃ³w uÅ¼ytych podczas wywoÅ‚ania.
					</small>
					<pre>PrzykÅ‚ad przeciÄ…Å¼ania funkcji w C++<code><script type="text/template">void print(int i) {
				std::cout << "Here is int: " << i << std::endl;
}
void print(double f) {
				std::cout << "Here is float: " << f << std::endl;
}
void print(char* c) {
				std::cout << "Here is char*: " << c << std::endl;
}</script></code></pre>
					<small>
						W powyÅ¼szym przykÅ‚adzie, funkcja <code>print</code> jest przeciÄ…Å¼ona trzy razy: raz dla
						argumentu typu int, raz
						dla argumentu typu double i raz dla argumentu typu char*. Kompilator wybierze odpowiedniÄ…
						funkcjÄ™ do wywoÅ‚ania
						na podstawie typu argumentu uÅ¼ytego podczas wywoÅ‚ania. DziÄ™ki temu, metoda moÅ¼e byÄ‡ wywoÅ‚ana w
						rÃ³Å¼ny sposÃ³b w zaleÅ¼noÅ›ci od kontekstu, co zwiÄ™ksza elastycznoÅ›Ä‡ i czytelnoÅ›Ä‡
						kodu.
					</small>
				</section>

				<section data-auto-animate>
					<h3>PrzeciÄ…Å¼anie funkcji a programowanie obiektowe</h3>
					<small>
						PrzeciÄ…Å¼anie funkcji jest kluczowym elementem programowania obiektowego. Pozwala na definiowanie
						wielu metod o
						tej samej nazwie w obrÄ™bie jednej klasy, ktÃ³re rÃ³Å¼niÄ… siÄ™ typami i/lub liczbÄ… argumentÃ³w. DziÄ™ki
						temu, metoda
						moÅ¼e byÄ‡ wywoÅ‚ana w rÃ³Å¼ny sposÃ³b w zaleÅ¼noÅ›ci od kontekstu, co zwiÄ™ksza elastycznoÅ›Ä‡ i
						czytelnoÅ›Ä‡ kodu.
					</small>
				</section>
			</section>
            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">PO/lab3-figures-v1</h2>
                    <a href="https://classroom.github.com/a/kyzvEaHt">LINK</a>

                </section>
            </section>
            			<section data-background-gradient="linear-gradient(175deg, #009b72, #43447b)">

				<section>
					<h2>Polimorfizm</h2>
					<h3>Dziedziczenie</h3>
				</section>

				<section data-auto-animate>
					<h3>Dziedziczenie w programowaniu obiektowym</h3>
					<small>
						Dziedziczenie w programowaniu obiektowym to jeden z fundamentÃ³w tej paradygmatu programowania.
						Pozwala ono na tworzenie
						nowych klas na podstawie istniejÄ…cych klas. Nowa klasa, zwana klasÄ… pochodnÄ…, dziedziczy
						atrybuty i metody klasy bazowej, co
						pozwala na ponowne uÅ¼ycie kodu.
					</small>
					<pre style="font-size: 16px;">PrzykÅ‚ad dziedziczenia w C++<code><script type="text/template">// Klasa bazowa
class Animal {
public:
		void eat() {
				std::cout << "I can eat!" << std::endl;
		}
};

// Klasa pochodna
class Dog : public Animal {
public:
		void bark() {
				std::cout << "I can bark! Woof Woof!" << std::endl;
		}
};</script></code></pre>
					<small>
						W powyÅ¼szym przykÅ‚adzie, klasa <code>Dog</code> dziedziczy od klasy <code>Animal</code>. Oznacza
						to, Å¼e obiekt
						klasy <code>Dog</code> moÅ¼e uÅ¼ywaÄ‡ metody <code>eat()</code> zdefiniowanej w klasie
						<code>Animal</code>, a takÅ¼e
						metody <code>bark()</code> zdefiniowanej w samej klasie <code>Dog</code>.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Dziedziczenie w programowaniu obiektowym</h3>
					<pre>UÅ¼ycie klasy Dog w main.cpp<code class="hljs cpp" ><script type="text/template">// main.cpp
int main() {
		Animal myAnimal;
		myAnimal.eat();
		//myAnimal.bark(); // BÅ‚Ä…d kompilacji
		Dog myDog;
		myDog.eat();
		myDog.bark();
		return 0;
}</script></code></pre>
					<small>
						W powyÅ¼szym przykÅ‚adzie, tworzymy obiekt klasy <code>Dog</code> i <code>Animal</code> i
						wywoÅ‚ujemy metody <code>eat()</code> i
						<code>bark()</code>. Metoda <code>eat()</code> jest dziedziczona z klasy <code>Animal</code>, a
						metoda
						<code>bark()</code> jest zdefiniowana w klasie <code>Dog</code>. Obiekt klasy
						<code>Animal</code> nie posiada metody <code>bark()</code>,
					</small>

				</section>
				<section data-auto-animate>
					<h3>Poziomy dostÄ™pu do dziedziczenia w C++</h3>
					<ul>
						<li>
							<small>
								<strong>Public:</strong> JeÅ›li klasa jest dziedziczona publicznie, to publiczne i
								chronione czÅ‚onki
								klasy bazowej stajÄ… siÄ™ odpowiednio publicznymi i chronionymi czÅ‚onkami klasy pochodnej.
							</small>
						</li>
						<li>
							<small>
								<strong>Protected:</strong> JeÅ›li klasa jest dziedziczona chronionie, to publiczne i
								chronione czÅ‚onki
								klasy bazowej stajÄ… siÄ™ chronionymi czÅ‚onkami klasy pochodnej.
							</small>
						</li>
						<li>
							<small>
								<strong>Private:</strong> JeÅ›li klasa jest dziedziczona prywatnie, to publiczne i
								chronione czÅ‚onki
								klasy bazowej stajÄ… siÄ™ prywatnymi czÅ‚onkami klasy pochodnej.
							</small>
						</li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Metody wirtualne w C++</h3>
					<small>
						Metoda wirtualna to funkcja czÅ‚onkowska klasy, ktÃ³rÄ… deklaruje siÄ™ za pomocÄ… sÅ‚owa kluczowego
						<code>virtual</code> w klasie bazowej. Pozwala to na "przesÅ‚anianie" metody w klasie pochodnej.
						Gdy metoda
						wirtualna jest wywoÅ‚ywana przez wskaÅºnik lub referencjÄ™ do klasÄ™ bazowÄ…, wywoÅ‚anie jest
						rozstrzygane w czasie
						wykonywania, a nie w czasie kompilacji. To oznacza, Å¼e wywoÅ‚ana zostanie metoda zdefiniowana w
						klasie typu
						obiektu, a nie typu wskaÅºnika lub referencji.
					</small>


					<pre style="font-size: 16px;">PrzykÅ‚ad metody wirtualnej w C++<code><script type="text/template">// Klasa bazowa
class Base {
public:
		virtual void print() {
				cout << "WywoÅ‚anie metody print() klasy bazowej" << endl;
		}
};

// Klasa pochodna
class Derived : public Base {
public:
		// PrzesÅ‚oniÄ™cie metody print()
		void print() override {
				cout << "WywoÅ‚anie metody print() klasy pochodnej" << endl;
		}
};</script></code></pre>
				</section>


				<section data-auto-animate>
					<h3>Metody abstrakcyjne w C++</h3>
					<small>
						Metoda abstrakcyjna to metoda wirtualna, ktÃ³ra jest zadeklarowana, ale nie zdefiniowana w klasie
						bazowej.
						Deklaruje siÄ™ jÄ…, ustawiajÄ…c jej definicjÄ™ na 0 (np. <code>virtual void myMethod() = 0;</code>).
						Klasa, ktÃ³ra
						zawiera co najmniej jednÄ… metodÄ™ abstrakcyjnÄ…, jest nazywana klasÄ… abstrakcyjnÄ…. Klasy
						abstrakcyjne nie mogÄ… byÄ‡
						instancjonowane - sÅ‚uÅ¼Ä… jako bazy dla klas pochodnych, ktÃ³re muszÄ… zaimplementowaÄ‡ wszystkie
						metody
						abstrakcyjne.
					</small>


					<pre style="font-size: 16px;">PrzykÅ‚ad metody abstrakcyjnej w C++<code><script type="text/template">// Klasa bazowa (abstrakcyjna)
class Base {
public:
		virtual void print() = 0; // Metoda abstrakcyjna
};

// Klasa pochodna
class Derived : public Base {
public:
		// Implementacja metody abstrakcyjnej
		void print() override {
				cout << "WywoÅ‚anie metody print() klasy pochodnej" << endl;
		}
};</script></code></pre>
				</section>

				<section data-auto-animate>
					<h3>PrzesÅ‚anianie metod bez uÅ¼ycia sÅ‚owa kluczowego 'virtual' w C++</h3>
					<small>
						JeÅ›li metoda zostanie przysÅ‚oniÄ™ta bez uÅ¼ycia sÅ‚owa kluczowego <code>virtual</code>, to
						zachowanie bÄ™dzie
						zaleÅ¼aÅ‚o od typu
						referencji lub wskaÅºnika, ktÃ³rym wywoÅ‚ywania jest metoda, a nie od rzeczywistego typu obiektu.
						To jest
						znane jako
						"statyczne wiÄ…zanie" lub "wiÄ…zanie w czasie kompilacji".
					</small>
					<pre style="font-size: 15px;">PrzykÅ‚ad <code><script type="text/template">// Klasa bazowa
class Base {
public:
		void print() {
				cout << "WywoÅ‚anie metody print() klasy bazowej" << endl;
		}
};

// Klasa pochodna
class Derived : public Base {
public:
		void print() {
				cout << "WywoÅ‚anie metody print() klasy pochodnej" << endl;
		}
};

int main() {
		Derived d;
		Base& b = d;
		b.print();  // WywoÅ‚a metodÄ™ print() klasy bazowej, nie pochodnej
		return 0;
}</script></code></pre>
					<small>
						W powyÅ¼szym przykÅ‚adzie, mimo Å¼e <code>b</code> jest referencjÄ… do obiektu klasy
						<code>Derived</code>, wywoÅ‚anie
						<code>b.print()</code> wywoÅ‚a metodÄ™ <code>print()</code> klasy <code>Base</code>, poniewaÅ¼
						metoda
						<code>print()</code> nie jest wirtualna.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Rodzaje Dziedziczenia w Programowaniu Obiektowym</h3>
					<small>
						Dziedziczenie w programowaniu obiektowym umoÅ¼liwia tworzenie nowych klas na podstawie
						istniejÄ…cych klas, co
						uÅ‚atwia ponowne uÅ¼ycie kodu, zwiÄ™ksza czytelnoÅ›Ä‡ i uÅ‚atwia zarzÄ…dzanie kodem.
						<ul>
							<li><strong>Dziedziczenie jednokrotne (single inheritance):</strong> Klasa podrzÄ™dna
								dziedziczy od jednej
								klasy nadrzÄ™dnej.</li>
							<li><strong>Dziedziczenie wielokrotne (multiple inheritance):</strong> Klasa podrzÄ™dna
								dziedziczy
								jednoczeÅ›nie od dwÃ³ch lub wiÄ™cej klas nadrzÄ™dnych.</li>
							<li><strong>Dziedziczenie wielostopniowe (multilevel inheritance):</strong> Jedna klasa
								dziedziczy od innej,
								a nastÄ™pnie inna klasa dziedziczy z powyÅ¼szej klasy, tworzÄ…c hierarchiÄ™ klasy.</li>
							<li><strong>Dziedziczenie wielopoziomowe (hierarchical inheritance):</strong> Jedna klasa
								nadrzÄ™dna, wiele
								klas podrzÄ™dnych. Klasy podrzÄ™dne mogÄ… dziedziczyÄ‡ od jednej wspÃ³lnej klasy nadrzÄ™dnej.
							</li>
							<li><strong>Dziedziczenie interfejsÃ³w (interface inheritance):</strong> Klasy mogÄ…
								dziedziczyÄ‡ jedynie
								sygnatury metod, nie ich implementacje. Jest to podobne do klas abstrakcyjnych w C++.
							</li>
						</ul>
					</small>
				</section>

				<section data-auto-animate>
					<h3>Polimorfizm w programowaniu obiektowym</h3>
					<small>
						Polimorfizm to kluczowy koncept w programowaniu obiektowym, ktÃ³ry pozwala obiektom rÃ³Å¼nych klas
						dziaÅ‚aÄ‡ jak
						obiekty innej klasy. Jest to moÅ¼liwe dziÄ™ki uÅ¼yciu dziedziczenia i metod wirtualnych.
					</small>
					<ul>
						<li>
							<small>
								<b>Polimorfizm statyczny (wczesne wiÄ…zanie):</b> Typ obiektu jest okreÅ›lany podczas
								kompilacji.
								PrzykÅ‚adem moÅ¼e byÄ‡ przeciÄ…Å¼anie funkcji.
							</small>
						</li>
						<li>
							<small>
								<b>Polimorfizm dynamiczny (pÃ³Åºne wiÄ…zanie):</b> Typ obiektu jest okreÅ›lany w czasie
								wykonywania.
								PrzykÅ‚adem moÅ¼e byÄ‡ przesÅ‚anianie funkcji.
							</small>
						</li>
					</ul>
					<small>
						Polimorfizm jest waÅ¼ny, poniewaÅ¼ pozwala na tworzenie bardziej elastycznego i Å‚atwiejszego do
						zarzÄ…dzania kodu,
						umoÅ¼liwiajÄ…c programistom traktowanie obiektÃ³w rÃ³Å¼nych klas w ten sam sposÃ³b.
					</small>
				</section>
			</section>
            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">PO/lab4-figures-v2</h2>
                    <a href="https://classroom.github.com/a/vZeS1y5y">LINK</a>

                </section>
            </section>

        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
        });
    </script>

</body>

</html>