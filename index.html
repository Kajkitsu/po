<!doctype html>
<html lang="pl">

<head>
    <meta charset="utf-8">
    <title>Programowanie Obiektowe - Nowa Wersja</title>
    <meta name="description" content="PO LAB">
    <meta name="author" content="Norbert Waszkowiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .row {
            display: flex;
        }

        .column {
            flex: 50%;
            padding: 10px;
        }

        .small-font pre {
            font-size: 13px;
            margin-left: 0;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <section data-background-gradient="linear-gradient(45deg, #2c3e50, #3498db)">

                <!-- 1. Slajd powitalny -->
                <section style="text-align: left;">
                    <h1>Programowanie Obiektowe</h1>

                    <div style="margin-top: 40px;">
                        <p><strong>ProwadzÄ…cy:</strong> por. mgr inÅ¼. Norbert Waszkowiak</p>

                        <div style="margin-top: 30px; font-size: 0.6em;">
                            <p>ğŸ“ <strong>Tel:</strong> 261 839 060</p>
                            <p>ğŸ“§ <strong>Email:</strong> norbert.waszkowiak@wat.edu.pl</p>
                            <p>ğŸ¢ <strong>PokÃ³j:</strong> bud. 100, pok. 254B</p>
                            <p>ğŸ’¬ <strong>Konsultacje:</strong> po wczeÅ›niejszym umÃ³wieniu (online/stacjonarnie)</p>
                        </div>
                    </div>

                </section>
            </section>

            <!-- 2. Historia programowania -->
            <section data-background-gradient="linear-gradient(37deg, #1e3c72, #2a5298)">

                <!-- Slajd tytuÅ‚owy -->
                <section>
                    <h2>Historia programowania</h2>
                    <h3>Programowanie proceduralne vs obiektowe</h3>
                    <aside class="notes">
                        Programowanie obiektowe nie powstaÅ‚o przypadkowo ani jako abstrakcyjna teoria akademicka.
                        Jest odpowiedziÄ… na konkretne problemy inÅ¼ynierskie, ktÃ³re wystÄ…piÅ‚y w praktyce
                        tworzenia oprogramowania w latach 60. i 70. XX wieku.

                        W tej czÄ™Å›ci wykÅ‚adu omÃ³wimy ewolucjÄ™ paradygmatÃ³w programowania oraz przyczyny,
                        dla ktÃ³rych programowanie obiektowe staÅ‚o siÄ™ dominujÄ…cym podejÅ›ciem w inÅ¼ynierii
                        oprogramowania.
                        Analiza historyczna pozwoli zrozumieÄ‡, Å¼e OOP jest narzÄ™dziem rozwiÄ…zujÄ…cym realne problemy,
                        a nie jedynie teoretycznÄ… koncepcjÄ….
                    </aside>
                </section>

                <!-- Programowanie proceduralne -->
                <section>
                    <h3>Programowanie proceduralne</h3>
                    <p><strong>Lata 50-60. XX wieku</strong></p>
                    <ul>
                        <li>Program = lista instrukcji wykonywanych kolejno</li>
                        <li>Dane oddzielone od funkcji</li>
                        <li>PrzykÅ‚ady: Fortran, COBOL, C</li>
                    </ul>
                    <pre style="font-size: 16px; margin-top: 30px;"><code class="hljs c" data-trim>
int suma = 0;
for(int i = 0; i < 10; i++) {
    suma += i;
}
printf("Suma: %d", suma);
                    </code></pre>
                    <aside class="notes">
                        Programowanie proceduralne charakteryzuje siÄ™ sekwencyjnym wykonywaniem instrukcji.
                        Program skÅ‚ada siÄ™ ze zmiennych przechowujÄ…cych dane oraz procedur (funkcji) operujÄ…cych na tych
                        danych.
                        KluczowÄ… cechÄ… tego paradygmatu jest separacja danych od logiki przetwarzania.

                        JÄ™zyki takie jak Fortran (1957) sÅ‚uÅ¼yÅ‚y obliczeniom naukowym, COBOL (1959)
                        zastosowaniom biznesowym, a C (1972) programowaniu systemowemu. Wszystkie opieraÅ‚y siÄ™
                        na paradygmacie proceduralnym.

                        PodejÅ›cie to byÅ‚o efektywne dla programÃ³w o ograniczonej zÅ‚oÅ¼onoÅ›ci - rzÄ™du setek linii kodu.
                        Jednak wraz ze wzrostem skali oprogramowania zaczÄ™Å‚y ujawniaÄ‡ siÄ™ fundamentalne problemy tego
                        modelu.
                    </aside>
                </section>

                <!-- Problem -->
                <section>
                    <h3>Problem: chaos w duÅ¼ych programach</h3>
                    <ul>
                        <li>ğŸ“ˆ TysiÄ…ce linii w jednym pliku</li>
                        <li>ğŸ”„ Zmienne globalne - kto je zmienia?</li>
                        <li>ğŸ› BÅ‚Ä…d w jednym miejscu = awaria caÅ‚oÅ›ci</li>
                        <li>ğŸ‘¥ WspÃ³Å‚praca w zespole? Koszmar!</li>
                        <li>â™»ï¸ Ponowne uÅ¼ycie kodu? NiemoÅ¼liwe</li>
                    </ul>
                    <p style="margin-top: 40px; color: #ffd93d;">
                        <em>"Spaghetti code"</em> - wszystko ze wszystkim poplÄ…tane
                    </p>
                    <aside class="notes">
                        W latach 70. XX wieku skala oprogramowania osiÄ…gnÄ™Å‚a dziesiÄ…tki i setki tysiÄ™cy linii kodu.
                        Systemy bankowe, systemy kontroli lotÃ³w, wczesne systemy operacyjne - wszystkie ujawniÅ‚y
                        fundamentalne ograniczenia podejÅ›cia proceduralnego.

                        Zmienne globalne tworzyÅ‚y problem identyfikacji odpowiedzialnoÅ›ci. W programie liczÄ…cym
                        50 tysiÄ™cy linii kodu, zmienna globalna "saldo_konta" mogÅ‚a byÄ‡ modyfikowana przez dziesiÄ…tki
                        funkcji. Wykrycie ÅºrÃ³dÅ‚a nieprawidÅ‚owej wartoÅ›ci wymagaÅ‚o analizy caÅ‚ej bazy kodu.

                        Silne sprzÄ™Å¼enie miÄ™dzy komponentami oznaczaÅ‚o, Å¼e bÅ‚Ä…d w jednej funkcji mÃ³gÅ‚ propagowaÄ‡ siÄ™
                        na pozornie niepowiÄ…zane obszary systemu. Funkcje operowaÅ‚y na tych samych globalnych
                        strukturach danych.

                        Praca zespoÅ‚owa byÅ‚a utrudniona - wielu programistÃ³w modyfikowaÅ‚o te same globalne zasoby,
                        co prowadziÅ‚o do konfliktÃ³w i bÅ‚Ä™dÃ³w integracyjnych.

                        Ponowne wykorzystanie kodu byÅ‚o praktycznie niemoÅ¼liwe. Funkcje byÅ‚y Å›ciÅ›le zwiÄ…zane
                        z globalnymi zmiennymi konkretnego projektu, co uniemoÅ¼liwiaÅ‚o ich przeniesienie.

                        Termin "spaghetti code" opisuje tÄ™ sytuacjÄ™ - kod tak splÄ…tany, Å¼e modyfikacja
                        jednego elementu wpÅ‚ywa nieprzewidywalnie na caÅ‚y system.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie -->
                <section>
                    <h3>Potrzeba nowego podejÅ›cia</h3>
                    <p style="font-size: 0.9em;">Analiza problemÃ³w programowania proceduralnego prowadzi do fundamentalnej obserwacji:</p>
                    <div style="margin-top: 30px; padding: 20px; background: rgba(52, 152, 219, 0.1); border-radius: 10px;">
                        <p style="font-size: 0.95em;">
                            <strong>Dane i operacje na nich sÄ… naturalnie powiÄ…zane!</strong>
                        </p>
                    </div>
                    <aside class="notes">
                        Analiza problemÃ³w programowania proceduralnego doprowadziÅ‚a do fundamentalnej obserwacji:
                        dane i operacje na nich sÄ… naturalnie powiÄ…zane. 
                        
                        W kolejnych slajdach zobaczymy konkretne przykÅ‚ady tego problemu i jego rozwiÄ…zania.
                    </aside>
                </section>

                <!-- PrzykÅ‚ad: Konto bankowe - problem proceduralny -->
                <section>
                    <h3>Problem: Dane oddzielone od operacji</h3>
                    <p style="font-size: 0.85em;">Konto bankowe w podejÅ›ciu proceduralnym:</p>
                    <pre style="font-size: 14px;"><code class="hljs c" data-trim>
// Dane
int saldo = 1000;
char* wlasciciel = "Jan Kowalski";

// Operacje (gdzieÅ› indziej w kodzie)
void wplac(int kwota) {
    saldo += kwota;
}

void wyplac(int kwota) {
    saldo -= kwota;
}

int sprawdz_saldo() {
    return saldo;
}
                    </code></pre>
                    <p style="font-size: 0.8em; color: #ff6b6b; margin-top: 20px;">
                        âŒ Zmienna <code>saldo</code> istnieje oddzielnie od funkcji <code>wpÅ‚aÄ‡</code> i <code>wypÅ‚aÄ‡</code>
                    </p>
                    <aside class="notes">
                        Konto bankowe zawiera saldo oraz operacje wpÅ‚aty, wypÅ‚aty i sprawdzenia stanu. 
                        Logicznie stanowiÄ… one jednÄ… caÅ‚oÅ›Ä‡.

                        Jednak programowanie proceduralne separuje te elementy - zmienna "saldo" istnieje 
                        oddzielnie od funkcji "wpÅ‚aÄ‡" i "wypÅ‚aÄ‡". 
                        
                        To prowadzi do pytania: dlaczego kod nie odzwierciedla naturalnej struktury problemu?
                    </aside>
                </section>

                <!-- Naturalne grupowanie -->
                <section>
                    <h3>Naturalne grupowanie danych i operacji</h3>
                    <div class="row" style="margin-top: 30px;">
                        <div class="column">
                            <h4 style="color: #ff6b6b; font-size: 0.9em;">âŒ Proceduralnie</h4>
                            <pre style="font-size: 12px;"><code class="hljs c" data-trim>
// Dane
int saldo;
char* wlasciciel;

// Funkcje (oddzielnie)
void wplac(int kwota);
void wyplac(int kwota);
int sprawdz_saldo();
                            </code></pre>
                            <p style="font-size: 0.75em;">Separacja danych i logiki</p>
                        </div>
                        <div class="column">
                            <h4 style="color: #51cf66; font-size: 0.9em;">âœ“ Obiektowo</h4>
                            <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class Konto {
    // Dane + Metody razem
    int saldo;
    string wlasciciel;
    
    void wplac(int kwota);
    void wyplac(int kwota);
    int sprawdz_saldo();
};
                            </code></pre>
                            <p style="font-size: 0.75em;">Dane i logika w jednej encji</p>
                        </div>
                    </div>
                    <aside class="notes">
                        Koncepcja grupowania danych z operacjami to fundament programowania obiektowego.
                        Zamiast separacji, otrzymujemy encjÄ™ "Konto", ktÃ³ra zawiera zarÃ³wno dane (saldo, wÅ‚aÅ›ciciel),
                        jak i metody (wpÅ‚aÄ‡, wypÅ‚aÄ‡, sprawdÅº saldo).

                        To jest istota OOP - dane i zachowania razem tworzÄ… spÃ³jnÄ… caÅ‚oÅ›Ä‡.
                    </aside>
                </section>

                <!-- Problem: Brak kontroli dostÄ™pu -->
                <section>
                    <h3>Problem: Brak kontroli dostÄ™pu</h3>
                    <pre style="font-size: 14px;"><code class="hljs c" data-trim>
int saldo = 1000;

void wyplac(int kwota) {
    saldo -= kwota;  // Brak walidacji!
}

// W innym miejscu programu:
saldo = -1000000;  // KaÅ¼dy moÅ¼e to zrobiÄ‡!
wyplac(5000);      // Saldo teraz: -1005000
                    </code></pre>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b;">
                        <p style="font-size: 0.85em;">
                            <strong>Problem:</strong> BezpoÅ›rednia modyfikacja <code>saldo = -1000000</code> jest moÅ¼liwa!
                        </p>
                    </div>
                    <aside class="notes">
                        W podejÅ›ciu proceduralnym kaÅ¼da zmienna globalna moÅ¼e byÄ‡ modyfikowana przez dowolny fragment kodu.
                        BezpoÅ›rednie przypisanie "saldo = -1000000" jest poprawne skÅ‚adniowo.
                        
                        Kompilator akceptuje taki kod. Program kompiluje siÄ™ i uruchamia. BÅ‚Ä…d manifestuje
                        siÄ™ w runtime, potencjalnie po dÅ‚uÅ¼szym okresie dziaÅ‚ania systemu.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie: Enkapsulacja -->
                <section>
                    <h3>RozwiÄ…zanie: Enkapsulacja</h3>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
class Konto {
private:
    int saldo;  // Chronione!
    
public:
    void wplac(int kwota) {
        if (kwota > 0)  // Walidacja
            saldo += kwota;
    }
    
    void wyplac(int kwota) {
        if (kwota > 0 && kwota <= saldo)  // Walidacja
            saldo -= kwota;
    }
};

// Konto k;
// k.saldo = -1000000;  // BÅÄ„D KOMPILACJI!
                    </code></pre>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                        <p style="font-size: 0.85em;">
                            âœ… <strong>Kontrola dostÄ™pu:</strong> tylko metody mogÄ… zmieniaÄ‡ dane
                        </p>
                    </div>
                    <aside class="notes">
                        Konieczna byÅ‚a kontrola dostÄ™pu do danych. BezpoÅ›rednia modyfikacja "saldo = -1000" 
                        powinna byÄ‡ niemoÅ¼liwa. Tylko odpowiednie metody, zawierajÄ…ce logikÄ™ walidacji, 
                        powinny mieÄ‡ prawo zmiany stanu.
                        
                        To jest istota enkapsulacji - ukrywania danych i kontrolowania dostÄ™pu poprzez 
                        zdefiniowany interfejs.
                        
                        Pole saldo jest prywatne. PrÃ³ba bezpoÅ›redniej modyfikacji k.saldo=-1000000 
                        jest bÅ‚Ä™dem kompilacji. Kompilator zgÅ‚osi bÅ‚Ä…d przed uruchomieniem programu.
                    </aside>
                </section>

                <!-- RozwiÄ…zanie: RozszerzalnoÅ›Ä‡ -->
                <section>
                    <h3>RozwiÄ…zanie: RozszerzalnoÅ›Ä‡</h3>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
class Konto {
protected:
    int saldo;
public:
    void wplac(int kwota) { /* ... */ }
    void wyplac(int kwota) { /* ... */ }
};

// Rozszerzenie bez przepisywania!
class KontoOszczednosciowe : public Konto {
private:
    float oprocentowanie;
public:
    void nalicz_odsetki() {
        saldo += saldo * oprocentowanie;
    }
};
                    </code></pre>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                        <p style="font-size: 0.85em;">
                            âœ… <strong>Dziedziczenie:</strong> rozszerzamy bez duplikacji kodu
                        </p>
                    </div>
                    <aside class="notes">
                        Potrzebna byÅ‚a moÅ¼liwoÅ›Ä‡ rozszerzania funkcjonalnoÅ›ci bez przepisywania kodu.
                        Mechanizm dziedziczenia pozwala na stworzenie KontoOszczÄ™dnoÅ›ciowego rozszerzajÄ…cego
                        Konto, bez koniecznoÅ›ci duplikacji kodu bazowego.
                        
                        KontoOszczÄ™dnoÅ›ciowe automatycznie otrzymuje metody wpÅ‚aÄ‡ i wypÅ‚aÄ‡ z klasy bazowej,
                        dodajÄ…c tylko nowÄ… funkcjonalnoÅ›Ä‡ - naliczanie odsetek.
                    </aside>
                </section>

                <!-- Podsumowanie potrzeby OOP -->
                <section>
                    <h3>Czego potrzebowaliÅ›my?</h3>
                    <div class="row" style="margin-top: 40px;">
                        <div class="column">
                            <h4 style="color: #ff6b6b;">âŒ Problem</h4>
                            <ul style="font-size: 0.8em;">
                                <li>Dane osobno od funkcji</li>
                                <li>Wszystko globalne</li>
                                <li>Brak ochrony</li>
                                <li>Trudno skalowaÄ‡</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h4 style="color: #51cf66;">âœ“ RozwiÄ…zanie OOP</h4>
                            <ul style="font-size: 0.8em;">
                                <li>Dane + funkcje razem</li>
                                <li>Kontrolowany dostÄ™p</li>
                                <li>Ukryte szczegÃ³Å‚y (enkapsulacja)</li>
                                <li>Åatwe rozszerzanie (dziedziczenie)</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Te obserwacje - grupowanie danych z metodami, kontrola dostÄ™pu przez enkapsulacjÄ™,
                        rozszerzalnoÅ›Ä‡ przez dziedziczenie - doprowadziÅ‚y do powstania koncepcji 
                        programowania obiektowego.
                        
                        W nastÄ™pnych slajdach zobaczymy jak te idee zostaÅ‚y zrealizowane w pierwszych
                        jÄ™zykach obiektowych.
                    </aside>
                </section>

                <!-- Simula -->
                <section>
                    <h3>1967: Simula</h3>
                    <p><strong>Ole-Johan Dahl i Kristen Nygaard (Norwegia)</strong></p>
                    <ul>
                        <li>Symulacje (kolejki, procesy)</li>
                        <li>Wprowadzili: <strong>klasy i obiekty</strong></li>
                        <li>Pierwszy jÄ™zyk obiektowy</li>
                    </ul>
                    <aside class="notes">
                        Rok 1967, Norwegian Computing Center w Oslo. Ole-Johan Dahl i Kristen Nygaard
                        pracujÄ… nad jÄ™zykiem do symulacji dyskretnych zdarzeÅ„ - kolejek w systemach obsÅ‚ugi,
                        procesÃ³w produkcyjnych, ruchu w portach.

                        W kolejnych slajdach zobaczymy jak fundamentalna obserwacja doprowadziÅ‚a do stworzenia
                        koncepcji klas i obiektÃ³w.
                    </aside>
                </section>

                <!-- Simula: Problem symulacji -->
                <section>
                    <h3>Simula: Symulacja sklepu</h3>
                    <p style="font-size: 0.85em;">Naturalne byty w symulacji:</p>
                    <div style="text-align: left; margin: 20px; font-size: 0.8em;">
                        <div style="margin: 15px 0; padding: 12px; background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db;">
                            <strong>ğŸ‘¤ Klient:</strong> imiÄ™, wiek, koszyk zakupÃ³w<br>
                            <em>Zachowania:</em> czeka w kolejce, wybiera produkty, pÅ‚aci
                        </div>
                        <div style="margin: 15px 0; padding: 12px; background: rgba(46, 204, 113, 0.1); border-left: 3px solid #2ecc71;">
                            <strong>ğŸ’¼ Kasjer:</strong> stanowisko, szybkoÅ›Ä‡ obsÅ‚ugi<br>
                            <em>Zachowania:</em> obsÅ‚uguje klienta, skanuje produkty, wydaje resztÄ™
                        </div>
                        <div style="margin: 15px 0; padding: 12px; background: rgba(155, 89, 182, 0.1); border-left: 3px solid #9b59b6;">
                            <strong>ğŸ“¦ Produkt:</strong> nazwa, cena, kod<br>
                            <em>Zachowania:</em> wyÅ›wietl informacje, oblicz rabat
                        </div>
                    </div>
                    <aside class="notes">
                        Podczas projektowania jÄ™zyka symulacji zauwaÅ¼yli fundamentalnÄ… wÅ‚aÅ›ciwoÅ›Ä‡:
                        symulowane systemy skÅ‚adajÄ… siÄ™ z bytÃ³w, z ktÃ³rych kaÅ¼dy posiada wÅ‚asny stan
                        (dane) oraz zachowanie (operacje).

                        W symulacji sklepu naturalnymi bytami sÄ…: klienci posiadajÄ…cy imiÄ™, wiek, koszyk zakupÃ³w;
                        kasjerzy majÄ…cy stanowisko i szybkoÅ›Ä‡ obsÅ‚ugi; produkty charakteryzujÄ…ce siÄ™ nazwÄ…, cenÄ… i kodem.

                        KaÅ¼dy byt posiada nie tylko dane, ale rÃ³wnieÅ¼ zachowania: klient czeka w kolejce,
                        wybiera produkty, pÅ‚aci; kasjer obsÅ‚uguje klienta, skanuje produkty, wydaje resztÄ™.
                    </aside>
                </section>

                <!-- Simula: Klasa jako szablon -->
                <section>
                    <h3>Simula: Klasa jako szablon</h3>
                    <pre style="font-size: 13px;"><code class="hljs" data-trim>
! Klasa w Simula
CLASS Klient;
BEGIN
    TEXT imie;
    INTEGER wiek;
    REF(Koszyk) koszyk;
    
    PROCEDURE czekaj_w_kolejce;
    BEGIN
        ! kod czekania
    END;
    
    PROCEDURE plac;
    BEGIN
        ! kod pÅ‚acenia
    END;
END Klient;
                    </code></pre>
                    <p style="font-size: 0.8em; margin-top: 20px;">
                        ğŸ’¡ <strong>Klasa</strong> = szablon definiujÄ…cy strukturÄ™ i zachowanie
                    </p>
                    <aside class="notes">
                        Ta obserwacja doprowadziÅ‚a do stworzenia jÄ™zyka Simula z fundamentalnymi koncepcjami:
                        klasÄ… jako szablonem definiujÄ…cym strukturÄ™ i zachowanie.

                        Klasa "Klient" definiuje, Å¼e kaÅ¼dy klient posiada imiÄ™, wiek i koszyk.
                        Definiuje rÃ³wnieÅ¼ zachowania (procedury): czekaj_w_kolejce, plac.
                    </aside>
                </section>

                <!-- Simula: Obiekt jako instancja -->
                <section>
                    <h3>Simula: Obiekt jako instancja</h3>
                    <pre style="font-size: 13px;"><code class="hljs" data-trim>
! Tworzenie obiektÃ³w (instancji klasy Klient)
REF(Klient) jan, anna;

jan :- NEW Klient;
jan.imie := "Jan Kowalski";
jan.wiek := 35;

anna :- NEW Klient;
anna.imie := "Anna Nowak";
anna.wiek := 28;

! KaÅ¼dy obiekt ma wÅ‚asne dane
jan.plac;   ! Jan pÅ‚aci
anna.plac;  ! Anna pÅ‚aci
                    </code></pre>
                    <p style="font-size: 0.8em; margin-top: 20px;">
                        ğŸ’¡ <strong>Obiekt</strong> = konkretna instancja klasy z wÅ‚asnymi wartoÅ›ciami
                    </p>
                    <aside class="notes">
                        Obiekt jako konkretnÄ… instancjÄ… klasy. Klasa "Klient" definiuje, Å¼e kaÅ¼dy klient 
                        posiada imiÄ™, wiek i koszyk. 
                        
                        Obiekt "Jan Kowalski" jest konkretnÄ… instancjÄ… z wartoÅ›ciami: imiÄ™="Jan", wiek=35, 
                        koszyk=[mleko, chleb].

                        KaÅ¼dy obiekt ma wÅ‚asne wartoÅ›ci, ale wspÃ³lnÄ… strukturÄ™ i zachowania zdefiniowane w klasie.
                    </aside>
                </section>

                <!-- Simula: Dziedziczenie -->
                <section>
                    <h3>Simula: Dziedziczenie</h3>
                    <pre style="font-size: 12px;"><code class="hljs" data-trim>
! Klasa bazowa
CLASS Osoba;
BEGIN
    TEXT imie;
    INTEGER wiek;
    
    PROCEDURE przedstaw_sie;
    BEGIN
        OutText("Nazywam siÄ™ ");
        OutText(imie);
    END;
END Osoba;

! Klasa pochodna (dziedziczy po Osoba)
Osoba CLASS Klient;  ! Klient rozszerza Osoba
BEGIN
    REF(Koszyk) koszyk;
    
    PROCEDURE rob_zakupy;
    BEGIN
        ! kod zakupÃ³w
    END;
END Klient;
                    </code></pre>
                    <aside class="notes">
                        Simula wprowadziÅ‚a rÃ³wnieÅ¼ koncepcjÄ™ dziedziczenia - moÅ¼liwoÅ›ci tworzenia
                        specjalizowanych klas na bazie klas ogÃ³lnych.

                        Klient dziedziczy po Osoba, otrzymujÄ…c automatycznie pola (imie, wiek) i metody
                        (przedstaw_sie), dodajÄ…c wÅ‚asne rozszerzenia (koszyk, rob_zakupy).
                    </aside>
                </section>

                <!-- Simula: WpÅ‚yw -->
                <section>
                    <h3>Simula: WpÅ‚yw na przyszÅ‚oÅ›Ä‡</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>Koncepcje wprowadzone przez Simula:</strong>
                            <ul style="font-size: 0.85em; margin-top: 10px;">
                                <li>âœ… Klasa jako szablon</li>
                                <li>âœ… Obiekt jako instancja</li>
                                <li>âœ… Dziedziczenie</li>
                                <li>âœ… Polimorfizm (wirtualne procedury)</li>
                            </ul>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>WpÅ‚ynÄ™Å‚a na:</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                C++, Java, Python, C#, JavaScript...
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Mimo Å¼e Simula nie osiÄ…gnÄ™Å‚a szerokiego zastosowania komercyjnego, jej koncepcje
                        staÅ‚y siÄ™ fundamentem wszystkich wspÃ³Å‚czesnych jÄ™zykÃ³w obiektowych: C++, Java, Python, C#.
                        
                        KluczowÄ… ideÄ… jest grupowanie danych z zachowaniami w spÃ³jne encje - klasy i obiekty.
                    </aside>
                </section>

                <!-- Smalltalk -->
                <section>
                    <h3>1972: Smalltalk</h3>
                    <p><strong>Alan Kay (Xerox PARC)</strong></p>
                    <ul>
                        <li>WSZYSTKO jest obiektem (nawet liczby!)</li>
                        <li>Pierwsze GUI (okienka, mysz)</li>
                        <li>UkuÅ‚ termin "programowanie obiektowe"</li>
                    </ul>
                    <aside class="notes">
                        Rok 1972, Xerox Palo Alto Research Center. Alan Kay, informatyk i wizjoner,
                        rozwija koncepcjÄ™ programowania obiektowego do jej logicznej konkluzji, tworzÄ…c
                        jÄ™zyk Smalltalk.

                        W kolejnych slajdach zobaczymy rewolucyjne podejÅ›cie Smalltalk.
                    </aside>
                </section>

                <!-- Smalltalk: Wszystko jest obiektem -->
                <section>
                    <h3>Smalltalk: Wszystko jest obiektem</h3>
                    <p style="font-size: 0.85em;">Nawet liczby sÄ… obiektami z metodami!</p>
                    <pre style="font-size: 14px;"><code class="hljs smalltalk" data-trim>
"Liczby jako obiekty"
5 + 3.          "Wynik: 8"
10 - 7.         "Wynik: 3"
4 * 6.          "Wynik: 24"

"To jest tak naprawdÄ™ wywoÅ‚anie metod:"
5 plus: 3.      "Metoda 'plus:' z argumentem 3"
10 minus: 7.    "Metoda 'minus:' z argumentem 7"

"Liczby majÄ… rÃ³Å¼ne metody:"
5 squared.      "Wynik: 25 (podniesienie do kwadratu)"
10 factorial.   "Wynik: 3628800"
7 isPrime.      "Wynik: true (czy pierwsza?)"
                    </code></pre>
                    <p style="font-size: 0.75em; margin-top: 20px; color: #3498db;">
                        ğŸ’¡ W Smalltalk <code>5 + 3</code> to wysÅ‚anie wiadomoÅ›ci <code>+</code> do obiektu <code>5</code> z argumentem <code>3</code>
                    </p>
                    <aside class="notes">
                        Fundamentalna zasada Smalltalk: wszystko jest obiektem. Nawet wartoÅ›ci prymitywne
                        takie jak liczba 5 sÄ… obiektami posiadajÄ…cymi metody. 
                        
                        Liczba 5 posiada metody dodawania, mnoÅ¼enia, konwersji do stringa. W notacji Smalltalk: 
                        5 + 3 to wywoÅ‚anie metody dodawania na obiekcie 5 z argumentem 3. 
                        
                        WspÃ³Å‚czeÅ›nie ten model widzimy w Pythonie, gdzie (5).__add__(3) jest poprawnym wywoÅ‚aniem.
                    </aside>
                </section>

                <!-- Smalltalk: Komunikacja przez wiadomoÅ›ci -->
                <section>
                    <h3>Smalltalk: Komunikacja przez wiadomoÅ›ci</h3>
                    <pre style="font-size: 13px;"><code class="hljs smalltalk" data-trim>
"Definiowanie klasy"
Object subclass: #Konto
    instanceVariableNames: 'saldo wlasciciel'
    
"Definiowanie metod"
Konto >> wplac: kwota
    saldo := saldo + kwota.

Konto >> wyplac: kwota
    (kwota <= saldo)
        ifTrue: [ saldo := saldo - kwota ]
        ifFalse: [ self error: 'NiewystarczajÄ…ce saldo' ].

"Tworzenie obiektu i wysyÅ‚anie wiadomoÅ›ci"
mojeKonto := Konto new.
mojeKonto wplac: 1000.    "WysyÅ‚anie wiadomoÅ›ci 'wplac:' z argumentem 1000"
mojeKonto wyplac: 500.    "WysyÅ‚anie wiadomoÅ›ci 'wyplac:' z argumentem 500"
                    </code></pre>
                    <aside class="notes">
                        Kay wprowadziÅ‚ koncepcjÄ™ komunikacji poprzez wiadomoÅ›ci. Obiekty nie
                        "wywoÅ‚ujÄ… funkcji" - wysyÅ‚ajÄ… wiadomoÅ›ci do innych obiektÃ³w, ktÃ³re decydujÄ…
                        jak na nie odpowiedzieÄ‡. To fundamentalna zmiana paradygmatu.

                        Zamiast "wywoÅ‚aj funkcjÄ™ wplac na koncie", mÃ³wimy "wyÅ›lij wiadomoÅ›Ä‡ wplac: do obiektu konto".
                    </aside>
                </section>

                <!-- Smalltalk: PorÃ³wnanie z innymi jÄ™zykami -->
                <section>
                    <h3>Smalltalk vs inne jÄ™zyki</h3>
                    <div class="row" style="margin-top: 20px;">
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Smalltalk (czyste OOP)</h4>
                            <pre style="font-size: 11px;"><code class="hljs smalltalk" data-trim>
"Wszystko jest obiektem"
5 + 3.
'tekst' size.
true ifTrue: [ 'tak' ].

"Nawet klasy sÄ… obiektami!"
String new.
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Python (inspirowany Smalltalk)</h4>
                            <pre style="font-size: 11px;"><code class="hljs python" data-trim>
# Liczby jako obiekty
(5).__add__(3)
"tekst".upper()

# Klasy teÅ¼ sÄ… obiektami
type(str)  # <class 'type'>
                            </code></pre>
                        </div>
                    </div>
                    <p style="font-size: 0.75em; margin-top: 20px;">
                        ğŸ’¡ WspÃ³Å‚czesne jÄ™zyki jak Python przejÄ™Å‚y filozofiÄ™ Smalltalk
                    </p>
                    <aside class="notes">
                        WspÃ³Å‚czeÅ›nie ten model widzimy w Pythonie, gdzie (5).__add__(3) jest poprawnym wywoÅ‚aniem.
                        Python, podobnie jak Smalltalk, traktuje wszystko jako obiekty, wÅ‚Ä…cznie z klasami.

                        To pokazuje jak daleko siÄ™gajÄ…cy byÅ‚ wpÅ‚yw Smalltalk na rozwÃ³j jÄ™zykÃ³w programowania.
                    </aside>
                </section>

                <!-- Smalltalk: GUI -->
                <section>
                    <h3>Smalltalk: Rewolucja w interfejsach</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>Pierwsze graficzne GUI (1973):</strong>
                            <ul style="font-size: 0.85em; margin-top: 10px;">
                                <li>ğŸ–¼ï¸ Okna (nakÅ‚adajÄ…ce siÄ™)</li>
                                <li>ğŸ–±ï¸ ObsÅ‚uga myszy</li>
                                <li>ğŸ“‹ Menu rozwijane</li>
                                <li>ğŸ¨ Ikony</li>
                            </ul>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>WpÅ‚yw:</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                â†’ Apple Macintosh (1984)<br>
                                â†’ Microsoft Windows (1985)<br>
                                â†’ Wszystkie wspÃ³Å‚czesne GUI
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Smalltalk byÅ‚ rÃ³wnieÅ¼ rewolucyjny technologicznie - Kay stworzyÅ‚ pierwsze
                        graficzne Å›rodowisko uÅ¼ytkownika oparte na oknach, ikonach i myszy. 
                        
                        To rozwiÄ…zanie, zaprezentowane w Xerox PARC, zostaÅ‚o nastÄ™pnie zaadaptowane przez Apple
                        w Macintosh oraz Microsoft w Windows.

                        Bez Smalltalk nie mielibyÅ›my wspÃ³Å‚czesnych interfejsÃ³w graficznych!
                    </aside>
                </section>

                <!-- Smalltalk: Dziedzictwo -->
                <section>
                    <h3>Smalltalk: Dziedzictwo</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>ğŸ’¡ Alan Kay ukuÅ‚ termin:</strong>
                            <p style="margin-top: 10px; font-size: 1.2em; font-weight: bold; color: #2ecc71;">
                                "Object-Oriented Programming"
                            </p>
                            <p style="margin-top: 10px; font-style: italic;">
                                Programowanie Obiektowe
                            </p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>WpÅ‚yw na jÄ™zyki:</strong>
                            <p style="margin-top: 10px;">
                                Ruby (bardzo inspirowany Smalltalk)<br>
                                Python (filozofia "wszystko jest obiektem")<br>
                                JavaScript (prototypy, dynamicznoÅ›Ä‡)<br>
                                Swift (nowoczesna skÅ‚adnia, opcjonalne typy)
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Alan Kay ukuÅ‚ termin "object-oriented programming" - programowanie obiektowe.

                        Mimo Å¼e Smalltalk nie osiÄ…gnÄ…Å‚ dominacji w przemyÅ›le ze wzglÄ™du na wymagania
                        wydajnoÅ›ciowe, jego czysta wizja OOP wpÅ‚ynÄ™Å‚a na projektowanie wszystkich
                        pÃ³Åºniejszych jÄ™zykÃ³w obiektowych. 
                        
                        Zasady formuÅ‚owane przez Kaya pozostajÄ… aktualne 50 lat pÃ³Åºniej.

                        Wiele wspÃ³Å‚czesnych jÄ™zykÃ³w przejÄ™Å‚o filozofiÄ™ Smalltalk - Ruby jest niemal
                        bezpoÅ›rednim spadkobiercÄ…, Python przyjÄ…Å‚ koncepcjÄ™ "wszystko jest obiektem",
                        JavaScript wykorzystaÅ‚ dynamiczne wysyÅ‚anie wiadomoÅ›ci.
                    </aside>
                </section>

                <!-- C++ -->
                <section>
                    <h3>1983: C++</h3>
                    <p><strong>Bjarne Stroustrup</strong></p>
                    <ul>
                        <li>PoÅ‚Ä…czyÅ‚ C (szybki) + OOP (zorganizowany)</li>
                        <li>"C with Classes" â†’ C++</li>
                        <li>ProgramiÅ›ci C mogli stopniowo przejÅ›Ä‡ na OOP</li>
                    </ul>
                    <aside class="notes">
                        Rok 1983, Bell Laboratories. Bjarne Stroustrup, informatyk duÅ„skiego pochodzenia,
                        stoi przed problemem: jak wprowadziÄ‡ koncepcje obiektowe do praktyki przemysÅ‚owej,
                        gdzie dominuje jÄ™zyk C znany z wydajnoÅ›ci i kontroli niskopoziomowej?

                        W kolejnych slajdach zobaczymy jak C++ Å‚Ä…czy Å›wiat C z paradygmatem obiektowym.
                    </aside>
                </section>

                <!-- C++: Problem do rozwiÄ…zania -->
                <section>
                    <h3>C++: Wyzwanie</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>ğŸ¯ Problem:</strong>
                            <p style="margin-top: 10px;">
                                Jak wprowadziÄ‡ OOP do Å›wiata, gdzie dominuje C?
                            </p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>Wymagania:</strong>
                            <ul style="margin-top: 10px;">
                                <li>âœ… ZachowaÄ‡ wydajnoÅ›Ä‡ C</li>
                                <li>âœ… ZachowaÄ‡ kontrolÄ™ niskopoziomowÄ…</li>
                                <li>âœ… DodaÄ‡ moÅ¼liwoÅ›ci organizacyjne OOP</li>
                                <li>âœ… KompatybilnoÅ›Ä‡ z istniejÄ…cym kodem C</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        RozwiÄ…zaniem byÅ‚o stworzenie C++ - jÄ™zyka Å‚Ä…czÄ…cego sprawdzonÄ… efektywnoÅ›Ä‡ C
                        z moÅ¼liwoÅ›ciami organizacyjnymi programowania obiektowego. To byÅ‚ strategiczny
                        kompromis pozwalajÄ…cy na ewolucyjne przyjÄ™cie nowego paradygmatu.

                        ProgramiÅ›ci C mogli kontynuowaÄ‡ pisanie kodu proceduralnego, stopniowo wprowadzajÄ…c
                        elementy obiektowe. Nie byÅ‚o koniecznoÅ›ci rewolucyjnej zmiany caÅ‚ego podejÅ›cia.
                    </aside>
                </section>

                <!-- C++: Ewolucja, nie rewolucja -->
                <section>
                    <h3>C++: Ewolucja, nie rewolucja</h3>
                    <div class="row" style="margin-top: 20px;">
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Kod C (dziaÅ‚a w C++)</h4>
                            <pre style="font-size: 11px;"><code class="hljs c" data-trim>
// Czysty C
#include <stdio.h>

int suma(int a, int b) {
    return a + b;
}

int main() {
    int wynik = suma(5, 3);
    printf("%d\n", wynik);
    return 0;
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.85em;">Kod C++ (z klasami)</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
// C++ z klasÄ…
#include <iostream>
using namespace std;

class Kalkulator {
public:
    int suma(int a, int b) {
        return a + b;
    }
};

int main() {
    Kalkulator k;
    cout << k.suma(5, 3) << endl;
    return 0;
}
                            </code></pre>
                        </div>
                    </div>
                    <p style="font-size: 0.75em; margin-top: 20px;">
                        ğŸ’¡ Kod C pozostawaÅ‚ poprawnym kodem C++ - kompatybilnoÅ›Ä‡ wsteczna!
                    </p>
                    <aside class="notes">
                        Kod C pozostawaÅ‚ poprawnym kodem C++, zapewniajÄ…c kompatybilnoÅ›Ä‡ wstecznÄ….
                        ProgramiÅ›ci mogli stopniowo wprowadzaÄ‡ klasy i obiekty, nie przepisujÄ…c
                        caÅ‚ego projektu od zera.

                        PoczÄ…tkowo jÄ™zyk nazywaÅ‚ siÄ™ "C with Classes". Zmiana nazwy na C++ (operator
                        inkrementacji w C oznacza zwiÄ™kszenie o 1) symbolizowaÅ‚a ewolucyjny charakter jÄ™zyka.
                    </aside>
                </section>

                <!-- C++: Klasy w C++ -->
                <section>
                    <h3>C++: Wprowadzenie klas</h3>
                    <pre style="font-size: 13px;"><code class="hljs cpp" data-trim>
// Klasa w C++
class Konto {
private:
    double saldo;
    string wlasciciel;
    
public:
    // Konstruktor
    Konto(string w, double s) : wlasciciel(w), saldo(s) {}
    
    void wplac(double kwota) {
        if (kwota > 0)
            saldo += kwota;
    }
    
    void wyplac(double kwota) {
        if (kwota > 0 && kwota <= saldo)
            saldo -= kwota;
    }
    
    double pobierz_saldo() const {
        return saldo;
    }
};
                    </code></pre>
                    <aside class="notes">
                        C++ wprowadziÅ‚ klasy z peÅ‚nÄ… enkapsulacjÄ… - pola prywatne, metody publiczne,
                        konstruktory. JednoczeÅ›nie zachowaÅ‚ wszystkie moÅ¼liwoÅ›ci C - wskaÅºniki,
                        bezpoÅ›redni dostÄ™p do pamiÄ™ci, struktury.
                    </aside>
                </section>

                <!-- C++: WskaÅºniki + OOP -->
                <section>
                    <h3>C++: Niskopoziomowa kontrola + OOP</h3>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class Osoba {
private:
    string imie;
    int wiek;
public:
    Osoba(string i, int w) : imie(i), wiek(w) {}
    void wyswietl() { cout << imie << ", " << wiek << endl; }
};

int main() {
    // Obiekt na stosie (jak w C)
    Osoba p1("Jan", 30);
    
    // Obiekt na stercie (wskaÅºnik jak w C)
    Osoba* p2 = new Osoba("Anna", 25);
    
    p1.wyswietl();
    p2->wyswietl();
    
    // Manualne zarzÄ…dzanie pamiÄ™ciÄ… (jak w C)
    delete p2;  // Musimy pamiÄ™taÄ‡!
    
    return 0;
}
                    </code></pre>
                    <aside class="notes">
                        C++ zachowaÅ‚ fundamentalne cechy C: bezpoÅ›redni dostÄ™p do pamiÄ™ci, wskaÅºniki,
                        moÅ¼liwoÅ›Ä‡ programowania niskopoziomowego. JednoczeÅ›nie wprowadziÅ‚ klasy, dziedziczenie,
                        polimorfizm, szablony. 
                        
                        To poÅ‚Ä…czenie czyni C++ unikalnym - pozwala na niskopoziomowÄ… kontrolÄ™ 
                        (zarzÄ…dzanie kaÅ¼dym bajtem pamiÄ™ci) oraz wysokopoziomowÄ… organizacjÄ™ 
                        (eleganckie hierarchie klas).
                    </aside>
                </section>

                <!-- C++: Dziedziczenie -->
                <section>
                    <h3>C++: Dziedziczenie i polimorfizm</h3>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class Pojazd {
protected:
    string marka;
public:
    Pojazd(string m) : marka(m) {}
    virtual void jedz() {  // Metoda wirtualna
        cout << "Pojazd jedzie" << endl;
    }
};

class Samochod : public Pojazd {
private:
    int liczba_drzwi;
public:
    Samochod(string m, int d) : Pojazd(m), liczba_drzwi(d) {}
    void jedz() override {  // Nadpisanie
        cout << "SamochÃ³d " << marka << " jedzie" << endl;
    }
};

// Polimorfizm
Pojazd* p = new Samochod("Toyota", 4);
p->jedz();  // WywoÅ‚uje Samochod::jedz()
                    </code></pre>
                    <aside class="notes">
                        C++ wprowadziÅ‚ peÅ‚ne wsparcie dla dziedziczenia i polimorfizmu. Metody wirtualne
                        umoÅ¼liwiajÄ… dynamiczne wiÄ…zanie - wywoÅ‚anie odpowiedniej metody w runtime
                        w zaleÅ¼noÅ›ci od rzeczywistego typu obiektu.

                        To wszystko przy zachowaniu wydajnoÅ›ci - programista moÅ¼e wybraÄ‡ czy chce
                        polimorfizm (metody wirtualne) czy maksymalnÄ… wydajnoÅ›Ä‡ (metody niewirtualne).
                    </aside>
                </section>

                <!-- C++: Zastosowania -->
                <section>
                    <h3>C++: Gdzie siÄ™ sprawdza?</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>ğŸ–¥ï¸ Systemy operacyjne:</strong>
                            <p style="margin-top: 10px;">Windows, Linux - wydajnoÅ›Ä‡ + organizacja</p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>ğŸ® Silniki gier:</strong>
                            <p style="margin-top: 10px;">Unreal Engine - kontrola kaÅ¼dego klatki na sekundÄ™</p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>ğŸš— Embedded/Automotive:</strong>
                            <p style="margin-top: 10px;">Systemy kontroli w samochodach, samolotach</p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>ğŸŒ PrzeglÄ…darki:</strong>
                            <p style="margin-top: 10px;">Chrome, Firefox - wydajnoÅ›Ä‡ krytyczna</p>
                        </div>
                    </div>
                    <aside class="notes">
                        Zastosowania C++: systemy operacyjne (Windows, Linux), silniki gier (Unreal Engine),
                        oprogramowanie embedded (automotive, avionics), aplikacje wymagajÄ…ce wydajnoÅ›ci
                        (przeglÄ…darki Chrome, Firefox).

                        WszÄ™dzie tam, gdzie liczy siÄ™ wydajnoÅ›Ä‡ i niskopoziomowa kontrola, ale jednoczeÅ›nie
                        potrzebna jest dobra organizacja duÅ¼ego projektu.
                    </aside>
                </section>

                <!-- C++: Charakterystyka -->
                <section>
                    <h3>C++: Ewolucja C</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>ğŸ’¡ Kluczowa idea:</strong>
                            <p style="margin-top: 10px;">
                                C++ nie jest jÄ™zykiem stworzonym od podstaw dla OOP.<br>
                                Jest <strong>ewolucjÄ… C w kierunku obiektowoÅ›ci</strong>.
                            </p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>To wyjaÅ›nia:</strong>
                            <ul style="margin-top: 10px;">
                                <li>WspÃ³Å‚istnienie struktur i klas</li>
                                <li>Operatory <code>new</code> i <code>malloc</code></li>
                                <li>RÃ³Å¼ne konwencje i style</li>
                                <li>WieloÅ›Ä‡ paradygmatÃ³w (proceduralny, obiektowy, generyczny)</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        C++ nie jest jÄ™zykiem stworzonym od podstaw dla OOP. Jest ewolucjÄ… C w kierunku
                        obiektowoÅ›ci, zachowujÄ…cÄ… kompatybilnoÅ›Ä‡ i wydajnoÅ›Ä‡. 
                        
                        To wyjaÅ›nia wiele jego osobliwoÅ›ci - koegzystencja struktur i klas, operatorÃ³w 
                        new/malloc, rÃ³Å¼ne konwencje. Zrozumienie tej ewolucji jest kluczem do zrozumienia jÄ™zyka.
                    </aside>
                </section>

                <!-- Java -->
                <section>
                    <h3>1995: Java</h3>
                    <p><strong>James Gosling (Sun Microsystems)</strong></p>
                    <ul>
                        <li>"Write once, run anywhere" (JVM)</li>
                        <li>Automatyczne zarzÄ…dzanie pamiÄ™ciÄ…</li>
                        <li>Wymuszony OOP - wszystko w klasach</li>
                    </ul>
                    <aside class="notes">
                        Rok 1995, Sun Microsystems. Kontekst: ekspansja Internetu, heterogeniczne
                        Å›rodowiska sprzÄ™towe (PC, Mac, Unix), potrzeba przenoÅ›noÅ›ci oprogramowania.
                        
                        James Gosling projektuje JavÄ™ z fundamentalnym zaÅ‚oÅ¼eniem: "Write once, run anywhere".

                        W kolejnych slajdach zobaczymy jak Java rÃ³Å¼ni siÄ™ od C++.
                    </aside>
                </section>

                <!-- Java: Problem przenoÅ›noÅ›ci -->
                <section>
                    <h3>Java: Problem do rozwiÄ…zania</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(231, 76, 60, 0.1); border-left: 4px solid #e74c3c;">
                            <strong>ğŸŒ Problem lat 90.:</strong>
                            <p style="margin-top: 10px;">
                                RÃ³Å¼ne platformy: Windows, macOS, Unix, Solaris...<br>
                                KaÅ¼da wymaga osobnej kompilacji i testowania!
                            </p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>C++ problem:</strong>
                            <pre style="font-size: 11px; margin-top: 10px;"><code class="hljs bash" data-trim>
# Trzeba kompilowaÄ‡ osobno dla kaÅ¼dej platformy!
g++ program.cpp -o program_windows.exe    # Windows
g++ program.cpp -o program_mac            # macOS  
g++ program.cpp -o program_linux          # Linux
                            </code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        Kontekst: ekspansja Internetu, heterogeniczne Å›rodowiska sprzÄ™towe (PC, Mac, Unix), 
                        potrzeba przenoÅ›noÅ›ci oprogramowania. James Gosling projektuje JavÄ™ z fundamentalnym 
                        zaÅ‚oÅ¼eniem: "Write once, run anywhere".

                        W C++ ten sam kod trzeba kompilowaÄ‡ osobno dla kaÅ¼dej platformy. To generuje
                        ogromne koszty testowania i dystrybucji.
                    </aside>
                </section>

                <!-- Java: JVM -->
                <section>
                    <h3>Java: RozwiÄ…zanie - JVM</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.8em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>Java Virtual Machine:</strong>
                            <p style="margin-top: 10px;">
                                1. Kompilujesz raz â†’ bytecode (.class)<br>
                                2. JVM na kaÅ¼dej platformie uruchamia ten sam bytecode
                            </p>
                        </div>
                    </div>
                    <pre style="font-size: 12px;"><code class="hljs java" data-trim>
// Program.java
public class Program {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// Kompilacja (raz!)
javac Program.java  â†’ Program.class (bytecode)

// Uruchomienie (na dowolnej platformie!)
java Program  // Windows
java Program  // macOS
java Program  // Linux
                    </code></pre>
                    <aside class="notes">
                        Mechanizm realizacji: Java Virtual Machine (JVM). Kompilacja nie produkuje
                        kodu maszynowego specyficznego dla platformy, lecz bytecode - kod poÅ›redni.
                        
                        JVM na kaÅ¼dej platformie interpretuje ten bytecode. Ten sam plik .class
                        wykonuje siÄ™ identycznie na Windows, macOS, Linux.

                        To byÅ‚a rewolucja w dystrybucji oprogramowania!
                    </aside>
                </section>

                <!-- Java: Garbage Collector -->
                <section>
                    <h3>Java: Automatyczne zarzÄ…dzanie pamiÄ™ciÄ…</h3>
                    <div class="row" style="margin-top: 20px;">
                        <div class="column">
                            <h4 style="font-size: 0.8em; color: #e74c3c;">C++ (manualnie)</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
Osoba* p = new Osoba("Jan");
// ... uÅ¼ywamy obiektu ...

delete p;  // MUSISZ PAMIÄ˜TAÄ†!

// ZapomniaÅ‚eÅ›? 
// â†’ Wyciek pamiÄ™ci! ğŸ’¥
                            </code></pre>
                            <p style="font-size: 0.7em; margin-top: 10px;">âŒ Åatwo o bÅ‚Ä™dy!</p>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.8em; color: #2ecc71;">Java (automatycznie)</h4>
                            <pre style="font-size: 11px;"><code class="hljs java" data-trim>
Osoba p = new Osoba("Jan");
// ... uÅ¼ywamy obiektu ...

// Koniec! Nie musisz nic robiÄ‡!
// Garbage Collector sam usuwa âœ…
                            </code></pre>
                            <p style="font-size: 0.7em; margin-top: 10px;">âœ… Bezpieczniejsze!</p>
                        </div>
                    </div>
                    <aside class="notes">
                        Java wprowadziÅ‚a pierwszÄ… fundamentalnÄ… zmianÄ™ wzglÄ™dem C++:

                        Garbage Collector - automatyczne zarzÄ…dzanie pamiÄ™ciÄ…. W C++ programista
                        musi pamiÄ™taÄ‡: new wymaga delete. Brak delete prowadzi do wycieku pamiÄ™ci - program
                        konsumuje coraz wiÄ™cej RAM. 
                        
                        W Javie Garbage Collector automatycznie identyfikuje i usuwa nieuÅ¼ywane obiekty. 
                        To znaczÄ…co upraszcza programowanie, kosztem mniejszej kontroli i potencjalnie 
                        wolniejszego dziaÅ‚ania podczas zbierania Å›mieci.
                    </aside>
                </section>

                <!-- Java: Wymuszony OOP -->
                <section>
                    <h3>Java: Wymuszony paradygmat OOP</h3>
                    <pre style="font-size: 13px;"><code class="hljs java" data-trim>
// W Javie WSZYSTKO musi byÄ‡ w klasie!
public class Program {
    // Nawet main() jest metodÄ… klasy
    public static void main(String[] args) {
        System.out.println("Hello!");
    }
}

// To NIE zadziaÅ‚a w Javie:
// void funkcja() { ... }  // âŒ Musi byÄ‡ w klasie!
// int x = 5;              // âŒ Musi byÄ‡ polem klasy!

// Poprawnie:
public class MojaKlasa {
    private int x = 5;        // âœ… Pole klasy
    
    public void funkcja() {   // âœ… Metoda klasy
        // ...
    }
}
                    </code></pre>
                    <aside class="notes">
                        Druga fundamentalna zmiana: Wymuszony paradygmat obiektowy. W Javie nie moÅ¼na 
                        napisaÄ‡ kodu poza klasÄ…. Funkcja main() musi byÄ‡ metodÄ… statycznÄ… klasy. 
                        Zmienne globalne nie istniejÄ… - muszÄ… byÄ‡ statycznymi polami klas.

                        To wymuszenie paradygmatu miaÅ‚o znaczÄ…cy efekt edukacyjny. W C++ moÅ¼na mieszaÄ‡
                        kod proceduralny z obiektowym. Java nie pozwala na kompromisy - tylko czyste OOP.
                    </aside>
                </section>

                <!-- Java: Wszystko obiektowe -->
                <section>
                    <h3>Java: Prawie wszystko jest obiektem</h3>
                    <pre style="font-size: 13px;"><code class="hljs java" data-trim>
// Typy prymitywne (wyjÄ…tek)
int liczba = 5;
boolean prawda = true;

// Ale majÄ… obiektowe wrappery!
Integer liczbaObj = 5;        // Autoboxing
Boolean prawdaObj = true;

// MogÄ… uÅ¼ywaÄ‡ metod obiektowych
String text = liczbaObj.toString();
int wartosc = liczbaObj.intValue();

// Kolekcje wymagajÄ… obiektÃ³w
ArrayList<Integer> lista = new ArrayList<>();
lista.add(5);  // int â†’ Integer automatycznie!

// ArrayList<int> lista;  // âŒ NIE ZADZIAÅA!
                    </code></pre>
                    <aside class="notes">
                        Wszystko musi byÄ‡ obiektem (z wyjÄ…tkiem typÃ³w prymitywnych, ktÃ³re posiadajÄ… 
                        wrappery obiektowe: int â†’ Integer).

                        Miliony programistÃ³w uczÄ…cych siÄ™ Javy musiaÅ‚o opanowaÄ‡ wÅ‚aÅ›ciwe praktyki obiektowe.
                        To miaÅ‚o ogromny wpÅ‚yw edukacyjny - Java wymusiÅ‚ myÅ›lenie obiektowe.
                    </aside>
                </section>

                <!-- Java: Klasa w Javie -->
                <section>
                    <h3>Java: PrzykÅ‚ad klasy</h3>
                    <pre style="font-size: 12px;"><code class="hljs java" data-trim>
public class Konto {
    // Pola (zawsze prywatne!)
    private double saldo;
    private String wlasciciel;
    
    // Konstruktor
    public Konto(String wlasciciel, double saldo) {
        this.wlasciciel = wlasciciel;
        this.saldo = saldo;
    }
    
    // Metody publiczne
    public void wplac(double kwota) {
        if (kwota > 0) {
            saldo += kwota;
        }
    }
    
    public void wyplac(double kwota) {
        if (kwota > 0 && kwota <= saldo) {
            saldo -= kwota;
        }
    }
    
    // Getter
    public double getSaldo() {
        return saldo;
    }
}
                    </code></pre>
                    <aside class="notes">
                        Typowa klasa w Javie: pola prywatne, konstruktor publiczny, metody publiczne,
                        gettery/settery. To jest standard w Javie - enkapsulacja jest wymuszona
                        przez konwencje jÄ™zyka i dobre praktyki.
                    </aside>
                </section>

                <!-- Java: PorÃ³wnanie C++ vs Java -->
                <section>
                    <h3>Java vs C++: Filozofie</h3>
                    <div class="row" style="margin-top: 20px; font-size: 0.75em;">
                        <div class="column">
                            <h4 style="color: #9b59b6;">C++</h4>
                            <ul style="font-size: 0.9em;">
                                <li>âœ… Maksymalna wydajnoÅ›Ä‡</li>
                                <li>âœ… Kontrola niskopoziomowa</li>
                                <li>âœ… WskaÅºniki, pamiÄ™Ä‡</li>
                                <li>âš ï¸ Manualne delete</li>
                                <li>âš ï¸ Kompilacja dla platform</li>
                            </ul>
                            <p style="margin-top: 15px; font-style: italic;">
                                "PeÅ‚na kontrola + odpowiedzialnoÅ›Ä‡"
                            </p>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">Java</h4>
                            <ul style="font-size: 0.9em;">
                                <li>âœ… PrzenoÅ›noÅ›Ä‡ (JVM)</li>
                                <li>âœ… Automatyczny GC</li>
                                <li>âœ… BezpieczeÅ„stwo</li>
                                <li>âš ï¸ Mniejsza kontrola</li>
                                <li>âš ï¸ Wolniejsze (czasem)</li>
                            </ul>
                            <p style="margin-top: 15px; font-style: italic;">
                                "BezpieczeÅ„stwo + prostota"
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Dla programistÃ³w C++ Java reprezentuje alternatywnÄ… filozofiÄ™: rezygnacja
                        z niskopoziomowej kontroli w zamian za bezpieczeÅ„stwo i przenoÅ›noÅ›Ä‡. 
                        
                        Oba podejÅ›cia majÄ… uzasadnienie w odpowiednich kontekstach zastosowaÅ„.
                    </aside>
                </section>

                <!-- Java: Zastosowania -->
                <section>
                    <h3>Java: Gdzie siÄ™ sprawdza?</h3>
                    <div style="text-align: left; margin: 20px; font-size: 0.85em;">
                        <div style="margin: 15px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>ğŸŒ Aplikacje webowe (backend):</strong>
                            <p style="margin-top: 10px;">Spring, Hibernate - systemy korporacyjne</p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>ğŸ“± Android:</strong>
                            <p style="margin-top: 10px;">WiÄ™kszoÅ›Ä‡ aplikacji (choÄ‡ Kotlin zyskuje)</p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>ğŸ¦ Systemy enterprise:</strong>
                            <p style="margin-top: 10px;">BankowoÅ›Ä‡, ubezpieczenia - Java EE dominuje</p>
                        </div>
                        <div style="margin: 15px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>â˜ï¸ Big Data:</strong>
                            <p style="margin-top: 10px;">Hadoop, Apache Spark - ekosystem JVM</p>
                        </div>
                    </div>
                    <aside class="notes">
                        WspÃ³Å‚czesne zastosowania Javy: aplikacje webowe (backend - Spring, Hibernate),
                        Android (choÄ‡ obecnie Kotlin zyskuje przewagÄ™), systemy korporacyjne (bankowoÅ›Ä‡,
                        ubezpieczenia, gdzie dominuje Java Enterprise Edition).

                        Java sprawdza siÄ™ wszÄ™dzie tam, gdzie przenoÅ›noÅ›Ä‡ i bezpieczeÅ„stwo sÄ… waÅ¼niejsze
                        niÅ¼ maksymalna wydajnoÅ›Ä‡.
                    </aside>
                </section>

                <!-- Dlaczego OOP wygraÅ‚o -->
                <section>
                    <h3>Dlaczego OOP?</h3>
                    <div style="text-align: left; margin: 20px;">
                        <div data-id="enkapsulacja"
                            style="margin: 20px 0; padding: 15px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71;">
                            <strong>âœ… Enkapsulacja</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Dane chronione - tylko metody mogÄ… je zmieniaÄ‡
                            </p>
                        </div>
                        <div data-id="modularnosc"
                            style="margin: 20px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db;">
                            <strong>âœ… ModularnoÅ›Ä‡</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                NiezaleÅ¼ne obiekty - Å‚atwiej debugowaÄ‡
                            </p>
                        </div>
                        <div data-id="wielokrotne"
                            style="margin: 20px 0; padding: 15px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6;">
                            <strong>âœ… Wielokrotne uÅ¼ycie</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Dziedziczenie - nie piszesz od zera
                            </p>
                        </div>
                        <div data-id="naturalne"
                            style="margin: 20px 0; padding: 15px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22;">
                            <strong>âœ… Naturalne myÅ›lenie</strong>
                            <p style="font-size: 0.85em; margin-top: 10px;">
                                Kod = rzeczywistoÅ›Ä‡ (Klient, Produkt, ZamÃ³wienie)
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        Programowanie obiektowe rozwiÄ…zaÅ‚o fundamentalne problemy inÅ¼ynierii oprogramowania
                        na duÅ¼Ä… skalÄ™. 
                        
                        W kolejnych slajdach szczegÃ³Å‚owo omÃ³wimy kaÅ¼dy z czterech filarÃ³w OOP.
                    </aside>
                </section>

                <!-- Enkapsulacja - szczegÃ³Å‚y -->
                <section>
                    <div data-id="enkapsulacja"
                        style="padding: 20px; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… Enkapsulacja</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            Ukrywanie implementacji i kontrola dostÄ™pu
                        </p>
                    </div>
                    <div class="row" style="margin-top: 20px; font-size: 0.8em;">
                        <div class="column">
                            <h4 style="color: #e74c3c;">âŒ Bez enkapsulacji</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
class BankAccount {
public:
    double balance; // KaÅ¼dy ma dostÄ™p!
};

BankAccount acc;
acc.balance = -1000000; // ğŸ’¥ MoÅ¼liwe!
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">âœ… Z enkapsulacjÄ…</h4>
                            <pre style="font-size: 11px;"><code class="hljs cpp" data-trim>
class BankAccount {
private:
    double balance; // Chronione!
public:
    void deposit(double amount) {
        if (amount > 0) // Walidacja
            balance += amount;
    }
    void withdraw(double amount) {
        if (amount > 0 && amount <= balance)
            balance -= amount;
    }
};
// acc.balance = -1000; // âŒ BÅÄ„D!
                            </code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        ENKAPSULACJA - ukrywanie implementacji i kontrola dostÄ™pu.

                        RozwaÅ¼my klasÄ™ BankAccount. Pole balance jest prywatne. DostÄ™p moÅ¼liwy wyÅ‚Ä…cznie
                        poprzez metody deposit() i withdraw(). Te metody zawierajÄ… logikÄ™ walidacji:
                        deposit() weryfikuje czy kwota jest dodatnia, withdraw() sprawdza czy saldo
                        jest wystarczajÄ…ce. BezpoÅ›rednie przypisanie balance = -1000000 jest niemoÅ¼liwe -
                        kompilator zgÅ‚osi bÅ‚Ä…d dostÄ™pu do prywatnego pola.

                        To fundamentalna rÃ³Å¼nica wzglÄ™dem programowania proceduralnego, gdzie kaÅ¼da
                        zmienna globalna moÅ¼e byÄ‡ modyfikowana przez dowolny fragment kodu. Enkapsulacja
                        gwarantuje, Å¼e dane mogÄ… byÄ‡ zmieniane tylko w kontrolowany sposÃ³b.
                    </aside>
                </section>

                <!-- ModularnoÅ›Ä‡ - szczegÃ³Å‚y -->
                <section>
                    <div data-id="modularnosc"
                        style="padding: 20px; background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… ModularnoÅ›Ä‡</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            NiezaleÅ¼noÅ›Ä‡ komponentÃ³w
                        </p>
                    </div>
                    <pre style="font-size: 12px;"><code class="hljs cpp" data-trim>
class User {
private:
    string name;
    string email;
public:
    string getName() { return name; }
    void setName(string n) { name = n; }
};

class Invoice {
private:
    double amount;
    User* customer;
public:
    void generatePDF() { /* ... */ }
};

// User nie wie o Invoice, Invoice uÅ¼ywa tylko interfejsu User
// Zmiana implementacji User nie wpÅ‚ywa na Invoice!
                    </code></pre>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 10px; font-size: 0.85em;">
                        ğŸ’¡ KaÅ¼da klasa to niezaleÅ¼ny moduÅ‚ - Å‚atwiejsze debugowanie i utrzymanie
                    </div>
                    <aside class="notes">
                        MODULARNOÅšÄ† - niezaleÅ¼noÅ›Ä‡ komponentÃ³w.

                        KaÅ¼da klasa stanowi niezaleÅ¼ny moduÅ‚. Klasa User nie posiada wiedzy o klasie Invoice.
                        Modyfikacja implementacji User nie wpÅ‚ywa na Invoice, o ile interfejs publiczny
                        (publiczne metody) pozostaje niezmieniony. Reszta systemu nie zauwaÅ¼a wewnÄ™trznych zmian.

                        W systemie skÅ‚adajÄ…cym siÄ™ ze stu klas, kaÅ¼da stanowi czarnÄ… skrzynkÄ™.
                        Interfejs publiczny definiuje wejÅ›cie i wyjÅ›cie, implementacja jest ukryta.
                        Debugowanie staje siÄ™ prostsze - bÅ‚Ä…d w klasie Payment wymaga analizy tylko tej klasy,
                        nie caÅ‚ego systemu.
                    </aside>
                </section>

                <!-- Wielokrotne uÅ¼ycie - szczegÃ³Å‚y -->
                <section>
                    <div data-id="wielokrotne"
                        style="padding: 20px; background: rgba(155, 89, 182, 0.1); border-left: 4px solid #9b59b6; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… Wielokrotne uÅ¼ycie</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            Dziedziczenie i kompozycja
                        </p>
                    </div>
                    <div class="row" style="margin-top: 20px; font-size: 0.75em;">
                        <div class="column">
                            <h4 style="font-size: 0.9em;">Dziedziczenie</h4>
                            <pre style="font-size: 10px;"><code class="hljs cpp" data-trim>
class Animal {
protected:
    string name;
public:
    void eat() { /*...*/ }
    void sleep() { /*...*/ }
};

class Dog : public Animal {
public:
    void bark() { /*...*/ }
    // Otrzymuje eat() i sleep()
    // automatycznie!
};
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4 style="font-size: 0.9em;">Kompozycja</h4>
                            <pre style="font-size: 10px;"><code class="hljs cpp" data-trim>
class Engine {
public:
    void start() { /*...*/ }
    void stop() { /*...*/ }
};

class Car {
private:
    Engine engine; // Zawiera Engine
public:
    void drive() {
        engine.start();
        // ...
    }
};
// Ten sam Engine w Motorcycle!
                            </code></pre>
                        </div>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(155, 89, 182, 0.1); border-radius: 10px; font-size: 0.85em;">
                        ğŸ’¡ Ponowne wykorzystanie bez duplikacji kodu
                    </div>
                    <aside class="notes">
                        WIELOKROTNE UÅ»YCIE - dziedziczenie i kompozycja.

                        Klasa Animal definiuje metody eat(), sleep(), makeSound(). Klasa Dog dziedziczy
                        po Animal, automatycznie otrzymujÄ…c te metody. Programista dodaje tylko metodÄ™ bark().
                        Nie ma duplikacji kodu bazowego.

                        Kompozycja: klasa Car zawiera obiekt Engine. Ten sam Engine moÅ¼e byÄ‡ uÅ¼ywany
                        w klasie Motorcycle. Ponowne wykorzystanie bez kopiowania.

                        W programowaniu proceduralnym ponowne uÅ¼ycie wymaga copy-paste. Modyfikacja
                        w jednym miejscu wymaga modyfikacji we wszystkich kopiach. To prowadzi do
                        bÅ‚Ä™dÃ³w i trudnoÅ›ci w utrzymaniu.
                    </aside>
                </section>

                <!-- Naturalne modelowanie - szczegÃ³Å‚y -->
                <section>
                    <div data-id="naturalne"
                        style="padding: 20px; background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22; margin-bottom: 20px;">
                        <h3 style="margin: 0;">âœ… Naturalne myÅ›lenie</h3>
                        <p style="font-size: 0.85em; margin-top: 10px;">
                            Odzwierciedlenie rzeczywistoÅ›ci w kodzie
                        </p>
                    </div>
                    <div style="text-align: left; margin: 20px; font-size: 0.8em;">
                        <div style="margin: 15px 0; padding: 12px; background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db;">
                            <strong>ğŸ›’ System e-commerce - naturalne encje:</strong>
                        </div>
                        <pre style="font-size: 11px; margin-top: 15px;"><code class="hljs cpp" data-trim>
class Customer {
    string name, address;
    vector<Order> orderHistory;
};

class Product {
    string name, description;
    double price;
};

class ShoppingCart {
    vector<Product> items;
    double calculateTotal();
};

class Order {
    Customer* customer;
    vector<Product> products;
    string status; // "pending", "shipped", "delivered"
};
                        </code></pre>
                        <div style="margin-top: 15px; padding: 12px; background: rgba(230, 126, 34, 0.1); border-radius: 10px;">
                            ğŸ’¡ Kod = bezpoÅ›rednie odzwierciedlenie struktury biznesowej
                        </div>
                    </div>
                    <aside class="notes">
                        NATURALNE MODELOWANIE - odzwierciedlenie rzeczywistoÅ›ci.

                        ProjektujÄ…c system e-commerce, naturalnie identyfikujemy encje: Klient (imiÄ™, adres,
                        historia zamÃ³wieÅ„), Produkt (nazwa, cena, opis), Koszyk (lista produktÃ³w, suma),
                        ZamÃ³wienie (klient, produkty, status).

                        OOP pozwala bezpoÅ›rednio zapisaÄ‡ tÄ™ strukturÄ™ w kodzie:
                        class Customer { }, class Product { }, class ShoppingCart { }, class Order { }

                        Kod staje siÄ™ samodokumentujÄ…cym. Nowy programista analizujÄ…cy projekt
                        natychmiast rozumie strukturÄ™ systemu przez nazwy klas. Nie musi analizowaÄ‡
                        tysiÄ™cy linii funkcji o niejasnych nazwach.

                        To sÄ… cztery filary programowania obiektowego: enkapsulacja, modularnoÅ›Ä‡,
                        wielokrotne uÅ¼ycie, naturalne modelowanie. Nie sÄ… abstrakcyjnymi koncepcjami -
                        to praktyczne narzÄ™dzia rozwiÄ…zujÄ…ce realne problemy inÅ¼ynierskie.
                    </aside>
                </section>

                <!-- PorÃ³wnanie: Proceduralne vs Obiektowe -->
                <section>
                    <h3>PorÃ³wnanie: Proceduralne vs Obiektowe</h3>
                    <div class="row">
                        <div class="column">
                            <h4 style="color: #ff6b6b;">âŒ Proceduralnie</h4>
                            <pre style="font-size: 13px;"><code class="hljs c">int saldo = 1000;

void wplac(int kwota) {
    saldo += kwota;
}

void wyplac(int kwota) {
    saldo -= kwota;
}

// KaÅ¼dy moÅ¼e:
saldo = -5000; // Ups!
</code></pre>
                        </div>
                        <div class="column">
                            <h4 style="color: #2ecc71;">âœ… Obiektowo</h4>
                            <pre style="font-size: 13px;"><code class="hljs cpp">class Konto {
private:
    int saldo;
public:
    void wplac(int kwota) {
        if (kwota > 0)
            saldo += kwota;
    }
    void wyplac(int kwota) {
        if (kwota > 0 && kwota <= saldo)
            saldo -= kwota;
    }
};

// Chronione!
// k.saldo = -5000; // BÅÄ„D!
</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        PorÃ³wnanie implementacji konta bankowego w paradygmatach proceduralnym i obiektowym
                        ilustruje fundamentalne rÃ³Å¼nice.

                        PODEJÅšCIE PROCEDURALNE:

                        Zmienna "saldo" jest globalna. KaÅ¼dy fragment programu ma do niej dostÄ™p i moÅ¼e
                        jÄ… modyfikowaÄ‡. Funkcje wplac() i wyplac() operujÄ… na tej zmiennej. Problem:
                        identyfikacja wszystkich miejsc modyfikujÄ…cych saldo wymaga przeszukania caÅ‚ego kodu.

                        Brak walidacji. Funkcja wyplac() nie weryfikuje czy saldo jest wystarczajÄ…ce.
                        Funkcja wplac() nie sprawdza czy kwota jest dodatnia. NajwiÄ™kszy problem:
                        bezpoÅ›rednie przypisanie saldo = -5000 jest poprawne skÅ‚adniowo.

                        Kompilator akceptuje taki kod. Program kompiluje siÄ™ i uruchamia. BÅ‚Ä…d manifestuje
                        siÄ™ w runtime, potencjalnie po dÅ‚uÅ¼szym okresie dziaÅ‚ania systemu. System produkcyjny
                        moÅ¼e wykazaÄ‡ nieprawidÅ‚owe saldo klienta: -5000 zÅ‚.

                        PODEJÅšCIE OBIEKTOWE:

                        Klasa Konto. Pole saldo jest prywatne. DostÄ™p ma wyÅ‚Ä…cznie kod wewnÄ…trz klasy.
                        Z zewnÄ…trz dostÄ™p jest niemoÅ¼liwy.

                        Metody wplac() i wyplac() sÄ… publiczne - stanowiÄ… interfejs klasy. ZawierajÄ…
                        logikÄ™ walidacji: wplac() weryfikuje if (kwota > 0), wyplac() sprawdza
                        if (kwota > 0 && kwota <= saldo). PrÃ³ba bezpoÅ›redniej modyfikacji k.saldo=-5000 jest bÅ‚Ä™dem
                            kompilacji. Kompilator zgÅ‚osi bÅ‚Ä…d przed uruchomieniem, nie po tygodniach dziaÅ‚ania w
                            Å›rodowisku produkcyjnym. To ilustruje fundamentalnÄ… wartoÅ›Ä‡ OOP: kontrola i bezpieczeÅ„stwo.
                            Projektant klasy definiuje poprawne operacje. UÅ¼ytkownik klasy (inny programista, moÅ¼liwe
                            ten sam programista po upÅ‚ywie czasu) nie moÅ¼e naruszyÄ‡ niezmiennikÃ³w. Kompilator egzekwuje
                            reguÅ‚y. Ten przykÅ‚ad demonstruje nie teoretycznÄ… koncepcjÄ™, lecz praktyczne narzÄ™dzie.
                            BezpieczeÅ„stwo, kontrola, mniej bÅ‚Ä™dÃ³w, Å‚atwiejsze utrzymanie. To konkretne korzyÅ›ci
                            inÅ¼ynierskie, nie abstrakcje akademickie. </aside>
                </section>

                <!-- Podsumowanie -->
                <section>
                    <h3>Podsumowanie</h3>
                    <p style="font-size: 1.1em; margin-bottom: 20px;">
                        <strong>OOP powstaÅ‚o, aby kod byÅ‚:</strong>
                    </p>
                    <ul style="font-size: 0.9em; line-height: 1.8;">
                        <li>ğŸ“¦ <strong>Bezpieczniejszy</strong> - chronione dane</li>
                        <li>ğŸ§© <strong>Modularny</strong> - Å‚atwiej zarzÄ…dzaÄ‡</li>
                        <li>â™»ï¸ <strong>Wielokrotnego uÅ¼ytku</strong> - dziedziczenie</li>
                        <li>ğŸŒ <strong>ZrozumiaÅ‚y</strong> - jak rzeczywistoÅ›Ä‡</li>
                    </ul>
                    <div
                        style="margin-top: 30px; padding: 20px; background: rgba(52, 152, 219, 0.1); border-radius: 10px;">
                        <p style="font-size: 0.9em; text-align: center; font-style: italic;">
                            "Nie programujemy dla komputerÃ³w, programujemy dla ludzi."
                        </p>
                    </div>
                    <aside class="notes">
                        Podsumowanie analizy historycznej:

                        Programowanie obiektowe nie jest arbitralnÄ… abstrakcjÄ… teoretycznÄ…. Jest odpowiedziÄ…
                        na konkretne problemy inÅ¼ynierskie, ktÃ³re ujawniÅ‚y siÄ™ w praktyce tworzenia
                        oprogramowania w latach 60-70 XX wieku.

                        W poczÄ…tkowej fazie, gdy programy liczyÅ‚y setki linii kodu, paradygmat proceduralny
                        byÅ‚ wystarczajÄ…cy. Jednak wraz ze wzrostem skali - systemy osiÄ…gajÄ…ce miliony linii
                        kodu, takie jak Windows, Oracle, systemy bankowe - podejÅ›cie proceduralne okazaÅ‚o siÄ™
                        nieadekwatne. Potrzebna byÅ‚a lepsza organizacja i kontrola zÅ‚oÅ¼onoÅ›ci.

                        Programowanie obiektowe dostarcza narzÄ™dzi do konstrukcji zÅ‚oÅ¼onych systemÃ³w
                        charakteryzujÄ…cych siÄ™: zrozumiaÅ‚oÅ›ciÄ… (klasy odzwierciedlajÄ… strukturÄ™ problemu),
                        bezpieczeÅ„stwem (enkapsulacja chroni niezmienniki), modularnoÅ›ciÄ… (Å‚atwiejsze
                        zarzÄ…dzanie i debugowanie), rozszerzalnoÅ›ciÄ… (dziedziczenie i polimorfizm).

                        W kolejnych zajÄ™ciach teoria zostanie przeniesiona do praktyki. Studenci bÄ™dÄ…
                        implementowaÄ‡ klasy, stosowaÄ‡ enkapsulacjÄ™, konstruowaÄ‡ hierarchie dziedziczenia,
                        wykorzystywaÄ‡ polimorfizm. To nie bÄ™dzie teoretyczna abstrakcja - bÄ™dzie praktyczne
                        zastosowanie narzÄ™dzi inÅ¼ynierskich.

                        NaleÅ¼y pamiÄ™taÄ‡: nauka programowania obiektowego jest procesem. PoczÄ…tkowo moÅ¼e
                        wydawaÄ‡ siÄ™ nadmiernie skomplikowane. Pytanie "dlaczego caÅ‚a klasa zamiast prostej
                        funkcji?" jest naturalne na poczÄ…tkowym etapie. Jednak wraz z doÅ›wiadczeniem,
                        szczegÃ³lnie przy projektach wiÄ™kszej skali, zalety OOP stajÄ… siÄ™ oczywiste.

                        WspÃ³Å‚czesne oprogramowanie - 90% systemÃ³w produkcyjnych - wykorzystuje paradygmat
                        obiektowy. Od systemÃ³w operacyjnych (Windows, Linux), przez platformy mobilne
                        (Android), po systemy webowe (Facebook, Google). To nie przypadek. OOP sprawdza siÄ™
                        w praktyce inÅ¼ynierskiej.

                        SkutecznoÅ›Ä‡ metody weryfikuje siÄ™ w praktyce, nie w teorii. OOP funkcjonuje
                        efektywnie w maÅ‚ych projektach (Ä‡wiczenia akademickie), Å›rednich (projekty
                        zaliczeniowe), i co najistotniejsze - w systemach przemysÅ‚owych o skali
                        milionÃ³w linii kodu.

                        Cytat na zakoÅ„czenie: "Nie programujemy dla komputerÃ³w, programujemy dla ludzi."

                        Komputer wykonuje kaÅ¼dy poprawny kod - proceduralny, obiektowy, assembly.
                        Jednak ludzie - programista za miesiÄ…c, kolega przejmujÄ…cy projekt, przyszÅ‚y
                        maintainer - wymagajÄ… kodu zrozumiaÅ‚ego.

                        Programowanie obiektowe tworzy kod czytelny dla ludzi. Kod do ktÃ³rego moÅ¼na wrÃ³ciÄ‡
                        po roku i zrozumieÄ‡ jego strukturÄ™. Kod moÅ¼liwy do przekazania bez wielogodzinnych
                        sesji wyjaÅ›niajÄ…cych.

                        WartoÅ›Ä‡ OOP nie tkwi w szybkoÅ›ci wykonania (choÄ‡ C++ jest efektywny) ani oszczÄ™dnoÅ›ci
                        pamiÄ™ci (choÄ‡ obiekty mogÄ… byÄ‡ kompaktowe). Fundamentalna wartoÅ›Ä‡ to: zrozumiaÅ‚oÅ›Ä‡,
                        utrzymywalnoÅ›Ä‡, skalowalnoÅ›Ä‡.

                        NastÄ™pne zajÄ™cia: implementacja pierwszej klasy w C++.
                    </aside>
                </section>

            </section>
            <!-- Koniec sekcji: Historia programowania -->
            <section data-background-color="black">
                <section data-auto-animate>
                    <h2 style="color: white;">Zadanie domowe + kartkÃ³wka</h2>
                    <p>ObejrzeÄ‡ materiaÅ‚y video, aby przygotowaÄ‡ sie do kartkÃ³wki.</p>
                    <small>
                        <ul>
                            <li><a href="https://youtu.be/D6EI7EbEN4Q">Czym jest Git? - Kurs gita po polsku #1/12</a>
                            </li>
                            <li><a href="https://youtu.be/4bXuEv2R3W4">Jak zapisaÄ‡ zmiany - Kurs gita po polsku
                                    #2/12</a></li>
                            <li><a href="https://youtu.be/gG80UsfMXsU">PrzestrzeÅ„ robocza i stage - Kurs gita po polsku
                                    #3/12</a></li>
                            <li><a href="https://youtu.be/I8lQK0NK0lY">Czym jest branch? - Kurs git po polsku #8/12</a>
                            </li>
                            <li><a href="https://youtu.be/7myDXGfEnds">Zdalne repozytorium i fork - Kurs git po polsku
                                    #9/12</a></li>
                            <li><a href="https://youtu.be/mxDN0rYQyGA">RozwiÄ…zywanie konfliktÃ³w - Kurs git po polsku
                                    #10/12</a></li>
                        </ul>
                    </small>
                    <br />
                    <small>PrzykÅ‚adowe pytania na kartkÃ³wkÄ™:
                        <ul>
                            <li>Co to jest system kontroli wersji?</li>
                            <li>WymieÅ„ podstawowe podstawowe komendy Gita i ich przeznaczenie</li>
                            <li>Co to jest repozytorium?</li>
                            <li>Co to jest branch?</li>
                            <li>Co to jest commit?</li>
                        </ul>
                    </small>

                </section>
            </section>
            <section data-background-gradient="linear-gradient(67deg, #1e5799, #7db9e8)">
                <section>
                    <h2>ZAJÄ˜CIA 2: Pierwsza klasa w C++</h2>
                    <p>Od struktury do klasy</p>
                </section>

                <!-- 6. Przypomnienie: struktura w C++ -->
                <section>
                    <h2>Przypomnienie: struktura w C++</h2>
                    <pre><code class="cpp" data-trim>
struct Point {
    int x;
    int y;
};

Point p1;
p1.x = 10;
p1.y = 20;
        </code></pre>
                    <ul style="font-size: 0.85em; margin-top: 20px;">
                        <li>Grupowanie danych</li>
                        <li>Wszystko publiczne</li>
                        <li>Brak kontroli dostÄ™pu</li>
                    </ul>
                </section>

                <!-- 7. Przechodzimy do klasy - minimalistyczny przykÅ‚ad -->
                <section>
                    <h2>Przechodzimy do klasy</h2>
                    <h3 style="font-size: 0.9em;">Minimalistyczny przykÅ‚ad</h3>
                    <pre><code class="cpp" data-trim>
class Point {
public:
    int x;
    int y;
};

Point p1;
p1.x = 10;
p1.y = 20;
        </code></pre>
                    <div
                        style="margin-top: 30px; padding: 15px; background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107;">
                        <p style="font-size: 0.85em;"><strong>RÃ³Å¼nica:</strong> domyÅ›lnie prywatne vs publiczne</p>
                        <p style="font-size: 0.75em; margin-top: 10px;">Na razie uÅ¼ywamy <code>public</code> - Å¼eby byÅ‚o
                            podobnie do struktury</p>
                    </div>
                </section>

                <!-- 8. Dodajemy pierwszÄ… metodÄ™ -->
                <section>
                    <h2>Dodajemy pierwszÄ… metodÄ™</h2>
                    <pre><code class="cpp" data-trim>
class Point {
public:
    int x;
    int y;
    
    void print() {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};
        </code></pre>
                    <ul style="font-size: 0.85em; margin-top: 20px;">
                        <li>Metoda to funkcja "naleÅ¼Ä…ca" do klasy</li>
                        <li>MoÅ¼e korzystaÄ‡ z pÃ³l <code>x</code> i <code>y</code></li>
                        <li>WywoÅ‚ujemy jÄ… na obiekcie: <code>p1.print()</code></li>
                    </ul>
                </section>

                <!-- 9. UÅ¼ywanie klasy -->
                <section>
                    <h2>UÅ¼ywanie klasy</h2>
                    <pre><code class="cpp" data-trim>
int main() {
    Point p1;
    p1.x = 10;
    p1.y = 20;
    p1.print();  // (10, 20)
    
    Point p2;
    p2.x = 5;
    p2.y = 15;
    p2.print();  // (5, 15)
    
    return 0;
}
        </code></pre>
                    <p style="font-size: 0.85em; margin-top: 20px;">
                        KaÅ¼dy obiekt ma wÅ‚asne wartoÅ›ci <code>x</code> i <code>y</code>
                    </p>
                </section>

                <!-- 10. Ä†wiczenie praktyczne 1 (WOLNO!) -->
                <section>
                    <h2>Ä†wiczenie praktyczne 1</h2>
                    <a href="https://classroom.github.com/a/moiVpWpi">LINK</a>
                    <div
                        style="text-align: left; padding: 20px; background: rgba(46, 204, 113, 0.1); border-radius: 10px;">
                        <h3 style="font-size: 1em; color: #2ecc71;">Zadanie:</h3>
                        <ul style="font-size: 0.85em; line-height: 1.8;">
                            <li>Napisz klasÄ™ <code>Point</code></li>
                            <li>Pola public: <code>x</code>, <code>y</code> (typu int)</li>
                            <li>Metoda: <code>print()</code> wyÅ›wietlajÄ…ca punkt w formacie <code>(x, y)</code></li>
                            <li>StwÃ³rz 2-3 obiekty i wyÅ›wietl ich wartoÅ›ci</li>
                        </ul>

                    </div>
                </section>
            </section>

        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
        });
    </script>

</body>

</html>