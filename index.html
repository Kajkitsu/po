<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Programowanie Obiektowe</title>

	<meta name="description" content="PO LAB">
	<meta name="author" content="Norbert Waszkowiak">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
	<style>
		.row {
			display: flex;
		}

		.column {
			flex: 50%;
			padding: 10px;
		}
	</style>
	<style>
		.small-font pre {
			font-size: 13px;
			/* Zmniejszenie czcionki */
			margin-left: 0;
			/* Usunięcie marginesu z lewej strony */
			white-space: pre-wrap;
			/* Zapobieganie przepełnieniu tekstu */
		}
	</style>

</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section data-background-gradient="linear-gradient(45deg, #33, #6754e8)">
				<section style="text-align: left;" data-auto-animate id="waszkowiak"
						 data-background-gradient="linear-gradient(45deg, #33, #6754e8)">
					<h2>Programowanie obiektowe</h2>
					<br slyle="height: 600px;" />
					<p style="text-align: left;">por. mgr inż. Norbert Waszkowiak</p>
					<small>nr tel.: 261 839 060</small>
					<br />
					<small>e-mail: norbert.waszkowiak@wat.edu.pl</small>
					<br />
					<small>pomieszczenie: bud. 100 pok. 254B</small>
					<br />
					<small>konsultacje online i stacjanarnie: po wcześniejszym umówieniu</small>
					<br />
				</section>
			</section>
			<section data-background-gradient="linear-gradient(37deg, #2b4a9e, #71a832)">

				<!-- Tytuł -->
				<section data-auto-animate>
					<h2>Powtórka: Tablice i wskaźniki w C++</h2>
				</section>

				<!-- Tablice -->
				<section data-auto-animate>
					<h2>Tablica </h2>
					<p class="fragment">Tablica = pudełko z przegródkami</p>
					<ul>
						<li class="fragment">Każda przegródka ma numer (indeks)</li>
						<li class="fragment">Wszystkie elementy są tego samego typu</li>
					</ul>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
int A[5] = {1, 2, 3, 4, 5};
cout << A[0]; // wypisze 1
    </code></pre>
				</section>

				<!-- Inicjalizacja i modyfikacja -->
				<section data-auto-animate>
					<h2>Praca z tablicami</h2>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
int A[5];      // puste pudełko
A[0] = 27;     // wpisanie wartości
A[1] = 10;
    </code></pre>
					<p class="fragment">Do wszystkich elementów najłatwiej dostać się pętlą:</p>
					<pre class="fragment" style="font-size: 16px"><code class="hljs cpp" data-trim>
for (int i = 0; i < 5; i++) {
    cout << A[i] << " ";
}
    </code></pre>
				</section>

				<!-- Wskaźnik -->
				<section data-auto-animate>
					<h2>Wskaźnik </h2>
					<p class="fragment">Wskaźnik = karteczka z adresem</p>
					<ul>
						<li class="fragment">Nie przechowuje wartości, tylko adres</li>
						<li class="fragment">Dzięki temu możemy dotrzeć do danych</li>
					</ul>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
int a = 10;
int *p = &a;   // wskaźnik na 'a'
cout << *p;   // dereferencja → 10
    </code></pre>
				</section>

				<!-- Po co wskaźniki -->
				<section data-auto-animate>
					<h2>Po co wskaźniki?</h2>
					<ul>
						<li class="fragment">Dostęp do pamięci dynamicznej (tworzonej w trakcie programu)</li>
						<li class="fragment">Przekazywanie dużych tablic do funkcji bez kopiowania</li>
						<li class="fragment">Tworzenie struktur danych (listy, drzewa, grafy)</li>
					</ul>
				</section>

				<!-- Dynamiczna alokacja -->
				<section data-auto-animate>
					<h2>Dynamiczna tablica</h2>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
int *p = new int[5]; // 5 elementów na stercie

for(int i = 0; i < 5; i++) {
    p[i] = i * 10;
}
    </code></pre>
					<p class="fragment">Pamięć trzeba potem zwolnić:</p>
					<pre class="fragment" style="font-size: 16px"><code class="hljs cpp" data-trim>
delete[] p;
    </code></pre>
				</section>

				<!-- Wskaźniki i struktury -->
				<section data-auto-animate>
					<h2>Wskaźniki i struktury</h2>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
struct Rectangle {
    int length;
    int breadth;
};

Rectangle *ptr = new Rectangle;
ptr->length = 10;
ptr->breadth = 20;
delete ptr;
    </code></pre>
				</section>

				<!-- Funkcje -->
				<section data-auto-animate>
					<h2>Wskaźnik jako argument</h2>
					<p>Przekazanie adresu do funkcji → zmiana wartości w oryginale</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
void updateValue(int *pValue) {
    *pValue = 100;
}

int value = 5;
updateValue(&value);
cout << value; // 100
    </code></pre>
				</section>

				<!-- Quiz -->
				<section data-auto-animate>
					<h2>Quiz</h2>
					<ul>
						<li class="fragment">Tablica to…</li>
						<li class="fragment">Wskaźnik przechowuje…</li>
						<li class="fragment">Jak zwolnić pamięć po new?</li>
					</ul>
				</section>

				<!-- Ćwiczenie -->
				<section data-auto-animate>
					<h2>Ćwiczenie</h2>
					<p>Napisz program, który:</p>
					<ul>
						<li class="fragment">Tworzy tablicę 5 ocen</li>
						<li class="fragment">Wypisuje je na ekranie</li>
						<li class="fragment">Oblicza średnią</li>
					</ul>
				</section>

				<!-- Zaawansowane -->
				<section data-auto-animate>
					<h2>Co dalej?</h2>
					<p class="fragment">Na studiach: listy, drzewa, grafy </p>
					<p class="fragment">Na razie – skupiamy się na podstawach</p>
				</section>

			</section>

			<section data-background-gradient="linear-gradient(37deg, #2b4a9e, #71a832)">
				<section>
					<h2>Klasa i obiekt dla zielonych</h2>
				</section>
				<section>
					<h2>Co to jest Klasa i Obiekt?</h2>
					<p>
						Klasa to szablon lub projekt, który określa, jakie właściwości (dane) i działania
						(funkcje/metody) będzie miał obiekt.
					</p>
					<p>
						Obiekt to konkretna instancja klasy, zawierająca rzeczywiste dane i umożliwiająca wykonanie
						zdefiniowanych działań.
					</p>
				</section>
				<section>
					<h2>Implementacja</h2>

					<div class="row">
						<div class="column">
							<h3>Python:</h3>
							<pre style="font-size: 16px;"><code class="python">
class Author:
	def __init__(self, name, surname):
		self.name = name
		self.surname = surname

# tworzenie obiektu 'author1'
author1 = Author("Jan", "Kowalski")
												</code></pre>
						</div>

						<div class="column">
							<h3>C++:</h3>
							<pre style="font-size: 16px;"><code class="cpp">class Author {
public:
    std::string name;
    std::string surname;
};

// tworzenie obiektu 'author1'
Author author1;
author1.name = "Jan";
author1.surname = "Kowalski";
                    </code></pre>
						</div>
					</div>
				</section>
				<section>
					<h2>Klasy vs Obiekty - Przykład</h2>
					<p>Klasa Author określa, że każdy autor ma imię i nazwisko.</p>
					<p>Obiekt klasy Author, np. author1, ma konkretne imię i nazwisko.</p>
				</section>
				<section>
					<h2>Implementacja</h2>

					<div class="row">
						<div class="column">
							<h3>Python:</h3>
							<pre style="font-size: 16px;"><code class="python"># Klasa Author
class Author:
	def __init__(self, name, surname):
		self.name = name
		self.surname = surname

# Obiekt author1 klasy Author
author1 = Author("Jan", "Kowalski")
							</code></pre>
						</div>

						<div class="column">
							<h3>C++:</h3>
							<pre style="font-size: 16px;"><code class="cpp">
// Klasa Author
class Author {
public:
	std::string name;
	std::string surname;
};

// Obiekt author1 klasy Author
Author author1;
author1.name = "Jan";
author1.surname = "Kowalski";
							</code></pre>
						</div>
					</div>
				</section>
				<section>
					<h2>Zmienne i Typy w Programowaniu</h2>
					<p style="font-size: 0.75em;">
						Typ zmiennej określa, jakiego rodzaju wartości może przechowywać
						zmienna.
					</p>
					<p style="font-size: 0.75em;">Klasa jest jak niestandardowy typ danych, który sami definiujemy.</p>
					<p style="font-size: 0.75em;">Obiekt to zmienna, która przechowuje dane typu klasy.</p>
					<pre><code class="cpp">// int to typ, a number to zmienna
int number = 5;

// Author to klasa (typ), a author1 to obiekt (zmienna)
Author author1;
author1.name = "Jan";
author1.surname = "Kowalski";					
												</code></pre>
				</section>
				<section>
					<h2>Po co nam ta obiektowość?</h2>
					<p style="font-size: 0.85em;">
						Programowanie obiektowe (OOP) umożliwia hermetyzację danych, co
						zapewnia bezpieczeństwo i integralność informacji.
					</p>
					<p style="font-size: 0.85em;">
						Dzięki dziedziczeniu, OOP wspiera ponowne użycie i rozszerzalność
						kodu, a polimorfizm pozwala na dynamiczniejsze zachowania.
					</p>
					<p style="font-size: 0.85em;">
						Dla porównania, struktury danych są bardziej podstawowe i nie oferują
						tych zaawansowanych funkcji.
					</p>
					<p style="font-size: 0.85em;">
						OOP jest kluczowe w tworzeniu złożonych, łatwych w utrzymaniu
						systemów, podczas gdy struktury są odpowiednie dla prostych zadań.
					</p>
				</section>
				<section>
					<h2>Struktura vs Klasa dla Samochodu</h2>
					<div class="row">
						<div class="column small-font">
							<h3>Struktura:</h3>
							<pre style="max-width: 600px;"><code class="python">// Definicja struktury Car
struct Car {
	std::string brand;
	int year;
};

int main() {
	// Tworzenie i inicjalizacja obiektu Car
	Car myCar;
	myCar.brand = "Toyota";
	myCar.year = 2020;

	// Wyświetlanie danych
	std::cout << "Samochód: " << myCar.brand << 
	  ", Rok: " << myCar.year << std::endl;

	return 0;
}
							</code></pre>
						</div>

						<div class="column small-font">
							<h3>Klasa:</h3>
							<pre style="max-width: 600px;">
							<code class="cpp">// Definicja klasy Car
class Car {
private:
	std::string brand;
	int year;

public:
	Car(const std::string &brand, int year)
		: brand(brand), year(year) {}

	void print() const {
		std::cout << "Samochód: " << brand << 
		  ", Rok: " << year << std::endl;
	}
};

int main() {
	// Tworzenie i inicjalizacja obiektu Car
	Car myCar("Toyota", 2020);

	// Wywołanie metody print
	myCar.print();

	return 0;
}	
							</code></pre>
						</div>
					</div>
				</section>
				<section>
					<h2>Różnice i Kiedy Używać</h2>

					<div class="row">
						<div class="column small-font">
							<h3>Struktury:</h3>
							<p style="font-size: 0.85em;"></p>Proste przechowywanie danych.</p>
							<p style="font-size: 0.85em;"></p>Brak hermetyzacji; wszystkie pola są publiczne i dostępne
							bezpośrednio.</p>
							<p style="font-size: 0.85em;"></p>Brak metod; służy głównie jako kontener danych.</p>
						</div>
						<div class="column small-font">
							<h3>Klasy:</h3>
							<p style="font-size: 0.85em;">Zawiera metody (np. print) do interakcji z danymi.</p>
							<p style="font-size: 0.85em;">
								Hermetyzuje dane; pola są prywatne, a dostęp do nich jest
								kontrolowany przez publiczne metody.
							</p>
							<p style="font-size: 0.85em;">
								Idealne do bardziej złożonych zastosowań, gdzie wymagana jest
								kontrola i rozszerzalność.
							</p>
						</div>
					</div>
				</section>
				<section>
					<h2>"Profesjonalna" klasa</h2>
					<pre style="font-size: 16px"><code class="hljs cpp"
											 data-trim
											 data-line-numbers>
					<script type="text/template">
#include <iostream>
#include <string>
#include <vector>
#include <map>

class Player {
private:
	std::string name;
	int health;
	int mana;
	std::map<std::string, int> inventory; // Przechowuje przedmioty i ich ilość
	std::vector<std::string> skills; // Lista umiejętności

public:
	Player(const std::string &name, int health, int mana)
		: name(name), health(health), mana(mana) {}

	void takeDamage(int amount) {
		health -= amount;
		if (health < 0) health = 0;
	}

	void useItem(const std::string &item) {
		if (inventory[item] > 0) {
			// Logika używania przedmiotu
			inventory[item]--;
		} else {
			std::cout << "Nie masz " << item << std::endl;
		}
	}

	void learnSkill(const std::string &skill) {
		skills.push_back(skill);
	}

	void printStatus() const {
		std::cout << "Gracz: " << name << "\n"
					<< "Zdrowie: " << health << "\n"
					<< "Mana: " << mana << std::endl;
	}

	// Dodatkowe metody...
};

int main() {
	Player hero("Arthas", 100, 50);
	hero.learnSkill("Fireball");
	hero.takeDamage(20);
	hero.useItem("Health Potion");
	hero.printStatus();

	return 0;
}		
</script></code></pre>
				</section>
			</section>


			<section id="start" data-background-gradient="linear-gradient(13deg, #3a6935, #b5b170)">
				<section data-auto-animate>
					<h2>Wstęp do programowania obiektowego</h2>
				</section>
				<section data-auto-animate>
					<h3>Podstawowe pojęcia</h3>
					<small>
						Jedną z barier w zrozumieniu techniki obiektowej jest specjalistyczne słownictwo, którym ta
						technika obrosła.
						W rzeczywistości można tym żargonem posługiwać się skutecznie stosując zaledwie kilka pojęć:
					</small>
					<small>
						<ul>
							<li><b>obiekt, instancja</b></li>
							<li><b>metoda</b></li>
							<li><b>klasa</b></li>
							<li><b>podklasa, (typ pochodny) (klasa dolna)</b> </li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Podstawowe pojęcia</h3>
					<small>
						<ul>
							<li>
								<b>obiekt, instancja</b> - to konkretny egzemplarz lub wystąpienie struktury danych
								zdefiniowanej w
								programie. Może zawierać dane (znane również
								jako właściwości lub atrybuty) oraz metody (funkcje działające na tych danych). Obiekt
								może
								reprezentować rzeczywiste
								lub abstrakcyjne elementy. Na przykład, obiekt "samochód" może mieć atrybuty takie jak
								kolor, marka, rok produkcji i
								metody takie jak "uruchom silnik" czy "zatrzymaj się".
							</li>
							<li><b>metoda</b></li>
							<li><b>klasa</b></li>
							<li><b>podklasa, (typ pochodny) (klasa dolna)</b> </li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Podstawowe pojęcia</h3>
					<small>
						<ul>
							<li><b>obiekt, instancja</b></li>
							<li>
								<b>metoda, (funkcja składowa klasy)</b> - a jest funkcją związaną z danym obiektem.
								Stanowi
								zachowanie obiektu, czyli co może on zrobić. Metody umożliwiają
								manipulację danymi obiektu i wykonują operacje na tych danych.
							</li>
							<li><b>klasa</b></li>
							<li><b>podklasa, (typ pochodny) (klasa dolna)</b> </li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Podstawowe pojęcia</h3>
					<small>
						<ul>
							<li><b>obiekt, instancja</b></li>
							<li><b>metoda</b></li>
							<li>
								<b>klasa</b> - to szablon lub wzorzec, na podstawie którego tworzone są obiekty. Klasa
								definiuje właściwości (atrybuty) oraz metody
								(funkcje) obiektów. Może być traktowana jako abstrakcyjny pojemnik, który definiuje
								cechy
								wspólne dla wszystkich
								instancji (obiektów), które będą tworzone na jej podstawie.
							</li>
							<li><b>podklasa, (typ pochodny) (klasa dolna)</b></li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Podstawowe pojęcia</h3>
					<small>
						<ul>
							<li><b>obiekt, instancja</b></li>
							<li><b>metoda</b></li>
							<li><b>klasa</b></li>
							<li>
								<b>podklasa, (typ pochodny) (klasa dolna)</b> to klasa, która dziedziczy cechy (atrybuty
								i metody) po innej
								klasie nadrzędnej, zwanej klasą bazową lub nadrzędną.
								Podklasa ma dostęp do cech klasy nadrzędnej i może dodatkowo definiować swoje własne
								atrybuty i metody. W ten
								sposób
								następuje rozszerzenie funkcjonalności klasy nadrzędnej.
							</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Co to jest PARADYGMAT?</h3>
					<small>
						<ul>
							<p>
								<b>Paradygmat</b> - zbiór wszystkich pojęć i teorii stanowiących podstawy danej nauki.
								Jest
								rodzajem
								uzgodnienia pomiędzy twórcami badań na zasadzie jego zgodności z dotychczasową wiedzą i
								kierunkiem jej
								rozwoju.
							</p>
							Musi być:
							<li>
								<ul>
									<li>Spójny logicznie i pojęciowo.</li>
									<li>Możliwie najprostszy czyli w formie definicji podstawowej.</li>
									<li>
										Mieć cechy operacyjności czyli możliwego wykorzystania do budowania teorii
										szczegółowych.
									</li>
								</ul>
							</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Paradygmaty programowania obiektowego</h3>
					<ul>
						<li><b>Abstrakcja</b></li>
						<li><b>Dziedziczenie</b></li>
						<li><b>Polimorfizm</b></li>
						<li><b>Enkapsulacja</b></li>
					</ul>
				</section>
				<section data-auto-animate>
					<h3>Paradygmaty programowania obiektowego</h3>
					<ul>
						<li>
							<b>Abstrakcja</b> - polega na wyodrębnieniu złożonego systemu jego najważniejszych cech i
							pominięciu tych,
							które nie są istotne dla danego problemu.
						</li>
						<li><b>Dziedziczenie</b></li>
						<li><b>Polimorfizm</b></li>
						<li><b>Enkapsulacja</b></li>
					</ul>
				</section>
				<section data-auto-animate>
					<h3>Paradygmaty programowania obiektowego</h3>
					<ul>
						<li><b>Abstrakcja</b></li>
						<li>
							<b>Dziedziczenie</b> - umożliwia tworzenie nowych klas na podstawie już istniejących,
							dziedzicząc po nich
							ich cechy (atrybuty i metody).
						</li>
						<li><b>Polimorfizm</b></li>
						<li><b>Enkapsulacja</b></li>
					</ul>
				</section>
				<section data-auto-animate>
					<h3>Paradygmaty programowania obiektowego</h3>
					<ul>
						<li><b>Abstrakcja</b></li>
						<li><b>Dziedziczenie</b></li>
						<li>
							<b>Polimorfizm</b> - umożliwia wykorzystanie jednej nazwy metody w różnych klasach, co
							pozwala na bardziej
							elastyczne i uniwersalne programowanie.
						</li>
						<li><b>Enkapsulacja</b></li>
					</ul>
				</section>
				<section data-auto-animate>
					<h3>Paradygmaty programowania obiektowego</h3>
					<ul>
						<li><b>Abstrakcja</b></li>
						<li><b>Dziedziczenie</b></li>
						<li><b>Polimorfizm</b></li>
						<li>
							<b>Enkapsulacja</b> - polega na ukrywaniu szczegółów implementacyjnych klasy i udostępnianiu
							tylko jej
							interfejsu, co zwiększa bezpieczeństwo i ułatwia utrzymanie kodu.
						</li>
					</ul>
				</section>
				<section data-auto-animate>
					<h3>O obiektach</h3>
					<small>
						Koncepcje programowania obiektowego zostały pokazane w języku Simula. Zbudowano go do
						symulacji złożonych systemów i
						jako podstawę konstrukcji języka przyjęto, że każdy obiekt rzeczywisty charakteryzują jego
						zachowania.
					</small>
					<b>
						<p style="margin: 10px;">
							Spróbowano więc tak układać komunikację pomiędzy procedurami (modułami)
							i danymi aby były podporządkowane zachowaniom
							symulowanych obiektów.
						</p>
					</b>
					<small>
						Obiekt był „pakunkiem” zawierającym procedury i dane powiązane razem tak, aby określały jego
						możliwe zachowania.
						Procedury w podejściu obiektowym nazywa się metodami. W odniesieniu do danych stosujemy nazwę
						zmienne bo ich wartość
						może się zmieniać w czasie. Nazywamy metody i zmienne atrybutami obiektu.
					</small>
				</section>
				<section data-auto-animate>
					<h3>O obiektach</h3>
					<small>
						Rozważmy dla ilustracji jak moglibyśmy programować przenośnik fabryczny. Może on wykonywać
						rozmaite czynności jak
						przemieszczanie się, ładowanie, rozładowanie. Musi przechowywać informacje o nośności,
						rozmiarach palety, prędkości,
						aktualnego położenia, aktualnego ładunku, itp. Tak więc realny obiekt „coś robi” i „coś
						wie”.
					</small>
					<b>
						<p style="margin: 10px;">
							Czynności obiektu opiszemy jako metody, a wielkości charakterystyczne,
							którymi obiekt się posługuje wykonując czynności,
							jako zmienne.
							CZYNNOŚCI OBIEKTU => METODY
							</br>
							DANE DO METOD => ZMIENNE OBIEKTU
						</p>
					</b>
					<small>
						Obiekt jest idealnym modułem programu. Tworzy własny, zamknięty świat. Wszystko co „wie”
						wyrażają jego zmienne. Wszystko
						co może robić wyrażają jego metody.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<small>Klasa jest nowym typem zmiennej w programie . Definiujemy ją jako:</small>
					<pre style="font-size: 16px" data-id="code-animation">
<code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
class MyClass {
//
// ...
//ciało klasy
};
</script>
</code>
</pre>
					<small>Jeśli chcemy stworzyć konkretny element czyli obiekt tej klasy to zapisujemy :</small>
					<pre style="font-size: 16px" data-id="code-animation">
<code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
MyClass myObject;
</script>
</code>
</pre>
					<small>
						Wtedy w pamięci operacyjnej powstanie obiekt klasy <b>MyClass</b>, który się nazywa
						<b>myObject</b>. Przypomina zapis: <b>int a;</b>
						ale nie jest całkowicie z nim równoważne. Jest znacznie bogatsze w treści i
						możliwościach.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<small>
						Kiedy już mamy typ <b>MyClass</b>, to możemy utworzyć obiekt pochodny, na przykład wskaźnik
						do obiektu z <b>MyClass</b>:
					</small>
					<pre style="font-size: 16px" data-id="code-animation">
					<code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
MyClass *pointer;
				</script>
				</code>
				</pre>
					<small>
						albo:
					</small>

					<pre style="font-size: 16px" data-id="code-animation">
					<code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
MyClass &addObject = myObject;
</script>
									</code>
									</pre>

					<small>
						Utworzy to wskaźnik do obiektów klasy <b>MyClass</b> (czyli do każdego obiektu, który
						utworzymy w tej klasie) albo
						referencje do wybranego obiektu klasy <b>MyClass</b> o nazwie <b>myObject</b>, której
						przypiszemy
						własności <b>myObject</b> w trybie dostępu
						do adresu.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code class="hljs cpp" data-trim data-line-numbers><script type="text/template">
	#include <iostream>
	#include <cstring>
	 
	class Card {
	public:
	    char color[80]{};
	    int value;
	    
	    Card(char* color, int value);
	 
	    void print();
	};
	 
	int main() {
	    Card k1("czarna", 5), k2("czerwona", 8);
	    
	    k1.print();
	    k2.print();
	    
	    strcpy(k1.color, "czarno-czerwona");
	    k2.value = 28;
	    
	    std::cout << std::endl;
	    
	    k1.print();
	    k2.print();

	    return 0;
	}
	 
	Card::Card(char* color, int value) {
					strcpy(this->color, color);
					this->value = value;
	}
	void Card::print() {
					std::cout << "Color: " << color << ", Value: " << value << std::endl;
	}
				</script>
													</code>
													</pre>
					<small>
						Przykład: <em>
							program w C++, który przechowuje informację o kolorze i wartości punktowej
							karty do gry. Wykorzystuje klasę o
							nazwie Card.
						</em>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="4-12|9"><script type="text/template">
					#include <iostream>
					#include <cstring>
					 
					class Card {
					public:
					    char color[80]{};
					    int value;
					    
					    Card(char* color, int value);
					 
					    void print();
					};
					 
					int main() {
					    Card k1("czarna", 5), k2("czerwona", 8);
					    
					    k1.print();
					    k2.print();
					    
					    strcpy(k1.color, "czarno-czerwona");
					    k2.value = 28;
					    
					    std::cout << std::endl;
					    
					    k1.print();
					    k2.print();
				
					    return 0;
					}
					 
					Card::Card(char* color, int value) {
									strcpy(this->color, color);
									this->value = value;
					}
					void Card::print() {
									std::cout << "Color: " << color << ", Value: " << value << std::endl;
					}
								</script>
																	</code>
																	</pre>
					<small>
						<ul>
							<li>
								Opis klasy zawsze umieszczamy w nawiasie klamrowym, po którym jest średnik, tak, jak w
								normalnych
								deklaracjach typów
								zmiennej.
							</li>
							<li>
								Konstruktor obiektu Karta, o <b>ZAWSZE nazwie takiej samej jak klasa</b> jest w obszarze
								opisu klasy
								tylko deklarowany i
								podawana jest lista jego argumentów. Nie podajemy typu pomimo, że jest funkcją (C++,
								Javie, C#, PHP 4 iin.) - jest tometoda o nazwie zgodnej z nazwą klasy.
							</li>
						</ul>

					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="14-29|15|9"><script type="text/template">
					#include <iostream>
					#include <cstring>
					 
					class Card {
					public:
					    char color[80]{};
					    int value;
					    
					    Card(char* color, int value);
					 
					    void print();
					};
					 
					int main() {
					    Card k1("czarna", 5), k2("czerwona", 8);
					    
					    k1.print();
					    k2.print();
					    
					    strcpy(k1.color, "czarno-czerwona");
					    k2.value = 28;
					    
					    std::cout << std::endl;
					    
					    k1.print();
					    k2.print();
				
					    return 0;
					}
					 
					Card::Card(char* color, int value) {
									strcpy(this->color, color);
									this->value = value;
					}
					void Card::print() {
									std::cout << "Color: " << color << ", Value: " << value << std::endl;
					}
								</script>
																	</code>
																	</pre>
					<small>
						Blok main(), w którym powołane są dwa obiekty klasy <b>Card</b> o nazwach k1 i
						k2. Obiekty mają
						argumenty takie, jakie zadeklarowano w konstruktorze, czyli zmienna typu char oraz zmienna
						integer.
					</small>
					<small>
						WNIOSEK: deklaracja
						konstruktora musi zawierać to, co potem jest potrzebne w funkcjonowaniu obiektów konstruowanych
						w klasie. W każdym
						obiekcie k1 oraz k2 wartości zmiennych deklarowanych są zainicjowane poprzez podanie konkretnych
						wartości. Jest to
						przykład przypisania przez wartość.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="31-34|31|32-33"><script type="text/template">
					#include <iostream>
					#include <cstring>
					 
					class Card {
					public:
					    char color[80]{};
					    int value;
					    
					    Card(char* color, int value);
					 
					    void print();
					};
					 
					int main() {
					    Card k1("czarna", 5), k2("czerwona", 8);
					    
					    k1.print();
					    k2.print();
					    
					    strcpy(k1.color, "czarno-czerwona");
					    k2.value = 28;
					    
					    std::cout << std::endl;
					    
					    k1.print();
					    k2.print();
				
					    return 0;
					}
					 
					Card::Card(char* color, int value) {
									strcpy(this->color, color);
									this->value = value;
					}
					void Card::print() {
									std::cout << "Color: " << color << ", Value: " << value << std::endl;
					}
								</script>
																	</code>
																	</pre>
					<small>
						Definicja konstruktora klasy. Najpierw nazwa <b>Card</b>, a potem operator <b>::</b> czyli
						operator zakresu.
						Teraz już na liście argumentów formalnych podane są nazwy argumentów <b>color</b> oraz
						<b>value</b>. Po liście argumentów formalnych może (
						ale nie musi) pojawić się dwukropek i lista inicjalizująca wartości argumentów, czyli argumenty
						początkowe. Następnie w
						nawiasie klamrowym, po którym nie ma średnika, umieszczamy ciało konstruktora. W ciele
						konstruktora mamy kopiowanie
						łańcucha nazwy koloru karty z <b>color</b> do <b>this->color</b>.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="35-37|17-18,25-26|35|36"><script type="text/template">
					#include <iostream>
					#include <cstring>
					 
					class Card {
					public:
					    char color[80]{};
					    int value;
					    
					    Card(char* color, int value);
					 
					    void print();
					};
					 
					int main() {
					    Card k1("czarna", 5), k2("czerwona", 8);
					    
					    k1.print();
					    k2.print();
					    
					    strcpy(k1.color, "czarno-czerwona");
					    k2.value = 28;
					    
					    std::cout << std::endl;
					    
					    k1.print();
					    k2.print();
				
					    return 0;
					}
					 
					Card::Card(char* color, int value) {
									strcpy(this->color, color);
									this->value = value;
					}
					void Card::print() {
									std::cout << "Color: " << color << ", Value: " << value << std::endl;
					}
								</script>
																	</code>
																	</pre>
					<small>
						Definicja funkcji własnej klasy <b>Card</b> o nazwie <b>print()</b>. Jest ona wykonywana w
						bloku <b>main()</b> na rzecz obiektów <b>k1</b> oraz <b>k2</b>.
						To, że jest ona funkcją własną klasy <b>Card</b> wskazuje nazwa klasy rozpoczynająca definicję i
						operator zakresu :: , który
						wskazuje, że funkcja działa w całym zakresie ważności obiektów klasy. Funkcja <b>print()</b>
						wykonuje na ekranie wypisanie nazwy
						koloru karty i jej wartości punktowej.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="20|21"><script type="text/template">
					#include <iostream>
					#include <cstring>
					 
					class Card {
					public:
					    char color[80]{};
					    int value;
					    
					    Card(char* color, int value);
					 
					    void print();
					};
					 
					int main() {
					    Card k1("czarna", 5), k2("czerwona", 8);
					    
					    k1.print();
					    k2.print();
					    
					    strcpy(k1.color, "czarno-czerwona");
					    k2.value = 28;
					    
					    std::cout << std::endl;
					    
					    k1.print();
					    k2.print();
				
					    return 0;
					}
					 
					Card::Card(char* color, int value) {
									strcpy(this->color, color);
									this->value = value;
					}
					void Card::print() {
									std::cout << "Color: " << color << ", Value: " << value << std::endl;
					}
								</script>
																	</code>
																	</pre>
					<small>
						Kolor obiektu k1 jest modyfikowany funkcją strcpy. W składni wymienia się nazwę obiektu, a po
						kropce nazwę
						argumentu zmienianego. Następnie modyfikowany jest argument value obiektu k2 poprzez zwykłą
						operację przypisania nowej
						wartości.
					</small>
					<small>
						WNIOSEK: Klasa a obiekt
						Widać, że klasa nie definiuje konkretnych obiektów tylko ich typy!!! Jest ona typem obiektu jako
						abstrakcyjnej zmiennej,
						a nie obiektem lub zbiorem obiektów (C++, Java). Obiekty k1 i k2 w przykładzie mają typ
						Karta.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Klasy obiektów</h3>
					<pre style="font-size: 16px" data-id="code-animation">
					<code class="hljs java" data-trim data-line-numbers><script type="text/template">
import java.util.*;

public class Card {
    private String color;
    private int value;
    
    public Card(String color, int value) {
        this.color = color;
        this.value = value;
    }
    
    public void print() {
        System.out.println("Color: " + color + ", Value: " + value);
    }
    
    public static void main(String[] args) {
        Card k1 = new Card("czarna", 5);
        Card k2 = new Card("czerwona", 8);
        
        k1.print();
        k2.print();
        
        k1.color = "czarno-czerwona";
        k2.value = 28;
        
        System.out.println();
        
        k1.print();
        k2.print();
    }
}
												</script>
																					</code>
																					</pre>
					<small>Przykład w języku Java</small>
				</section>
				<footer style="position: absolute; bottom: 0; width: 100%;">
					<small style="font-size: 9px;">
						Materiały do tej prezentacji zostały opracowane w oparciu o skrót materiałów wykładowych
						przedmiotu
						Programowanie
						Obiektowe prowadzonego na WAT. Autor materiałów źródłowych: prof. Andrzej Walczak<br>
						Copyrights Military University of Technology in Warsaw
					</small>
				</footer>
			</section>
			<section id="start" data-background-gradient="linear-gradient(13deg, #3a6935, #b5b170)">

				<!-- Tytuł -->
				<section data-auto-animate>
					<h2>Wstęp do programowania obiektowego cz.2</h2>
					<p class="fragment">Konstruktory, destruktory, this, polimorfizm</p>
				</section>

				<!-- Po co konstruktor -->
				<section data-auto-animate>
					<h3>Konstruktor — rola</h3>
					<ul>
						<li class="fragment">Automatycznie inicjalizuje obiekt w chwili tworzenia.</li>
						<li class="fragment">Nosi tę samą nazwę co klasa i nie ma typu zwrotnego.</li>
						<li class="fragment">Może być przeciążany (różne listy parametrów).</li>
						<li class="fragment">Może istnieć konstruktor domyślny (bez parametrów).</li>
					</ul>
				</section>

				<!-- Listy inicjalizacyjne -->
				<section data-auto-animate>
					<h3>Listy inicjalizacyjne</h3>
					<p class="fragment">Preferowany sposób ustawiania pól w C++: przed wejściem do ciała konstruktora.</p>
<pre class="fragment" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers="1-7|3-6">
class Card {
  std::string color;
  int value;
public:
  Card() : color("czarna"), value(4) {}
  Card(std::string c, int v) : color(std::move(c)), value(v) {}
};
</code></pre>
				</section>

				<!-- Przeciążanie konstruktorów i użycie -->
				<section data-auto-animate>
					<h3>Przeciążenie i użycie konstruktorów</h3>
<pre data-id="code-animation" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers="1-8|10-16">
class Card {
  std::string color; int value;
public:
  Card() : color("czarna"), value(4) {}
  Card(std::string c) : color(std::move(c)), value(4) {}
  Card(std::string c, int v) : color(std::move(c)), value(v) {}
  void print() const { std::cout << color << " " << value << "\n"; }
};

int main() {
  Card k1;                 // domyślny
  Card k2("czerwona");     // 1 parametr
  Card k3("zielona", 10);  // 2 parametry
  k1.print(); k2.print(); k3.print();
}
</code></pre>
				</section>

				<!-- Konstruktor domyślny i wartości domyślne parametrów -->
				<section data-auto-animate>
					<h3>Konstruktor domyślny i parametry domyślne</h3>
<pre style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers="1-9">
class Card {
  std::string color; int value;
public:
  // jeden konstruktor z parametrami domyślnymi
  Card(std::string c = "czarna", int v = 4)
    : color(std::move(c)), value(v) {}
};
</code></pre>
				</section>

				<!-- this -->
				<section data-auto-animate>
					<h3>this — wskaźnik do bieżącego obiektu</h3>
<pre class="fragment" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers="1-7|4-6">
class Card {
  std::string color; int value;
public:
  void setValue(int v) {
    this->value = v;           // to samo co: value = v;
  }
};
</code></pre>
				</section>

				<!-- Destruktor i reguła trzech -->
				<section data-auto-animate>
					<h3>Destruktor i reguła trzech</h3>
<pre class="fragment" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
class Buffer {
  size_t n; int* data;
public:
  Buffer(size_t n): n(n), data(new int[n]{}) {}
  Buffer(const Buffer& other): n(other.n), data(new int[n]) { std::copy(other.data, other.data+n, data); }
  Buffer& operator=(const Buffer& other) {
    if(this!=&other){ int* tmp=new int[other.n]; std::copy(other.data, other.data+other.n, tmp);
      delete[] data; data=tmp; n=other.n; }
    return *this;
  }
  ~Buffer(){ delete[] data; }
};
</code></pre>
				</section>

				<!-- Pola i metody statyczne -->
				<section data-auto-animate>
					<h3>Składowe statyczne</h3>
<pre class="fragment" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers="1-10|12-17">
class Counter {
public:
  static int created;
  Counter(){ ++created; }
};
int Counter::created = 0;

int main(){
  Counter a, b, c;
  std::cout << Counter::created; // 3
}
</code></pre>
				</section>

				<!-- Polimorfizm -->
				<section data-auto-animate>
					<h3>Polimorfizm — metoda wirtualna</h3>
<pre data-id="poly" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers="1-4|6-10|12-19">
struct Shape {
  virtual double area() const { return 0.0; }
};
struct Circle : Shape {
  double r;
  Circle(double r): r(r) {}
  double area() const override { return 3.14159*r*r; }
};
int main(){
  Shape s; Circle c(2);
  Shape* p = &c;        // wskaźnik do bazowej
  std::cout << p->area();  // wywoła Circle::area
}
</code></pre>
				</section>

				<!-- Życie obiektu -->
				<section data-auto-animate>
					<h3>Życie obiektu</h3>
					<ul>
						<li class="fragment">Obiekt lokalny: istnieje w obrębie bloku.</li>
						<li class="fragment">Obiekt dynamiczny: utworzony przez <code>new</code>, niszczenie przez <code>delete</code>.</li>
						<li class="fragment">W Javie: sprzątanie wykonuje Garbage Collector.</li>
					</ul>
				</section>

				<!-- Mini-quiz -->
				<section data-auto-animate>
					<h3>Quiz</h3>
					<ul>
						<li class="fragment">Kiedy uruchamia się konstruktor, a kiedy destruktor?</li>
						<li class="fragment">Po co lista inicjalizacyjna?</li>
						<li class="fragment">Czym różni się konstruktor kopiujący od operatora przypisania?</li>
						<li class="fragment">Co daje słowo kluczowe <code>virtual</code>?</li>
						<li class="fragment">Co wskazuje <code>this</code>?</li>
					</ul>
				</section>

				<!-- Ćwiczenie -->
				<section data-auto-animate>
					<h3>Ćwiczenie</h3>
					<p>Napisz klasę <code>Student</code> z polami <code>name</code>, <code>grade</code>:</p>
					<ul>
						<li class="fragment">Trzy konstruktory: domyślny, z nazwą, z nazwą i oceną.</li>
						<li class="fragment">Metoda <code>print()</code> wypisująca dane.</li>
						<li class="fragment">W <code>main()</code> utwórz obiekty i wywołaj <code>print()</code>.</li>
					</ul>
				</section>

				<!-- Podsumowanie -->
				<section data-auto-animate>
					<h3>Podsumowanie</h3>
					<ul>
						<li class="fragment">Konstruktor inicjalizuje obiekt, destruktor sprząta zasoby.</li>
						<li class="fragment">Lista inicjalizacyjna jest preferowana w konstruktorze.</li>
						<li class="fragment">Reguła trzech: konstruktor kopiujący, operator=, destruktor.</li>
						<li class="fragment">Wskaźnik <code>this</code> wskazuje bieżący obiekt.</li>
						<li class="fragment">Polimorfizm przez <code>virtual</code> umożliwia różne implementacje.</li>
						<li class="fragment">Składowe <code>static</code> należą do klasy, nie do obiektu.</li>
					</ul>
				</section>

			</section>





			<section data-background-gradient="linear-gradient(67deg, #749c19, #bf3045)">
				<section>
					<h2>Jak czytać diagramy klas?</h2>
				</section>
				<section data-auto-animate>
					<h3>Diagram klas</h3>
					<img style="max-height: 600px;" src="assets/class_diagram_Zad1.png">
				</section>
				<section data-auto-animate>
					<h3>Jak czytać diagramy klas?</h3>
					<img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
					<small>
						<ul>
							<li>
								<b>Klasy</b>: Prostokąty reprezentują klasy. Nazwa klasy jest umieszczona na górze
								prostokąta.
							</li>
							<li>
								<b>Atrybuty</b>: Poniżej nazwy klasy znajdują się atrybuty (pola, zmienne), które
								przechowują
								dane. Są
								one zazwyczaj oznaczone
								symbolem + dla publicznych lub - dla prywatnych.
							</li>
							<li>
								<b>Metody</b>: Jeszcze niżej umieszczone są metody (funkcje), które definiują zachowanie
								klasy.
								Podobnie jak atrybuty, metody
								mogą być oznaczone jako publiczne (+) lub prywatne (-).
							</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Jak czytać diagramy klas?</h3>
					<img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
					<small>
						<ul>
							<li>
								<b>Relacje</b>: Linie łączące klasy reprezentują różne typy relacji między nimi. Na
								przykład:
							</li>
							<li>
								<b>Asocjacja</b>: Zwykła linia oznacza, że dwie klasy są w jakiś sposób powiązane.
								Strzałki
								mogą
								wskazywać kierunek asocjacji,
								a liczby (np. "1" lub "*") określają krotność (ile obiektów jednej klasy może być
								powiązanych z
								obiektem drugiej klasy).
							</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Jak czytać diagramy klas?</h3>
					<img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
					<small>
						<ul>
							<li>
								<b>Dziedziczenie</b>: Linia zakończona pustym trójkątem wskazuje na dziedziczenie lub
								relację
								typu
								"jest rodzajem".
							</li>
							<li>
								<b>Krotność</b>: Przy relacjach, liczby takie jak "1" lub "" określają, ile instancji
								jednej
								klasy może
								być powiązanych z
								instancją drugiej klasy. Na przykład "1" oznacza pojedynczą instancję, a "" oznacza
								wiele
								instancji.
							</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Jak czytać diagramy klas?</h3>
					<img style="max-height: 400px;" src="assets/class_diagram_Zad1.png">
					<small>
						Na podstawie tego diagramu możemy zobaczyć, że klasa Article zawiera prywatne atrybuty takie jak
						title, author,
						publicationYear, journal i publiczne metody takie jak konstruktory, displayInfo(), getTitle(),
						getAuthor(),
						getPublicationYear(), getJournal(). Podobnie dla klas Author, Book i Chapter. Ponadto, relacje
						między klasami wskazują,
						że Article, Book i Chapter zawierają obiekty klasy Author, a Book zawiera również kolekcję
						obiektów Chapter.
					</small>
				</section>
				<section>
					<h3><b>&&&</b> ?</h3>
					<small>
						W języku C++ symbol <b>&</b> w kontekście parametru funkcji oznacza referencję. Referencje
						pozwalają funkcjom na dostęp do
						obiektów przekazanych do nich bez konieczności kopiowania tych obiektów. To znaczy, że funkcja
						może operować
						bezpośrednio na oryginalnym obiekcie, a nie na jego kopii, co jest wydajniejsze, szczególnie dla
						dużych obiektów.
					</small>
					<small>
						W kontekście diagramu klas UML, który przedstawiono, <b>&other</b> w konstruktorze kopiującym
						oznacza, że konstruktor przyjmuje
						referencję do innego obiektu tej samej klasy. Na przykład:
					</small>
					<pre style="font-size: 16px" data-id="code-animation">
					<code class="hljs cpp"><script type="text/template">
												Article::Article(const Article &other)
												</script>
												</code>
												</pre>
					<small>
						Ten konstruktor kopiujący Article przyjmuje referencję do innego obiektu Article i używa jego
						wartości do zainicjowania
						nowego obiektu. To jest standardowy sposób implementacji konstruktora kopiującego w C++, który
						zapewnia, że nowy obiekt
						jest kopią istniejącego obiektu.
					</small>
				</section>
			</section>

			<section data-background-gradient="linear-gradient(175deg, #09bc8a, #565896)" data-auto-animate>

				<!-- Tytuł -->
				<section>
					<h2>Zarządzanie pamięcią w C++</h2>
					<h3>Operatory new i delete</h3>
				</section>

				<!-- Alokacja dynamiczna -->
				<section>
					<h3>Alokacja dynamiczna</h3>
					<ul>
						<li class="fragment">Pamięć statyczna: przydzielana przy kompilacji (np. zmienne lokalne).</li>
						<li class="fragment">Pamięć dynamiczna: przydzielana w trakcie działania programu.</li>
						<li class="fragment">Dzięki temu można tworzyć struktury o zmiennym rozmiarze (np. tablice, listy, drzewa).</li>
					</ul>
				</section>

				<!-- Zwolnienie pamięci -->
				<section>
					<h3>Zwalnianie pamięci</h3>
					<ul>
						<li class="fragment">Pamięć zaalokowaną trzeba zwolnić, inaczej wystąpi wyciek pamięci.</li>
						<li class="fragment">Za zwalnianie odpowiada operator <code>delete</code>.</li>
						<li class="fragment">W przypadku obiektów — automatycznie wywołuje się destruktor.</li>
					</ul>
				</section>

				<!-- Operator new -->
				<section>
					<h3>Operator new</h3>
					<p class="fragment">Przydziela pamięć i zwraca adres utworzonego obiektu.</p>
<pre class="fragment" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
int *p = new int;     // jeden element
*p = 42;

int *tab = new int[5]; // tablica
</code></pre>
				</section>

				<!-- Operator delete -->
				<section>
					<h3>Operator delete</h3>
					<p class="fragment">Zwalnia pamięć zajętą przez obiekt lub tablicę.</p>
<pre class="fragment" style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
delete p;       // dla pojedynczego elementu
delete[] tab;   // dla tablicy
</code></pre>
				</section>

				<!-- Przykład z klasą -->
				<section>
					<h3>Przykład: konstruktor i destruktor</h3>
<pre style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
class MyClass {
public:
  MyClass()  { std::cout << "Obiekt utworzony\n"; }
  ~MyClass() { std::cout << "Obiekt zniszczony\n"; }
};

int main() {
  MyClass* obj = new MyClass(); // konstruktor
  delete obj;                   // destruktor + zwolnienie pamięci
}
</code></pre>
				</section>

				<!-- Tablica obiektów -->
				<section>
					<h3>Tablica obiektów</h3>
<pre style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
MyClass* arr = new MyClass[3]; // 3 obiekty

delete[] arr;                  // zwolnienie tablicy
</code></pre>
					<p class="fragment">Każdy element tablicy ma własny konstruktor i destruktor.</p>
				</section>

				<!-- Destruktor zwalniający zasób -->
				<section>
					<h3>Destruktor a pamięć</h3>
<pre style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
class MyArray {
  int* data;
public:
  MyArray() { data = new int[10]; }
  ~MyArray(){ delete[] data; }
};

int main() {
  MyArray* a = new MyArray();
  delete a;   // destruktor zwalnia pamięć automatycznie
}
</code></pre>
				</section>

				<!-- Quiz -->
				<section>
					<h3>Quiz</h3>
					<ul>
						<li class="fragment">Czym różni się <code>delete</code> od <code>delete[]</code>?</li>
						<li class="fragment">Kiedy wywoływany jest destruktor?</li>
						<li class="fragment">Co się stanie, jeśli zapomnimy zwolnić pamięć?</li>
					</ul>
				</section>

			</section>




			<section data-background-gradient="linear-gradient(175deg, #08415c, #202155)">
				<section>
					<h2>Pliki nagłówkowe</h2>
				</section>
				<section>
					<p>
						W języku C++, koncepcja podziału klasy na dwie części: plik nagłówkowy (header file) i plik
						źródłowy (source
						file) ma kilka korzyści:
					</p>
					<small>
						<ol>
							<li>
								<strong>Modularność:</strong> Dzięki rozdzieleniu definicji klasy (deklaracji) od jej
								implementacji, możliwe
								jest tworzenie modułów kodu, które można łatwo łączyć. Plik nagłówkowy zawiera zazwyczaj
								deklaracje klas,
								funkcji i innych elementów interfejsu, natomiast plik źródłowy zawiera implementację
								tych
								elementów.
							</li>

							<li>
								<strong>Hermetyzacja:</strong> Dzięki rozdzieleniu interfejsu od implementacji, można
								ukryć
								szczegóły
								implementacyjne przed użytkownikiem klasy. Użytkownicy mogą korzystać z interfejsu
								dostępnego w pliku
								nagłówkowym, nie będąc zaznajomieni z tym, jak dokładnie działa implementacja, co
								ułatwia
								utrzymanie
								tajemnicy implementacyjnej (hermetyzację).
							</li>

							<li>
								<strong>Szybsze kompilacje:</strong> W przypadku zmian w implementacji klasy, konieczne
								jest
								ponowne
								skompilowanie tylko pliku źródłowego, co pozwala na zaoszczędzenie czasu kompilacji.
								Jeśli
								wszystko
								zostałoby umieszczone w jednym pliku, nawet najmniejsza zmiana wymagałaby ponownego
								kompilowania całego
								programu.
							</li>
						</ol>
					</small>

				</section>

				<section>
					<small>
						Przykładowo, rozdzielenie klasy "MojaKlasa" na plik nagłówkowy (MojaKlasa.h) i plik źródłowy
						(MojaKlasa.cpp)
						może wyglądać tak:
					</small>
					<div class="row">
						<div class="col" style="float: left; width: 50%;">
							<pre style="font-size: 14px;"><code><script type="text/template">#ifndef MOJA_KLASA_H
#define MOJA_KLASA_H

class MojaKlasa {
public:
				// deklaracja konstruktora z parametrem
				MojaKlasa(int zmienna); 
				// deklaracja metody
				void metoda(); 
private:
				// deklaracja prywatnej zmiennej
				int zmienna; 
};

#endif // MOJA_KLASA_H</script></code></pre>
							<small><b>MojaKlasa.h</b></small>

						</div>
						<div class="col" style="float: right; width: 50%;">

							<pre style="font-size: 14px;"><code>
							<script type="text/template">#include "MojaKlasa.h"

// implementacja konstruktora
MojaKlasa::MojaKlasa(int zmienna)
				: zmienna(zmienna) {
}

// implementacja metody
void MojaKlasa::metoda() {
				std::cout << "Zmienna: " 
								<< zmienna << std::endl;
}</script></code></pre>
							<small><b>MojaKlasa.cpp</b></small>

						</div>
					</div>
					<small>
						Następnie, w pliku, w którym chcemy użyć klasy, importuje się plik nagłówkowy (<b>
							#include
							"MojaKlasa.h"
						</b>) i
						korzysta z
						zadeklarowanego interfejsu. W przypadku kompilacji, konieczne jest dostarczenie zarówno pliku
						nagłówkowego, jak i
						pliku
						źródłowego do kompilatora.
					</small>
				</section>
				<section>
					<h3>Kod preprocesora</h3>
					<small>
						W języku C++, w plikach nagłówkowych, często używa się dyrektyw preprocesora takich jak
						<b>#ifndef</b>,
						<b>#define</b> i <b>#endif</b>
					</small>
					<small>
						<ul>
							<li>
								<b><em>#ifndef</em>(if not defined):</b> - Ten fragment kodu preprocesora sprawdza, czy
								dany symbol lub makro nie został wcześniej zdefiniowany. Jeśli symbol nie
								jest zdefiniowany, to wykonuje się kod znajdujący się między <b>#ifndef</b> a
								odpowiadającym mu <b>#endif</b>. Jeśli symbol jest już
								zdefiniowany, kod pomiędzy tymi dyrektywami jest pomijany.
							</li>
							<li>
								<b><em>#define</em></b> - Jeśli warunek w #ifndef jest spełniony (symbol nie jest
								zdefiniowany), to <b>#define</b> służy do zdefiniowania tego symbolu. W
								praktyce jest to najczęściej używane do stworzenia tzw. "strażnika wielokrotnego
								dołączania" (include guard). Działa to
								jako swoisty klucz, który uniemożliwia wielokrotne dołączanie tego samego pliku
								nagłówkowego podczas kompilacji.
							</li>
							<li>
								<b><em>#endif</em></b> - Oznacza koniec bloku warunkowego rozpoczętego przez
								<b>#ifndef</b>. Kody umieszczone między <b>#ifndef</b> a <b>#endif</b> są kompilowane
								tylko wtedy, gdy warunek nie został spełniony (symbol nie jest zdefiniowany). To zamyka
								blok warunkowy.
							</li>
						</ul>
					</small>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(175deg, #009b72, #43447b)">

				<section>
					<h2>Polimorfizm</h2>
					<h3>Przeciązanie funkcji i metod</h3>
					<h3> Dziedziczenie</h3>
				</section>
				<section data-auto-animate>
					<h3>Przeciążanie funkcji</h3>
					<small>
						Przeciążanie funkcji to technika programowania, która pozwala na definiowanie wielu funkcji o
						tej samej nazwie,
						ale różniących się typami i/lub liczbą argumentów. Kompilator wybiera odpowiednią funkcję do
						wywołania na
						podstawie argumentów użytych podczas wywołania.
					</small>
					<pre>Przykład przeciążania funkcji w C++<code><script type="text/template">void print(int i) {
										std::cout << "Here is int: " << i << std::endl;
						}
						void print(double f) {
										std::cout << "Here is float: " << f << std::endl;
						}
						void print(char* c) {
										std::cout << "Here is char*: " << c << std::endl;
						}</script></code></pre>
					<small>
						W powyższym przykładzie, funkcja <code>print</code> jest przeciążona trzy razy: raz dla
						argumentu typu int, raz
						dla argumentu typu double i raz dla argumentu typu char*. Kompilator wybierze odpowiednią
						funkcję do wywołania
						na podstawie typu argumentu użytego podczas wywołania. Dzięki temu, metoda może być wywołana w
						różny sposób w zależności od kontekstu, co zwiększa elastyczność i czytelność
						kodu.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Przeciążanie funkcji a programowanie obiektowe</h3>
					<small>
						Przeciążanie funkcji jest kluczowym elementem programowania obiektowego. Pozwala na definiowanie
						wielu metod o
						tej samej nazwie w obrębie jednej klasy, które różnią się typami i/lub liczbą argumentów. Dzięki
						temu, metoda
						może być wywołana w różny sposób w zależności od kontekstu, co zwiększa elastyczność i
						czytelność kodu.
					</small>
				</section>


				<section data-auto-animate>
					<h3>Dziedziczenie w programowaniu obiektowym</h3>
					<small>
						Dziedziczenie w programowaniu obiektowym to jeden z fundamentów tej paradygmatu programowania.
						Pozwala ono na tworzenie
						nowych klas na podstawie istniejących klas. Nowa klasa, zwana klasą pochodną, dziedziczy
						atrybuty i metody klasy bazowej, co
						pozwala na ponowne użycie kodu.
					</small>
					<pre style="font-size: 16px;">Przykład dziedziczenia w C++<code><script type="text/template">// Klasa bazowa
						class Animal {
						public:
								void eat() {
										std::cout << "I can eat!" << std::endl;
								}
						};
						
						// Klasa pochodna
						class Dog : public Animal {
						public:
								void bark() {
										std::cout << "I can bark! Woof Woof!" << std::endl;
								}
						};</script></code></pre>
					<small>
						W powyższym przykładzie, klasa <code>Dog</code> dziedziczy od klasy <code>Animal</code>. Oznacza
						to, że obiekt
						klasy <code>Dog</code> może używać metody <code>eat()</code> zdefiniowanej w klasie
						<code>Animal</code>, a także
						metody <code>bark()</code> zdefiniowanej w samej klasie <code>Dog</code>.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Dziedziczenie w programowaniu obiektowym</h3>
					<pre>Użycie klasy Dog w main.cpp<code class="hljs cpp"><script type="text/template">// main.cpp
						int main() {
								Animal myAnimal;
								myAnimal.eat();
								//myAnimal.bark(); // Błąd kompilacji
								Dog myDog;
								myDog.eat();
								myDog.bark();
								return 0;
						}</script></code></pre>
					<small>
						W powyższym przykładzie, tworzymy obiekt klasy <code>Dog</code> i <code>Animal</code> i
						wywołujemy metody <code>eat()</code> i
						<code>bark()</code>. Metoda <code>eat()</code> jest dziedziczona z klasy <code>Animal</code>, a
						metoda
						<code>bark()</code> jest zdefiniowana w klasie <code>Dog</code>. Obiekt klasy
						<code>Animal</code> nie posiada metody <code>bark()</code>,
					</small>

				</section>
				<section data-auto-animate>
					<h3>Poziomy dostępu do dziedziczenia w C++</h3>
					<ul>
						<li>
							<small>
								<strong>Public:</strong> Jeśli klasa jest dziedziczona publicznie, to publiczne i
								chronione członki
								klasy bazowej stają się odpowiednio publicznymi i chronionymi członkami klasy pochodnej.
							</small>
						</li>
						<li>
							<small>
								<strong>Protected:</strong> Jeśli klasa jest dziedziczona chronionie, to publiczne i
								chronione członki
								klasy bazowej stają się chronionymi członkami klasy pochodnej.
							</small>
						</li>
						<li>
							<small>
								<strong>Private:</strong> Jeśli klasa jest dziedziczona prywatnie, to publiczne i
								chronione członki
								klasy bazowej stają się prywatnymi członkami klasy pochodnej.
							</small>
						</li>
					</ul>
				</section>




				<section data-auto-animate>
					<h3>Metody wirtualne w C++</h3>
					<small>
						Metoda wirtualna to funkcja członkowska klasy, którą deklaruje się za pomocą słowa kluczowego
						<code>virtual</code> w klasie bazowej. Pozwala to na "przesłanianie" metody w klasie pochodnej.
						Gdy metoda
						wirtualna jest wywoływana przez wskaźnik lub referencję do klasę bazową, wywołanie jest
						rozstrzygane w czasie
						wykonywania, a nie w czasie kompilacji. To oznacza, że wywołana zostanie metoda zdefiniowana w
						klasie typu
						obiektu, a nie typu wskaźnika lub referencji.
					</small>


					<pre style="font-size: 16px;">Przykład metody wirtualnej w C++<code><script type="text/template">// Klasa bazowa
						class Base {
						public:
								virtual void print() {
										cout << "Wywołanie metody print() klasy bazowej" << endl;
								}
						};
						
						// Klasa pochodna
						class Derived : public Base {
						public:
								// Przesłonięcie metody print()
								void print() override {
										cout << "Wywołanie metody print() klasy pochodnej" << endl;
								}
						};</script></code></pre>
				</section>


				<section data-auto-animate>
					<h3>Metody abstrakcyjne w C++</h3>
					<small>
						Metoda abstrakcyjna to metoda wirtualna, która jest zadeklarowana, ale nie zdefiniowana w klasie
						bazowej.
						Deklaruje się ją, ustawiając jej definicję na 0 (np. <code>virtual void myMethod() = 0;</code>).
						Klasa, która
						zawiera co najmniej jedną metodę abstrakcyjną, jest nazywana klasą abstrakcyjną. Klasy
						abstrakcyjne nie mogą być
						instancjonowane - służą jako bazy dla klas pochodnych, które muszą zaimplementować wszystkie
						metody
						abstrakcyjne.
					</small>


					<pre style="font-size: 16px;">Przykład metody abstrakcyjnej w C++<code><script type="text/template">// Klasa bazowa (abstrakcyjna)
						class Base {
						public:
								virtual void print() = 0; // Metoda abstrakcyjna
						};
						
						// Klasa pochodna
						class Derived : public Base {
						public:
								// Implementacja metody abstrakcyjnej
								void print() override {
										cout << "Wywołanie metody print() klasy pochodnej" << endl;
								}
						};</script></code></pre>
				</section>

				<section data-auto-animate>
					<h3>Przesłanianie metod bez użycia słowa kluczowego 'virtual' w C++</h3>
					<small>
						Jeśli metoda zostanie przysłonięta bez użycia słowa kluczowego <code>virtual</code>, to
						zachowanie będzie
						zależało od typu
						referencji lub wskaźnika, którym wywoływania jest metoda, a nie od rzeczywistego typu obiektu.
						To jest
						znane jako
						"statyczne wiązanie" lub "wiązanie w czasie kompilacji".
					</small>
					<pre style="font-size: 15px;">Przykład <code><script type="text/template">// Klasa bazowa
						class Base {
						public:
								void print() {
										cout << "Wywołanie metody print() klasy bazowej" << endl;
								}
						};
						
						// Klasa pochodna
						class Derived : public Base {
						public:
								void print() {
										cout << "Wywołanie metody print() klasy pochodnej" << endl;
								}
						};
						
						int main() {
								Derived d;
								Base& b = d;
								b.print();  // Wywoła metodę print() klasy bazowej, nie pochodnej
								return 0;
						}</script></code></pre>
					<small>
						W powyższym przykładzie, mimo że <code>b</code> jest referencją do obiektu klasy
						<code>Derived</code>, wywołanie
						<code>b.print()</code> wywoła metodę <code>print()</code> klasy <code>Base</code>, ponieważ
						metoda
						<code>print()</code> nie jest wirtualna.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Rodzaje Dziedziczenia w Programowaniu Obiektowym</h3>
					<small>
						Dziedziczenie w programowaniu obiektowym umożliwia tworzenie nowych klas na podstawie
						istniejących klas, co
						ułatwia ponowne użycie kodu, zwiększa czytelność i ułatwia zarządzanie kodem.
						<ul>
							<li>
								<strong>Dziedziczenie jednokrotne (single inheritance):</strong> Klasa podrzędna
								dziedziczy od jednej
								klasy nadrzędnej.
							</li>
							<li>
								<strong>Dziedziczenie wielokrotne (multiple inheritance):</strong> Klasa podrzędna
								dziedziczy
								jednocześnie od dwóch lub więcej klas nadrzędnych.
							</li>
							<li>
								<strong>Dziedziczenie wielostopniowe (multilevel inheritance):</strong> Jedna klasa
								dziedziczy od innej,
								a następnie inna klasa dziedziczy z powyższej klasy, tworząc hierarchię klasy.
							</li>
							<li>
								<strong>Dziedziczenie wielopoziomowe (hierarchical inheritance):</strong> Jedna klasa
								nadrzędna, wiele
								klas podrzędnych. Klasy podrzędne mogą dziedziczyć od jednej wspólnej klasy nadrzędnej.
							</li>
							<li>
								<strong>Dziedziczenie interfejsów (interface inheritance):</strong> Klasy mogą
								dziedziczyć jedynie
								sygnatury metod, nie ich implementacje. Jest to podobne do klas abstrakcyjnych w C++.
							</li>
						</ul>
					</small>
				</section>

				<section data-auto-animate>
					<h3>Polimorfizm w programowaniu obiektowym</h3>
					<small>
						Polimorfizm to kluczowy koncept w programowaniu obiektowym, który pozwala obiektom różnych klas
						działać jak
						obiekty innej klasy. Jest to możliwe dzięki użyciu dziedziczenia i metod wirtualnych.
					</small>
					<ul>
						<li>
							<small>
								<b>Polimorfizm statyczny (wczesne wiązanie):</b> Typ obiektu jest określany podczas
								kompilacji.
								Przykładem może być przeciążanie funkcji.
							</small>
						</li>
						<li>
							<small>
								<b>Polimorfizm dynamiczny (późne wiązanie):</b> Typ obiektu jest określany w czasie
								wykonywania.
								Przykładem może być przesłanianie funkcji.
							</small>
						</li>
					</ul>
					<small>
						Polimorfizm jest ważny, ponieważ pozwala na tworzenie bardziej elastycznego i łatwiejszego do
						zarządzania kodu,
						umożliwiając programistom traktowanie obiektów różnych klas w ten sam sposób.
					</small>
				</section>
			</section>

			<section data-auto-animate data-background-gradient="linear-gradient(90deg, #aFB486, #F46267)">

				<!-- Tytuł -->
				<section>
					<h1>Dziedziczenie wielobazowe</h1>
				</section>

				<!-- Podstawowy przykład -->
				<section data-auto-animate>
<pre style="font-size: 16px" data-id="code-animation">
<code class="hljs cpp" data-trim data-line-numbers="1-9|11-19|21-28">
#include <iostream>

class BazowaA {
protected: int licznik;
public: void wyswietl() { std::cout << "A::wyswietl()\n"; }
};

class BazowaB {
protected: int licznik;
public: void wyswietl() { std::cout << "B::wyswietl()\n"; }
};

class Klasa: public BazowaA, public BazowaB {
public:
  void wyzeruj() {
    BazowaA::licznik = 0;
    BazowaB::licznik = 0;
  }
};

int main() {
  Klasa k;
  k.BazowaA::wyswietl();
  k.BazowaB::wyswietl();
}
</code>
</pre>
					<p class="fragment">W C++ jedna klasa może dziedziczyć po wielu klasach bazowych.</p>
					<p class="fragment">Jeśli metody lub pola się powtarzają, trzeba podać nazwę klasy (np. <code>BazowaA::</code>).</p>
				</section>

				<!-- Dostęp do pól i metod -->
				<section data-auto-animate>
					<h3>Dostęp do pól i metod</h3>
					<p class="fragment">Klasa pochodna ma dostęp do pól/metod bazowych zgodnie z regułami <code>public/protected/private</code>.</p>
					<p class="fragment">Przy powtarzających się nazwach → konieczna jest kwalifikacja nazwy (np. <code>k.BazowaA::wyswietl()</code>).</p>
				</section>

				<!-- Dziedziczenie wirtualne – problem -->
				<section>
					<h3>Dziedziczenie wirtualne</h3>
					<p>Problem: ta sama klasa bazowa może pojawić się wielokrotnie.</p>
<pre style="font-size: 16px" data-id="code-animation">
<code class="hljs cpp" data-trim data-line-numbers="1-3|5|7">
class Bazowa { public: void wyswietl() {} };

class Posrednia: public Bazowa {};

class Klasa: public Bazowa, public Posrednia {};
</code>
</pre>
					<p class="fragment">Klasa <code>Bazowa</code> jest tu przodkiem Klasy dwa razy → powstaje duplikacja pól i metod.</p>
				</section>

				<!-- Dziedziczenie wirtualne – rozwiązanie -->
				<section>
					<h3>Rozwiązanie: słowo kluczowe virtual</h3>
					<p class="fragment">Dzięki <code>virtual</code> dziedziczymy bazową klasę tylko raz.</p>
<pre style="font-size: 16px" data-id="code-animation">
<code class="hljs cpp" data-trim data-line-numbers="1-4|6|8|10-14">
class Bazowa {
public: void wyswietl() {}
};

class Posrednia1: public virtual Bazowa {};
class Posrednia2: public virtual Bazowa {};

class Klasa: public Posrednia1, public Posrednia2 {};

int main() {
  Klasa k;
  k.wyswietl();   // jednoznaczne wywołanie
}
</code>
</pre>
					<p class="fragment">Teraz pola i metody z klasy <code>Bazowa</code> istnieją tylko raz i odwołania są jednoznaczne.</p>
				</section>

				<!-- Quiz -->
				<section>
					<h3>Quiz</h3>
					<ul>
						<li class="fragment">Na czym polega dziedziczenie wielobazowe?</li>
						<li class="fragment">Co się stanie, gdy obie klasy bazowe mają metodę o tej samej nazwie?</li>
						<li class="fragment">Po co stosuje się dziedziczenie wirtualne?</li>
					</ul>
				</section>

			</section>
			<section data-background-gradient="linear-gradient(120deg, #8e44ad, #3498db)">
				<section>
					<h2>Przeciążanie operatorów w C++</h2>
					<p>W C++ możemy zdefiniować, jak operatory (+, -, =, [], << itp.) mają działać dla naszych własnych klas.</p>
				</section>

				<section>
					<h3>Dlaczego to przydatne?</h3>
					<ul>
						<li class="fragment">Pozwala traktować obiekty jak liczby czy napisy.</li>
						<li class="fragment">Ułatwia czytelność kodu.</li>
						<li class="fragment">Pozwala pisać własne struktury danych (np. wektor, macierz).</li>
					</ul>
				</section>

				<section>
					<h3>Przykład: operator +</h3>
				<pre style="font-size:16px"><code class="hljs cpp" data-trim data-line-numbers>
				#include <iostream>
				using namespace std;

				class Wektor {
				  int x, y;
				public:
				  Wektor(int a, int b): x(a), y(b) {}

				  // przeciążenie operatora +
				  Wektor operator+(const Wektor& other) {
					return Wektor(x + other.x, y + other.y);
				  }

				  void print() {
					cout << "(" << x << "," << y << ")";
				  }
				};

				int main() {
				  Wektor a(1,2), b(3,4);
				  Wektor c = a + b; // działa jak dla liczb!
				  c.print(); // wynik: (4,6)
				}
				</code></pre>
								</section>

								<section>
									<h3>Inne często przeciążane operatory</h3>
									<ul>
										<li><code>==</code> i <code>!=</code> – porównywanie obiektów.</li>
										<li><code>[]</code> – dostęp do elementu tablicy w klasie.</li>
										<li><code>&lt;&lt;</code> – wyświetlanie obiektów w <code>cout</code>.</li>
									</ul>
								</section>

								<section>
									<h3>Ćwiczenie</h3>
									<p>Napisz klasę <code>Complex</code> (liczby zespolone), a następnie przeciąż operator <code>+</code> i <code>&lt;&lt;</code>, żeby działały jak dla liczb:</p>
				<pre style="font-size:16px"><code class="hljs cpp" data-trim>
				Complex a(1,2), b(3,4);
				cout << (a+b); // wypisze: 4 + 6i
				</code></pre>
								</section>
							</section>



			</section>
			<!-- TODO -->
			<section>
				<section>
					<h3>Wzorzec projektowy Singleton</h3>
					<small>
						Wzorzec projektowy Singleton jest jednym z najbardziej popularnych wzorców projektowych w
						programowaniu
						obiektowym. Jego celem jest zapewnienie, że klasa ma tylko jedną instancję i zapewnienie
						globalnego dostępu do
						tej instancji.
					</small>
					<small>
						Wzorzec Singleton jest szczególnie przydatny, gdy chcemy, aby klasa miała tylko jedną instancję
						i chcemy
						zapewnić, że dostęp do tej instancji jest globalny. Może to być przydatne w przypadku, gdy
						chcemy, aby
						klasa reprezentowała globalny stan lub zasób, który jest współdzielony przez całą aplikację.
					</small>
				</section>
				<section>
					<h3>Przykład użycia wzorca projektowego Singleton</h3>
					<small>
						Poniżej znajduje się przykład kodu w języku C++, który pokazuje, jak używać wzorca projektowego
						Singleton:
					</small>
					<pre style="font-size: 16px;"><code>class Singleton {
						private:
								// Prywatny konstruktor, aby zapobiec 
								// tworzeniu instancji za pomocą operatora new
								Singleton() {}
						
								// Prywatny destruktor
								~Singleton() {}
						
								// Usunięcie możliwości kopiowania i przypisywania
								Singleton(const Singleton&) = delete;
								Singleton& operator=(const Singleton&) = delete;
						
						public:
								// Metoda do uzyskania instancji Singleton
								static Singleton& getInstance() {
										static Singleton instance;
										return instance;
								}
						};
						    </code></pre>
					<small>
						W tym przykładzie, klasa <code>Singleton</code> ma prywatny konstruktor i destruktor, co
						zapobiega tworzeniu
						nowych instancji za pomocą operatora <code>new</code> lub <code>delete</code>. Metoda
						<code>getInstance</code>
						zapewnia globalny dostęp do jednej instancji klasy.
					</small>
					<small>
						Ten przykład pokazuje, jak wzorzec Singleton może być używany do zapewnienia, że klasa ma tylko
						jedną instancję,
						a dostęp do tej instancji jest globalny.
					</small>
				</section>
			</section>
			<section>

				<section>
					<h3>Klasy zaprzyjaźnione w C++</h3>
					<small>
						Słowo kluczowe <code>friend</code> w C++ jest używane do nadania pewnym funkcjom lub klasom
						dostępu do
						prywatnych i chronionych członków klasy. Jeśli klasa jest zadeklarowana jako <code>friend</code>
						wewnątrz
						definicji innej klasy, ta zaprzyjaźniona klasa może bezpośrednio dostępować do prywatnych i
						chronionych członków
						tej klasy.
					</small>
					<small>
						Przykład użycia <code>friend</code> z klasą:
					</small>
					<pre style="font-size: 16px;"><code>
						class MyClass {
						private:
								int myPrivateVar;
						
						friend class MyFriendClass;
						};
						
						class MyFriendClass {
						public:
								void changeMyClass(MyClass& obj) {
									// Dostęp do prywatnej zmiennej jest możliwy dzięki deklaracji friend
										obj.myPrivateVar = 42;  
								}
						};
						    </code></pre>
					<small>
						W powyższym przykładzie, klasa <code>MyFriendClass</code> ma dostęp do prywatnej zmiennej
						<code>myPrivateVar</code> klasy <code>MyClass</code>, ponieważ jest zadeklarowana jako
						<code>friend</code> w tej
						klasie.
					</small>
				</section>


				<section>
					<h3>Ćwiczenie praktyczne: Rozbudowane zarządzanie pamięcią</h3>
					<small>
						Teraz, gdy zapoznałeś się z użyciem operatorów <code>new</code> i <code>delete</code> oraz
						wzorcem Singleton,
						spróbuj samodzielnie zaimplementować poniższe zadania:
					</small>
					<ul>
						<li>
							<small>
								Zaimplementuj klasę <code>MyArray</code> w C++, która ma prywatny konstruktor alokujący
								pamięć dla
								tablicy o określonym rozmiarze, prywatny destruktor zwalniający tę pamięć i publiczną
								metodę
								<code>getSize</code>, która zwraca rozmiar tablicy. Dodatkowo, dodaj metody
								<code>setValue</code> i
								<code>getValue</code> do ustawiania i pobierania wartości na określonym indeksie
								tablicy.
							</small>
						</li>
						<li>
							<small>
								Zaimplementuj klasę <code>MySingleton</code>, która jest Singletonem i przechowuje
								instancję klasy
								<code>MyArray</code>. Klasa powinna mieć metodę <code>getArray</code>, która zwraca
								referencję do
								przechowywanej instancji <code>MyArray</code>.
							</small>
						</li>
						<li>
							<small>
								Zaimplementuj funkcję <code>main</code>, która tworzy instancję klasy
								<code>MySingleton</code> za pomocą
								metody <code>getInstance</code>, a następnie używa metody <code>getArray</code> do
								manipulacji tablicą.
								Spróbuj dodać, odczytać i zmienić wartości w tablicy. Obserwuj, jak konstruktor i
								destruktor są
								wywoływane.
							</small>
						</li>
					</ul>
					<small>
						Pamiętaj, że kluczowym aspektem zarządzania pamięcią w programowaniu obiektowym jest
						zapewnienie, że pamięć jest
						odpowiednio alokowana i zwalniana. Operatorzy <code>new</code> i <code>delete</code> są
						podstawowymi narzędziami
						do tego celu w języku C++, a wzorzec Singleton pomaga zarządzać instancjami klas.
					</small>
				</section>

				<section data-background-color="black" data-auto-animate="">
					<h3>Zadanie domowe: Klasa do sortowania z dynamiczną alokacją pamięci</h3>
					<small>
						Twoim zadaniem jest zaimplementować klasę, która przyjmuje tablicę liczb do posortowania w
						konstruktorze,
						dynamicznie alokuje pamięć dla tej tablicy, a następnie zawiera metodę do jej sortowania. Metoda
						sortująca
						powinna zwracać wynik sortowania, jeśli jest wywołana po raz pierwszy, lub zwracać poprzedni
						wynik, jeśli
						sortowanie już zostało wykonane.
					</small>
					<ul>
						<li>
							<small>
								Użyj operatora <code>new</code> w konstruktorze klasy do dynamicznego alokowania pamięci
								dla tablicy.
							</small>
						</li>
						<li>
							<small>
								Zaimplementuj dowolny algorytm sortowania (oprócz sortowania bąbelkowego) jako metodę
								klasy do
								posortowania tablicy.
							</small>
						</li>
						<li>
							<small>
								Metoda sortująca powinna zwracać wynik sortowania, jeśli jest wywołana po raz pierwszy,
								lub zwracać
								poprzedni wynik, jeśli sortowanie już zostało wykonane.
							</small>
						</li>
						<li>
							<small>
								Użyj operatora <code>delete</code> w destruktorze klasy do zwolnienia pamięci po
								zakończeniu sortowania.
							</small>
						</li>
					</ul>
					<small>
						Pamiętaj, że kluczowym aspektem zarządzania pamięcią w programowaniu obiektowym jest
						zapewnienie, że pamięć jest
						odpowiednio alokowana i zwalniana. Operatorzy <code>new</code> i <code>delete</code> są
						podstawowymi narzędziami
						do tego celu w języku C++.
					</small>
				</section>



			</section>

















			<!-- TODO jako zadanie domowe -->
			<section data-background-gradient="linear-gradient(45deg, #c03090, #10a080)">
				<section>
					<h2>Konstruktor - cechy główne</h2>
				</section>
				<section data-auto-animate>
					<h3>Uwagi ogólne do konstruktorów</h3>
					<small>
						<ul>
							<li>
								Konstruktor <b>NIE MUSI</b> wystąpić w opisie klasy, czyli obiekty nie muszą być
								jawnie wprowadzane
								konstruktorem. Wtedy uruchomi się konstruktor domniemany.
							</li>
							<li>
								Nazwa konstruktora może być przeładowana, czyli stosowana wielokrotnie w opisie
								klasy z różnymi
								listami argumentów. Wtedy kompilator odróżnia konstruktory po listach argumentów,
								tak, jak w
								przypadku przeładowanych nazw funkcji. Konstruktorów może więc być wiele.
							</li>
							<li>
								Konstruktor może być wywoływany (a nie definiowany!!) bez żadnych argumentów. Jest
								to również tak
								zwany konstruktor domniemany. Czasem nazywamy go domyślnym albo standardowym. Ze
								względu na istotę
								przeładowania nazwy konstruktor domniemany czyli bezargumentowy może wystąpić tylko
								raz. Jeśli nie
								deklarujemy w klasie żadnego konstruktora, to kompilator sam ustanawia właśnie
								konstruktor
								domniemany do obsługi obiektów w programie. Każdy konstruktor z argumentami, którym
								nadamy
								początkowe wartości domyślne czyli już niedefiniowalne jest także konstruktorem
								domniemanym.
							</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor i jego właściwości</h3>
					<small>
						<ul>
							<li>
								Konstruktor jest zwykle deklarowany jako publiczny, bo obiekty wprowadzane nim mogą
								być używane
								przez klasy zewnętrzne, a ponadto jest funkcją, która <b>MUSI</b> być dostępna dla
								wszystkich
								składników klasy.
							</li>
							<li>
								Dla konstruktora można przewidzieć ochronę za pomocą etykiet <code>private</code>
								lub
								<code>protected</code>. Wówczas konstruowane obiekty będą dostępne tylko w obrębie
								klasy z tym
								konstruktorem jako <code>private</code> albo jako <code>protected</code> tylko w
								zakresie klas
								dziedziczących.
							</li>
							<li>
								Konstruktor kopiujący zamiast definiować nowe obiekty, podaje kopie obiektów
								zawartych w innej
								klasie.
							</li>
							<li>Konstruktor konwertujący dokonuje konwersji typu obiektu z jednego w drugi.</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący</h3>
					<small>
						<p>Przyjrzyjmy się wywołaniu konstruktora klasy o nazwie <code>klasa</code>:</p>
						<pre><code data-trim class="cpp">
													MyClass::MyClass(MyClass&)
															</code></pre>
						<p>
							Jego argumentem jest referencja do obiektu danej klasy. Czyli do elementu, który w chwili
							uruchomienia
							tego konstruktora już istnieje. Taki konstruktor nie konstruuje obiektu tylko tworzy
							kopię innego, który
							już istnieje.
						</p>
						<p>Przykłady zapisu konstruktora kopiującego:</p>
						<pre><code data-trim class="cpp">
													X::X(X&)
															</code></pre>
						<p>lub</p>
						<pre><code data-trim class="cpp">
													X::X(X&, float=3.1415, int=0)
															</code></pre>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący c.d.</h3>
					<small>
						<p>
							Taki konstruktor wprowadza obiekty identyczne z już istniejącymi, czyli ich kopie. Może
							być wywołany
							przez program niejawnie:
						</p>
						<ol>
							<li>
								W sytuacji, gdy do funkcji jest przez wartość przesyłany obiekt klasy X. Wówczas
								tworzona jest kopia
								tego obiektu, co jest znanym jako kopiowanie płytkie.
							</li>
							<li>
								W sytuacji, kiedy funkcja zwraca przez wartość obiekt klasy X. Również wtedy
								tworzona jest kopia
								obiektu, co także jest kopiowaniem płytkim.
							</li>
						</ol>
						<p>
							To, że konstruktor kopiujący podaje obiekt kopiowany przez referencję, daje mu możliwość
							zmiany
							zawartości obiektu klasy (np. przesyłanie argumentu do funkcji przez wartość).
						</p>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący c.d.</h3>
					<small>
						<p>
							Nie można pominąć referencji w konstruktorze kopiującym, ponieważ gdyby konstruktor
							<code>X</code>
							wywoływał obiekty swojej klasy <code>X</code> przez wartość, to powstawałaby
							nieskończona pętla
							tworzenia kopii.
						</p>
						<p>
							Konstruktor, z przyczyn logiki języka, otrzymuje więc warunki do tego, aby potencjalnie
							uszkodzić
							oryginał. Aby się przed tym zabezpieczyć, stosujemy następujący zapis (w trybie
							domyślnym):
						</p>
						<pre><code data-trim class="cpp">
													X::X(const X& obiekt)
															</code></pre>
						<p>
							Teraz konstruktor <code>X</code> wie, że obiekt klasy <code>X</code> musi być wywoływany
							jako stały.
							Konstruktor kopiujący jest domyślnie obdarzony moderatorem <code>const</code>, czyli nie
							może zmienić
							sam siebie.
						</p>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Kopiowanie płytkie i głębokie</h3>
					<small>
						<p>Wyróżniamy dwa typy kopiowania obiektów zawierających pola będące wskaźnikami:</p>
						<h4>Kopiowanie płytkie</h4>
						<ul>
							<li>Kopiowanie wszystkich składowych (w tym wskaźników).</li>
							<li>Kopiowane są wskaźniki, a nie to, na co wskazują.</li>
						</ul>
						<h4>Kopiowanie głębokie</h4>
						<ul>
							<li>Alokacja nowej pamięci dla wskaźników.</li>
							<li>Kopiowanie zawartości wskazywanej przez wskaźniki w nowe miejsce.</li>
							<li>Kopiowanie pozostałych pól, nie będących wskaźnikami.</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Głębokie kopiowanie</h3>
					<small>
						<p>
							Kiedy obiekt zawiera wskaźnik do dynamicznie zaalokowanego obszaru, należy zdefiniować
							operator
							przypisania wykonujący głębokie kopiowanie. Dla rozważanej klasy zdefiniowanie operatora
							przypisania
							może wyglądać następująco:
						</p>
						<pre><code data-trim class="cpp">
													AType&amp; AType::operator=(const AType&amp; otherObj) {
														// Sprawdzić przypisanie obiektu do samego siebie
														if (this == &amp;otherObj) {
															return *this; // do nothing
														}
													
														// Skasować zawartość obiektu docelowego
														delete this->...; // Właściwe czyszczenie zasobów
													
														// Zaalokować pamięć dla kopiowanych wartości
														// ... kod alokacji ...
													
														// Przepisać kopiowane wartości
														// ... kod kopiowania ...
													
														// Zwrócić *this
														return *this;
													}
															</code></pre>
						<p>
							Operator przypisania powinien uwzględnić przypadki szczególne, takie jak przypisanie
							obiektu do samego
							siebie oraz zarządzanie zasobami.
						</p>
					</small>
				</section>
				<section>
					<h3>Konstruktor kopiujący vs Operator przypisania</h3>
					<p>Konstruktor kopiujący i operator przypisania mają różne zastosowania i zachowania.</p>
				</section>

				<section>
					<h4>Konstruktor kopiujący</h4>
					<p>
						Używany do stworzenia nowego obiektu z istniejącego, bez konieczności sprawdzania przypisania
						do samego
						siebie oraz zwalniania poprzedniej zawartości. Jest wywoływany:
					</p>
					<ul>
						<li>Przy przekazywaniu obiektu przez wartość.</li>
						<li>Przy inicjalizacji nowego obiektu istniejącym.</li>
					</ul>
				</section>

				<section>
					<h4>Operator przypisania</h4>
					<p>
						Używany do kopiowania wartości między już istniejącymi obiektami, z dodatkowymi krokami jak:
					</p>
					<ul>
						<li>Sprawdzenie przypisania obiektu do samego siebie.</li>
						<li>Zarządzanie zwalnianiem zasobów przed przypisaniem.</li>
					</ul>
				</section>
				<section>
					<h3>Konstruktor kopiujący vs Operator przypisania c.d.</h3>
					<pre><code data-trim contenteditable>
													int main() {
														list a;
														// ...
														list b(a); // copy constructor is called
														list c = a; // copy constructor is called
													};
														</code></pre>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code class="hljs cpp"
											 data-trim
											 data-line-numbers>
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
				</section>

				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="5-10">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Omówienie przykładu: Klasa X</small>
					<small>
						<ul>
							<li>
								Klasyfikacja <code>public</code>, wskaźnik <code>p</code> i konstruktor
								<code>X(char*)</code>.
							</li>
							<li>Wskaźnik <code>p</code> wskazuje na znaki.</li>
							<li>Konstruktor przyjmuje <code>char*</code> jako argument.</li>
						</ul>
					</small>
				</section>

				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="38-41">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Omówienie przykładu: Konstruktor X</small>
					<br />
					<small>
						Definicja konstruktora klasy <code>X</code>. Przydziela on pamięć
						dla tablicy
						znaków i kopiuje łańcuch przekazany jako argument tylko jeśli alokacja pamięci się
						powiedzie.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="13-19">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Omówienie przykładu: Klasa Y</small>
					<small>Analogiczna struktura do klasy X dla klasy Y.</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="43-51">
					<script type="text/template">
														#include<iostream>
														#include<string>
														#include<conio.h>
														
														class X {
														public:
														    char *p;
														
														    X(char *);
														};
														
														class Y {
														public:
														    char *p;
														
														    Y(char *);
														
														    Y(Y &); // deklaracja konstruktora kopiującego
														};
														
														void main() {
														    X x("xxx");
														    X j = x; // wywołanie konstruktora kopiującego
														    cout << "\nx=" << x.p << ", j=" << j.p;
														    strcpy(j.p, "111");
														    cout << "\nx=" << x.p << ", j=" << j.p;
														    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
														
														    Y y("yyy");
														    Y d = y; // wywołanie konstruktora kopiującego
														    cout << "\ny=" << y.p << ", d=" << d.p;
														    strcpy(y.p, "222");
														    cout << "\ny=" << y.p << ", d=" << d.p;
														    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
														    getch();
														}
														
														X::X(char *s) {
														    p = new char[80];
														    if (p) strcpy(p, s);
														}
														
														Y::Y(char *s) {
														    p = new char[80];
														    if (p) strcpy(this->p, s);
														}
														
														Y::Y(Y &y) {
														    p = new char[80];
														    if (p) strcpy(p, y.p);
														}
																	</script></code></pre>
					<p>Implementacja konstruktorów klasy Y.</p>
					<small>
						Konstruktor klasy <code>Y</code>, przydziela pamięć dla tablicy
						znaków i kopiuje
						łańcuch przekazany jako argument.
					</small>
					<small>
						Konstruktor kopiujący klasy <code>Y</code>, tworzy nową tablicę
						znaków i kopiuje do
						niej zawartość z innego obiektu klasy <code>Y</code>, umożliwiając kopiowanie głębokie.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 150px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="48-51">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Konstruktor kopiujący w klasie Y kopiuje wskaźnik do zmiennej znakowej.</small>
					<small>
						<ul>
							<li>Możliwe jest kopiowanie z innej klasy, co jest podstawą kopiowania głębokiego.</li>
							<li>
								W klasie X, domyślny konstruktor kopiujący (utworzony w trakcie kompilacji) umożliwia
								kopiowanie płytkie.
							</li>
							<li>Kopiowanie płytkie obejmuje tylko składniki klasy X.</li>
						</ul>
					</small>
					<small>
						Konstruktor kopiujący klasy Y umożliwia kopiowanie głębokie, w przeciwieństwie do
						konstruktora kopiującego klasy X,
						który jest domyślny i wykonuje kopiowanie płytkie.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="21,22,23">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Inicjalizacja obiektów klasy X</small>
					<small>Tworzymy dwa obiekty klasy X, x i j, gdzie j jest inicjowany przez skopiowanie x.</small>
					<small>
						<ul>
							<li>x jest inicjowany z ciągiem "xxx".</li>
							<li>Konstruktor kopiujący klasy X jest używany do stworzenia j jako kopii x.</li>
						</ul>
					</small>
				</section>


				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="24-26">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Współdzielenie pamięci przez obiekty</small>
					<small>Wskaźnik p w obu obiektach, x i j, wskazuje na to samo miejsce w pamięci.</small>
					<small>
						<ul>
							<li>
								Modyfikacja <code>j.p</code> za pomocą <code>strcpy</code> zmienia również wartość
								wskazywaną przez <code>x.p.</code>
							</li>
							<li>
								Wydruk adresów wskaźników obiektów <code>x</code> i <code>j</code> pokaże ten sam adres.
							</li>
						</ul>
					</small>
				</section>


				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="24-26">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<p>Modyfikacja i wydruk wartości wskaźnika</p>
					<small>
						Poprzez wskaźnik <code>p</code> wpisujemy wartość "111" do obiektu
						<code>j</code>,
						a zmiany widoczne są również w <code>x</code> ze względu na współdzieloną pamięć. Wydruk
						adresów po
						modyfikacji wskaźnika <code>p</code> w obiekcie <code>j</code> powinien pokazać identyczne
						adresy dla obu
						obiektów.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="29-33">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<p>Konstruktor kopiujący w praktyce - klasa Y</p>
					<small>
						Powtórzenie operacji dla klasy <code>Y</code>, podobne do klasy
						<code>X</code>.
						Inicjacja obiektów <code>y</code> i <code>d</code> klasy
						<code>Y</code>, które są
						odpowiednikami <code>x</code> i <code>j</code> z klasy <code>X</code>.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code style="max-height: 250px;"
											 data-id="code"
											 class="hljs cpp"
											 data-trim
											 data-line-numbers="32-33">
					<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<p>Modifikacja i sprawdzenie obiektów klasy Y.</p>
					<small>
						Modyfikacja łańcucha w obiekcie <code>d</code> nie wpływa na obiekt
						<code>y</code>
						dzięki kopiowaniu głębokiemu realizowanemu przez konstruktor klasy <code>Y</code>.
					</small>
					<small>
						Adresy obiektów <code>y</code> i <code>d</code> powinny być różne,
						w
						przeciwieństwie do obiektów klasy <code>X</code>.
					</small>
				</section>


				<section>
					<h3>Wyniki działania programu</h3>
					<pre style="font-size: 16px"><code class="hljs" data-trim>
													  x=xxx, j=xxx
													  x=111, j=111
													  x.p=2707:0004, j.p=2707:0004
													  y=yyy, d=yyy
													  y=yyy, d=222
													  y.p=270D:0004, d.p=2713:0004
														</code></pre>
					<p style="font-size: 0.75em;">
						Powysze linie demonstrują rezultaty wykonania programu. Zauważamy,
						że obiekty
						<code>x</code> i <code>j</code> dzielą tę samą przestrzeń pamięci, podczas gdy
						<code>y</code> i
						<code>d</code> mają oddzielne lokalizacje, co jest wynikiem kopiowania głębokiego
						zaimplementowanego w
						konstruktorze klasy <code>Y</code>.
					</p>
				</section>
				<section>
					<h3>Metody tworzenia obiektów</h3>
					<div class="row">
						<div class="col" style="float: left; width: 50%; font-size: 0.65em;">
							<ul>
								<li>
									Zmienne automatyczne:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>Atype a; // konstruktor domyślny</code></pre>
								</li>
								<li>
									Zmienne z argumentami:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>Atype a(3); // konstruktor z parametrem int</code></pre>
								</li>
								<li>
									Przekazywanie parametrów przez wartość:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
									<script type="text/template">
						void f(Atype b) { ... }
						f(a); // konstruktor kopiujący
														</script></code></pre>
								</li>
							</ul>
						</div>
						<div class="col" style="float: right; width: 50%; font-size: 0.65em;">
							<ul>
								<li>
									Przypisanie wartości zmiennym:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
									<script type="text/template">
						Atype a, b;
						a = b; // operator przypisania
																</script>
																</code></pre>
								</li>
								<li>
									Inicjalizacja nowych obiektów:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>Atype a = b; // konstruktor kopiujący</code></pre>
								</li>
								<li>
									Zwracanie wartości z funkcji:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim><script type="text/template">
						Atype f() {
						    Atype a;
						    return a; // konstruktor kopiujący
						}
						</script>
														</code></pre>
								</li>
							</ul>
						</div>
					</div>
					<div style="clear: both;"></div>
				</section>
				<section>
					<h3>Cechy poprawnie napisanej klasy</h3>
					<small>
						Jawny konstruktor gwarantuje, że każdy zadeklarowany egzemplarz
						obiektu zostanie w
						kontrolowany sposób zainicjalizowany.
					</small>
					<small>
						Jeżeli obiekt zawiera wskaźniki do dynamicznie zaalokowanej
						pamięci, powinien
						zawierać:
					</small>
					<small>
						<ul>
							<li>
								<strong>Jawny destruktor:</strong> Zapobiega wyciekom pamięci i zwalnia zasoby podczas
								usuwania obiektu.
							</li>
							<li>
								<strong>Jawny operator przypisania:</strong> Używany przy przypisywaniu nowej wartości
								do istniejącego
								obiektu, zapewniając, że obiekt jest istotnie kopią innego obiektu, a nie jego aliasem.
							</li>
							<li>
								<strong>Jawny konstruktor kopiujący:</strong> Używany podczas kopiowania obiektu przy
								przekazywaniu
								parametrów, zwracaniu wartości i inicjalizacji, zapewniając, że obiekt jest istotnie
								kopią innego
								obiektu, a nie jego aliasem.
							</li>
						</ul>
					</small>

				</section>
				<section>
					<h3>Lista inicjalizacyjna konstruktora</h3>
					<p>Rozpatrzmy kod:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
													  class Klasa {
														  const int stala;
														  int& ref;
													  
													  public:
														  Klasa() : stala(1), ref(stala) {
															  // Puste ciało konstruktora
														  }
													  };
														</code></pre>
					<small class="fragment">
						error: uninitialized member 'Klasa::stala' with
						'const' type
						'const int' [-fpermissive]
					</small>
					<small class="fragment">
						error: uninitialized reference member
						'Klasa::ref' [-fpermissive]
					</small>
					<small class="fragment">
						error: assignment of read-only member
						'Klasa::stala'
					</small>
				</section>
				<section>
					<h3>Lista inicjalizacyjna konstruktora</h3>
					<small>
						Niektóre zmienne wymagają inicjalizacji, ponieważ nie można im
						przypisać wartości
						później (np. gdy są to stałe).
					</small>
					<small>
						Lista inicjalizacyjna konstruktora służy do nadawania wartości tym
						składowym w
						momencie ich tworzenia, jeszcze przed wejściem do ciała konstruktora.
					</small>
					<pre><code class="hljs cpp" data-trim contenteditable>
													  class Klasa {
														  const int stala;
														  int& ref;
													  
													  public:
														  Klasa() : stala(1), ref(stala) {
															  // Puste ciało konstruktora
														  }
													  };
														</code></pre>
					<small>
						Tutaj, zaraz po dwukropku, znajdują się jawne wywołania
						konstruktorów oddzielone
						przecinkami, które inicjalizują składowe klasy.
					</small>
				</section>
				<section>
					<h3>Składowe tworzone przez kompilator</h3>
					<p>
						Kompilator może, zwykle dla prostych klas, utworzyć konstruktor
						domyślny,
						kopiujący i operator przypisania (jeśli nie zostały już utworzone):
					</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
					<script type="text/template">
						#include <iostream>
						
						class Klasa {
						public:
						    int x;
						};
						
						int main() {
						    Klasa k1;
						    k1.x = 5;
						
						    Klasa k2(k1); // Konstruktor kopiujący
						    std::cout << k1.x << " " << k2.x << std::endl;
						
						    k2.x = 2;
						    k1 = k2; // Operator przypisania
						    std::cout << k1.x << " " << k2.x << std::endl;
						}
						</script></code></pre>

				</section>
				<section data-auto-animate>
					<h3>Elementy składowe klas i struktur</h3>
					<small>
						Klasa i struktura (Struct) są bardzo podobne. Struktury z
						definicji mają wszystkie
						składowe dostępne (publiczne), a klasy z definicji mają wszystkie składowe prywatne, ukryte
						pod wskaźnikiem
						<code>this</code> (C++) albo odpowiednio zarządzaną referencją (Java).
					</small>
					<small>
						Klasa lub struktura składa się z jej składowych. Praca wykonywana
						przez klasę jest
						wykonywana przez jej funkcje członkowskie. Stan, który utrzymuje, jest przechowywany w jego
						składowych
						danych. Inicjowanie elementów członkowskich jest wykonywane przez konstruktory, a prace
						oczyszczania, takie
						jak zwalnianie pamięci i zwalnianie zasobów, są wykonywane przez destruktory.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Elementy składowe klas i struktur</h3>
					<small>
						W języku C++11 lub nowszym składowe danych mogą (i zwykle powinny)
						być
						zainicjowane w punkcie deklaracji. Konstruktory niejawne, kopiujące, konwertujące,
						przemieszczające oraz
						destruktory definiowane są specjalnie, często niejawnie i nazywane są specjalnymi funkcjami
						składowymi klas.
					</small>
					<small>
						Funkcje składowe są statyczne lub niestatyczne. Zachowanie
						statycznych funkcji
						członkowskich różni się od innych funkcji członkowskich, ponieważ statyczne funkcje
						członkowskie nie mają
						niejawnego argumentu <code>this</code>. Niestatyczne funkcje członkowskie mają wskaźnik
						<code>this</code>.
						Funkcje członkowskie, zarówno statyczne, jak i niestatyczne, można zdefiniować w obrębie lub
						poza deklaracją
						klasy.
					</small>

				</section>
				<footer style="position: absolute; bottom: 0; width: 100%;">
					<small style="font-size: 9px;">
						Materiały do tej prezentacji zostały opracowane w oparciu o skrót materiałów wykładowych
						przedmiotu
						Programowanie
						Obiektowe prowadzonego na WAT. Autor materiałów źródłowych: prof. Andrzej Walczak<br>
						Copyrights Military University of Technology in Warsaw
					</small>
				</footer>


			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});

	</script>

</body>

</html>