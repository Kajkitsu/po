<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Programowanie Obiektowe</title>
	<meta name="description" content="PO LAB">
	<meta name="author" content="Norbert Waszkowiak">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
	<style>
		.row {
			display: flex;
		}

		.column {
			flex: 50%;
			padding: 10px;
		}
	</style>
	<style>
		.small-font pre {
			font-size: 13px;
			/* Zmniejszenie czcionki */
			margin-left: 0;
			/* Usunięcie marginesu z lewej strony */
			white-space: pre-wrap;
			/* Zapobieganie przepełnieniu tekstu */
		}
	</style>

</head>

<body>

	<div class="reveal">

		<div class="slides">
			<section data-background-gradient="linear-gradient(45deg, #33, #6754e8)">
				<section style="text-align: left;" data-auto-animate id="waszkowiak"
					data-background-gradient="linear-gradient(45deg, #33, #6754e8)">
					<h2>Programowanie obiektowe</h2>
					<br slyle="height: 600px;" />
					<p style="text-align: left;">por. mgr inż. Norbert Waszkowiak</p>
					<small>nr tel.: 261 839 060</small>
					<br />
					<small>e-mail: norbert.waszkowiak@wat.edu.pl</small>
					<br />
					<small>pomieszczenie: bud. 100 pok. 254B</small>
					<br />
					<small>konsultacje online i stacjanarnie: po wcześniejszym umówieniu</small>
					<br />
				</section>
			</section>
			<section data-background-gradient="linear-gradient(37deg, #2b4a9e, #71a832)">
				<section>
					<h2>Powtórka: Podstawy C/C++</h2>
				</section>
				<section>
					<h2>Tablice w C/C++</h2>
					<p>Tablice to zbiory podobnych elementów danych, umożliwiające grupowanie typów danych, takich jak
						liczby całkowite lub zmiennoprzecinkowe, pod jedną nazwą.</p>
					<p>Aby zadeklarować tablice liczb całkowitych:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
						<script type="text/template">
							int A[5];
					</script></code></pre>
					<p>Tworzy to tablicę A z 5 elementami typu integer.</p>
				</section>
				<section>
					<h2>Gdzie lądują tablice</h2>
					<p>W programie C/C++ tablica jest zwykle alokowana w segmencie stosu głównej pamięci.</p>
					<p>Tablice można deklarować i inicjować jednocześnie:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
                            int A[5] = {1, 2, 3, 4, 5};
                    </script></code></pre>
					<p>Można też manualnie modyfikować wartości w określonych indeksach:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
A[0] = 27;
A[1] = 10;
                    </script></code></pre>
				</section>
				<section>
					<h2>Struktura pamięci</h2>
					<p>Gdy tablica jest deklarowana w funkcji, pojawia się w stosie głównej pamięci i jest bezpośrednio
						dostępna dla funkcji main.</p>
					<p>Aby uzyskać dostęp do wszystkich elementów tablicy, często używa się pętli for. Na przykład:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
for (int i = 0; i < 5; i++) {
    printf("%d ", B[i]);
}
                    </script></code></pre>
				</section>
				<section>
					<h2>Wskaźniki w C/C++</h2>
					<p>Wskaźnik to zmienna adresowa przeznaczona do przechowywania adresu danych, a nie samych danych.
						Zmienne zwykłe przechowują dane, natomiast wskaźniki - adresy. Wskaźniki są używane do
						pośredniego dostępu do danych.</p>
				</section>
				<section>
					<h2>Po co używać wskaźników?</h2>
					<p>Wskaźniki są potrzebne do dostępu do pamięci poza programem, takiej jak pamięć sterty (heap).</p>
				</section>
				<section>
					<p>Deklarowanie i Inicjalizacja wskaźników</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
int a = 10; // Zmienna danych
int *p;     // Wskaźnik
p = &a;     // Inicjalizacja wskaźnika adresem zmiennej 'a'							
                    </script></code></pre>
					<p>Dereferencja to proces uzyskiwania dostępu do wartości, na którą wskazuje wskaźnik:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
printf("%d", *p); // Wydrukuje wartość zmiennej 'a' poprzez wskaźnik 'p'						
                    </script></code></pre>
					<p>Wskaźniki umożliwiają dynamiczne alokowanie pamięci:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
p = (int *)malloc(5 * sizeof(int)); // Alokacja 5 intów w C						
                    </script></code></pre>
				</section>
				<section>
					<h2>Zastosowanie Wskaźników</h2>
					<p>Dostęp do pamięci sterty.</p>
					<p>Dostęp do zasobów zewnętrznych (np. plików, urządzeń).</p>
					<p>Przekazywanie parametrów przez wskaźniki.</p>
				</section>
				<section>
					<h2>Wskaźniki w C++</h2>
					<p>W C++, wskaźniki i dynamiczna alokacja pamięci są kluczowe dla zarządzania zasobami. Alokacja
						dynamiczna jest prostsza dzięki operatorowi `new`:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
int *p = new int[5]; // Alokacja tablicy 5 całkowitych liczb						
                    </script></code></pre>
					<p>Ta linijka kodu alokuje miejsce dla 5 liczb całkowitych w pamięci sterty i przypisuje adres
						pierwszego elementu do wskaźnika p.</p>
				</section>
				<section>
					<p>Możliwy jest też dostęp do elementów tablicy z użyciem wskaźnika `p` jako tablicy do zapisywania
						wartości:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
for(int i = 0; i < 5; i++) {
	p[i] = i * 10; // Ustawienie wartości elementów tablicy
}													
                    </script></code></pre>
				</section>
				<section>
					<h2>Zwalnianie pamięci</h2>
					<p>Pamięć zaalokowana przez `new` musi być zwolniona za pomocą `delete`, a pamięć zaalokowana przez
						`malloc` jest zwalniana przez `free`.</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
free(tablica);
delete[] p; // Zwolnienie zaalokowanej pamięci						
                    </script></code></pre>
				</section>
				<section>
					<h2>Wskaźniki i Struktury</h2>
					<p>Wskaźniki mogą być również używane do dostępu do struktur:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
struct Rectangle {
	int length;
	int breadth;
};

Rectangle *ptr = new Rectangle; // Alokacja pamięci dla struktury
ptr->length = 10; // Ustawienie wartości składowej za pomocą wskaźnika
ptr->breadth = 20;
delete ptr; // Zwolnienie pamięci												
                    </script></code></pre>
				</section>
				<section>
					<h2>Co nam to daje?</h2>
					<p>Wskaźniki są używane do przekazywania dużych struktur lub tablic do funkcji bez konieczności ich
						kopiowania, co jest efektywne pod względem pamięci:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
                        <script type="text/template">
void updateValue(int *pValue) {
	*pValue = 100; // Modyfikacja wartości przez wskaźnik
}
int value = 5;
updateValue(&value); // Przekazanie adresu zmiennej																	
                    </script></code></pre>
				</section>
				<section>
					<h2>Zaawansowane wskaźniki</h2>
					<p>Wskaźniki mogą być również używane do tworzenia bardziej złożonych struktur danych, takich jak
						listy połączone, drzewa, grafy itd., i są niezbędne do zaawansowanych technik programowania w
						C++. O tym może kiedyś...</p>
				</section>
			</section>
			<section data-background-gradient="linear-gradient(37deg, #2b4a9e, #71a832)">
				<section>
					<h2>Klasa i obiekt dla zielonych</h2>
				</section>
				<section>
					<h2>Co to jest Klasa i Obiekt?</h2>
					<p>Klasa to szablon lub projekt, który określa, jakie właściwości (dane) i działania
						(funkcje/metody) będzie miał obiekt.</p>
					<p>Obiekt to konkretna instancja klasy, zawierająca rzeczywiste dane i umożliwiająca wykonanie
						zdefiniowanych działań.</p>
				</section>
				<section>
					<h2>Implementacja</h2>

					<div class="row">
						<div class="column">
							<h3>Python:</h3>
							<pre style="font-size: 16px;"><code class="python">
class Author:
	def __init__(self, name, surname):
		self.name = name
		self.surname = surname

# tworzenie obiektu 'author1'
author1 = Author("Jan", "Kowalski")
												</code></pre>
						</div>

						<div class="column">
							<h3>C++:</h3>
							<pre style="font-size: 16px;"><code class="cpp">class Author {
public:
    std::string name;
    std::string surname;
};

// tworzenie obiektu 'author1'
Author author1;
author1.name = "Jan";
author1.surname = "Kowalski";
                    </code></pre>
						</div>
					</div>
				</section>
				<section>
					<h2>Klasy vs Obiekty - Przykład</h2>
					<p>Klasa Author określa, że każdy autor ma imię i nazwisko.</p>
					<p>Obiekt klasy Author, np. author1, ma konkretne imię i nazwisko.</p>
				</section>
				<section>
					<h2>Implementacja</h2>

					<div class="row">
						<div class="column">
							<h3>Python:</h3>
							<pre style="font-size: 16px;"><code class="python"># Klasa Author
class Author:
	def __init__(self, name, surname):
		self.name = name
		self.surname = surname

# Obiekt author1 klasy Author
author1 = Author("Jan", "Kowalski")
							</code></pre>
						</div>

						<div class="column">
							<h3>C++:</h3>
							<pre style="font-size: 16px;"><code class="cpp">
// Klasa Author
class Author {
public:
	std::string name;
	std::string surname;
};

// Obiekt author1 klasy Author
Author author1;
author1.name = "Jan";
author1.surname = "Kowalski";
							</code></pre>
						</div>
					</div>
				</section>
				<section>
					<h2>Zmienne i Typy w Programowaniu</h2>
					<p style="font-size: 0.75em;">Typ zmiennej określa, jakiego rodzaju wartości może przechowywać
						zmienna.</p>
					<p style="font-size: 0.75em;">Klasa jest jak niestandardowy typ danych, który sami definiujemy.</p>
					<p style="font-size: 0.75em;">Obiekt to zmienna, która przechowuje dane typu klasy.</p>
					<pre><code class="cpp">// int to typ, a number to zmienna
int number = 5;

// Author to klasa (typ), a author1 to obiekt (zmienna)
Author author1;
author1.name = "Jan";
author1.surname = "Kowalski";					
												</code></pre>
				</section>
				<section>
					<h2>Po co nam ta obiektowość?</h2>
					<p style="font-size: 0.85em;">Programowanie obiektowe (OOP) umożliwia hermetyzację danych, co
						zapewnia bezpieczeństwo i integralność informacji.</p>
					<p style="font-size: 0.85em;">Dzięki dziedziczeniu, OOP wspiera ponowne użycie i rozszerzalność
						kodu, a polimorfizm pozwala na dynamiczniejsze zachowania.</p>
					<p style="font-size: 0.85em;">Dla porównania, struktury danych są bardziej podstawowe i nie oferują
						tych zaawansowanych funkcji.</p>
					<p style="font-size: 0.85em;">OOP jest kluczowe w tworzeniu złożonych, łatwych w utrzymaniu
						systemów, podczas gdy struktury są odpowiednie dla prostych zadań.</p>
				</section>
				<section>
					<h2>Struktura vs Klasa dla Samochodu</h2>
					<div class="row">
						<div class="column small-font">
							<h3>Struktura:</h3>
							<pre style="max-width: 600px;"><code class="python">// Definicja struktury Car
struct Car {
	std::string brand;
	int year;
};

int main() {
	// Tworzenie i inicjalizacja obiektu Car
	Car myCar;
	myCar.brand = "Toyota";
	myCar.year = 2020;

	// Wyświetlanie danych
	std::cout << "Samochód: " << myCar.brand << 
	  ", Rok: " << myCar.year << std::endl;

	return 0;
}
							</code></pre>
						</div>

						<div class="column small-font">
							<h3>Klasa:</h3>
							<pre style="max-width: 600px;">
								<code class="cpp">// Definicja klasy Car
class Car {
private:
	std::string brand;
	int year;

public:
	Car(const std::string &brand, int year)
		: brand(brand), year(year) {}

	void print() const {
		std::cout << "Samochód: " << brand << 
		  ", Rok: " << year << std::endl;
	}
};

int main() {
	// Tworzenie i inicjalizacja obiektu Car
	Car myCar("Toyota", 2020);

	// Wywołanie metody print
	myCar.print();

	return 0;
}	
							</code></pre>
						</div>
					</div>
				</section>
				<section>
					<h2>Różnice i Kiedy Używać</h2>

					<div class="row">
						<div class="column small-font">
							<h3>Struktury:</h3>
							<p style="font-size: 0.85em;"></p>Proste przechowywanie danych.</p>
							<p style="font-size: 0.85em;"></p>Brak hermetyzacji; wszystkie pola są publiczne i dostępne
							bezpośrednio.</p>
							<p style="font-size: 0.85em;"></p>Brak metod; służy głównie jako kontener danych.</p>
						</div>
						<div class="column small-font">
							<h3>Klasy:</h3>
							<p style="font-size: 0.85em;">Zawiera metody (np. print) do interakcji z danymi.</p>
							<p style="font-size: 0.85em;">Hermetyzuje dane; pola są prywatne, a dostęp do nich jest
								kontrolowany przez publiczne metody.</p>
							<p style="font-size: 0.85em;">Idealne do bardziej złożonych zastosowań, gdzie wymagana jest
								kontrola i rozszerzalność.</p>
						</div>
					</div>
				</section>
				<section>
					<h2>"Profesjonalna" klasa</h2>
					<pre style="font-size: 16px"><code  
						class="hljs cpp" 
						data-trim 
						data-line-numbers>
						<script type="text/template">
#include <iostream>
#include <string>
#include <vector>
#include <map>

class Player {
private:
	std::string name;
	int health;
	int mana;
	std::map<std::string, int> inventory; // Przechowuje przedmioty i ich ilość
	std::vector<std::string> skills; // Lista umiejętności

public:
	Player(const std::string &name, int health, int mana)
		: name(name), health(health), mana(mana) {}

	void takeDamage(int amount) {
		health -= amount;
		if (health < 0) health = 0;
	}

	void useItem(const std::string &item) {
		if (inventory[item] > 0) {
			// Logika używania przedmiotu
			inventory[item]--;
		} else {
			std::cout << "Nie masz " << item << std::endl;
		}
	}

	void learnSkill(const std::string &skill) {
		skills.push_back(skill);
	}

	void printStatus() const {
		std::cout << "Gracz: " << name << "\n"
					<< "Zdrowie: " << health << "\n"
					<< "Mana: " << mana << std::endl;
	}

	// Dodatkowe metody...
};

int main() {
	Player hero("Arthas", 100, 50);
	hero.learnSkill("Fireball");
	hero.takeDamage(20);
	hero.useItem("Health Potion");
	hero.printStatus();

	return 0;
}		
</script></code></pre>
				</section>
			</section>


<section id="start" data-background-gradient="linear-gradient(13deg, #3a6935, #b5b170)">

  <section data-auto-animate>
    <h2>Wstęp do programowania obiektowego</h2>
  </section>

  <section data-auto-animate>
    <h3>Po co nam obiektowość?</h3>
    <ul class="poplist">
      <li class="fragment"><b>Hermetyzacja (enkapsulacja)</b> — ukrycie szczegółów implementacyjnych, odsłonięty interfejs → większe bezpieczeństwo i łatwiejsza konserwacja.</li>
      <li class="fragment"><b>Dziedziczenie</b> — współdzielenie i ponowne użycie kodu; rozszerzalność bez duplikacji.</li>
      <li class="fragment"><b>Polimorfizm</b> — wspólny interfejs, różne implementacje; zachowanie wybierane w run-time.</li>
      <li class="fragment">Lepsze modelowanie złożonych systemów niż w „gołych” strukturach; klasy to <i>typy dziedzinowe</i>.</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Podstawowe pojęcia</h3>
    <ul class="poplist">
      <li class="fragment"><b>Klasa</b> — definicja typu: atrybuty (dane) i metody (zachowania).</li>
      <li class="fragment"><b>Obiekt</b> — egzemplarz klasy (stan + tożsamość + zachowanie).</li>
      <li class="fragment"><b>Atrybut</b> — informacja zapamiętana w obiekcie (np. <code>title</code>, <code>year</code>).</li>
      <li class="fragment"><b>Metoda</b> — operacja wykonywana na obiekcie (np. <code>load()</code>, <code>area()</code>).</li>
    </ul>
  </section>

</section>

			<section id="start" data-background-gradient="linear-gradient(13deg, #3a6935, #b5b170)">
				<section data-auto-animate>
					<h2>Wstęp do programowania obiektowego cz.2</h2>
				</section>
				<section data-auto-animate>
					<h3>Konstruktory</h3>
					<small>Konstruktor <b>NIE MUSI</b> wystąpić w opisie klasy, czyli obiekty nie muszą być wprowadzane
						konstruktorem <B>jawnym</B>.</small>
					<small><b>Nazwa konstruktora może być przeładowana bo jest on funkcją</b>, czyli może być ta nazwa
						stosowana wielokrotnie w opisie
						deklaracji klasy oraz w opisie funkcji konstruktora z różnymi listami argumentów. Wtedy
						kompilator odróżnia konstruktory
						po listach argumentów, tak, jak w przypadku przeładowanych nazw funkcji. Konstruktorów może wiec
						być wiele.</small>
					<small>Konstruktor <b>może być wywoływany ( a nie deklarowany!!) bez żadnych argumentów</b>. Jest to
						tak zwany konstruktor domniemany.
						Czasem nazywamy go domyślnym albo standardowym. Ze względu na istotę przeładowania nazwy
						<b>konstruktor domniemany czyli
							bezargumentowy może wystąpić tylko raz</b>. Jeśli nie deklarujemy w klasie żadnego
						konstruktora, to kompilator sam ustanawia
						właśnie konstruktor domniemany do obsługi obiektów klas deklarowanych w programie. Każdy
						konstruktor z argumentami,
						którym nadamy wartości domyślne czyli niedefiniowalne jest także konstruktorem
						domniemanym.</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktory</h3>
					<p>Co właściwie robi konstruktor? On <b>INICJALIZUJE</b> obiekty. Kompilator automatycznie wywołuje
						konstruktor w miejscu
						tworzenia obiektu zanim jeszcze obiekt podejmie jakiekolwiek działanie. <b>Czyli po pierwszym
							komunikacie na obiekt
							startuje konstruktor</b>. Nazwa konstruktora taka sama jak nazwa klasy (pomysł Stroustrupa)
						pozwala na jednoznaczne
						powiązanie konstruktora z typem zmiennej obiektowej (wykorzystano operator zakresu).</p>
				</section>
				<section>
					<h3>Konstruktory</h3>
					<small>
						<b>Konstruktor jest zwykle deklarowany jako publiczny</b>, bo przecież wprowadzane nim obiekty
						mogą być używane przez klasy
						zewnętrzne. Możemy jednak dla konstruktora przewidzieć ochronę tak, jak dla klas za pomocą
						etykiet <b>private</b> lub
						<b>protected</b>. Wówczas jednak także konstruowane obiekty będą dostępne tylko w obrębie klasy
						z tym konstruktorem jako
						private albo jako protected tylko w zakresie klas dziedziczących.
					</small>
					<small>
						Konstruktor może zamiast definiować obiekty podawać kopie obiektów zawartych w innej klasie lub
						tworzyć kopie obiektów
						istniejących. Wtedy jest to tak zwany <b>konstruktor kopiujący</b>.
					</small>
					<small>
						Konstruktor może dokonywać konwersji typu obiekty z jednego w drugi. Nazywamy go wtedy
						<b>konstruktorem konwertującym</b>.
					</small>
				</section>
				<section>
					<h3>Konstruktory</h3>
					<p>
						Destruktor (w naszym przykładzie <b>~Card</b>), zawsze wpisujemy w C++ do deklaracji klasy jako
						bezargumentowy !!
					</p>
				</section>
				<section data-auto-animate>
					<h3>Konstruktory</h3>
					<p>Konstruktor domniemany (ang. default constructor)</p>
					<pre style="font-size: 16px" data-id="code-animation">
																												<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="9|15"><script type="text/template">
	#include <iostream>
	#include <cstring>
	 
	class Card {
	public:
	    char color[80]{};
	    int value;
	    
	    Card(char* color = "czarna", int value = 4);
	 
	    void print();
	};
	 
	int main() {
	    Card k1, k2("czerwona");
	    
	    k1.print();
	    k2.print();
	    
	    strcpy(k1.color, "czarno-czerwona");
	    k2.value = 28;
	    
	    std::cout << std::endl;
	    
	    k1.print();
	    k2.print();

	    return 0;
	}
	 
	Card::Card(char* color, int value) {
					strcpy(this->color, color);
					this->value = value;
	}
	void Card::print() {
					std::cout << "Color: " << color << ", Value: " << value << std::endl;
	}
																			</script>
																												</code>
																												</pre>
					<small>
						Konstruktor domyślny (ang. default constructor) w języku C++ jest specjalnym rodzajem
						konstruktora, który jest wywoływany bez
						żadnych argumentów podczas tworzenia obiektu klasy. Gdy w klasie nie zdefiniowano żadnych
						konstruktorów, kompilator
						automatycznie generuje konstruktor domyślny. Jednakże, jeśli w klasie zdefiniowano jakikolwiek
						inny konstruktor (np.
						konstruktor z parametrami), konstruktor domyślny nie jest już automatycznie generowany, chyba że
						został zdefiniowany
						jawnie przez programistę.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktory</h3>
					<p>Konstruktor domniemany (ang. default constructor)</p>
					<pre style="font-size: 16px" data-id="code-animation">
																												<code style="max-height: 250px" class="hljs cpp" data-trim data-line-numbers="15"><script type="text/template">
	#include <iostream>
	#include <cstring>
	 
	class Card {
	public:
	    char color[80]{};
	    int value;
	    
	    Card(char* color = "czarna", int value = 4);
	 
	    void print();
	};
	 
	int main() {
	    Card k1, k2("czerwona");
	    
	    k1.print();
	    k2.print();
	    
	    strcpy(k1.color, "czarno-czerwona");
	    k2.value = 28;
	    
	    std::cout << std::endl;
	    
	    k1.print();
	    k2.print();

	    return 0;
	}
	 
	Card::Card(char* color, int value) {
					strcpy(this->color, color);
					this->value = value;
	}
	void Card::print() {
					std::cout << "Color: " << color << ", Value: " << value << std::endl;
	}
																			</script>
																												</code>
																												</pre>
					<small>
						W przypadku, gdy konstruktor z parametrami zawiera domyślne wartości dla tych parametrów, mówimy
						również o konstruktorze
						z domyślnymi parametrami. Jednak sama idea konstruktora domyślnego polega na tworzeniu obiektu
						bez konieczności
						dostarczania jakichkolwiek parametrów w momencie jego inicjalizacji.
					</small>
				</section>
				<section>
					<h3>Cechy obiektów</h3>
					<small>Poprzez sposób definiowania obiektu decydujemy o zakresie ważności jego nazwy czyli także o
						czasie jego życia. Zakres
						ważności obiektu definiują nawiasy klamrowe w deklaracji klasy. W javie i C++ jeśli przydzielimy
						na obiekt pamięć
						operatorem <b>new</b>, to obiekt istnieje także poza swoim zasięgiem. W C++ muszą być niszczone,
						w javie następuje to
						automatycznie (garbage collector). Kiedy <b>nie ma komunikatów</b> wiążących obiekt z
						jakimkolwiek atrybutem klasy uznaje się,
						że obiekt „wychodzi z zakresu ważności klasy” i może być usunięty.</small>
					<small>Jeśli obiekt jest definiowany w dostępie publicznym to rozumiemy, że jest dostępny globalnie
						czyli mogą z niego
						korzystać wszystkie funkcje i obiekty oraz funkcje składowe innych klas w programie.</small>
				</section>
				<section>
					<h3>Cechy obiektów</h3>
					<small>Obiekt może funkcjonować lokalnie (obiekt prywatny) i wówczas automatycznie kończy się jego
						zakres ważności wtedy, kiedy
						fragment programu (klasa, blok) pozostaje zakończona faktycznie. Taki obiekt –podobnie jak
						zmienna lokalna – traci swoje
						cechy (pomimo hermetyzacji) w zakresie wartości jego zmiennych i metod. Taki obiekt, podobnie
						jak zmienną lokalną,
						będziemy uważać za zapisywany automatycznie.</small>
					<small>Obiekt globalny jest inicjalizowany inaczej niż lokalny bo wstępnie (zanim zacznie
						funkcjonować jako <b>konkret</b> (czyli
						operować wartościami swoich atrybutów) jest inicjowany zerami.</small>
				</section>
				<section>
					<h3>Cechy obiektów</h3>
					<small>Obiekt można utworzyć jako obdarzony słowami sterującymi (moderatorami). W szczególności może
						to być moderator <b>static</b>.
						Taki obiekt, nawet jeśli jest lokalny, zachowa swoje wartości zmiennych i metod takie, jak przy
						ostatnim komunikacie.
						Inicjalizacja jest tu podobna jak obiektu globalnego – wartościami zerowymi. W javie taki
						moderator służy do wskazania,
						że metody (poprzedzonej słowem static) nie wiążemy z żadnym obiektem, czyli egzemplarzem
						klasy.</small>
					<small>Jeśli atrybutu static użyjemy do nazwy globalnej, to może ona być dostępna TYLKO W SWOIM
						PLIKU. Oznacza to, że NIE MOGĘ
						uzyskać dostępu do takiego obiektu wtedy, kiedy jest on w pliku dołączonym dyrektywą
						preprocesora include jako plik
						nagłówkowy.</small>
				</section>

				<section>
					<h3>this - WSKAŹNIK SPECJALNY</h3>
					<small>Każdej funkcji - metodzie zadeklarowanej wewnątrz klasy zostaje
						<b>w momencie wywołania w niejawny sposób (ang. implicitly)
							przekazany wskaźnik do obiektu</b> (w stosunku do którego funkcja ma
						zadziałać). Pointer wskazuje funkcji w pamięci operacyjnej ten obiekt, którego atrybutem jest
						dana funkcja. Bez
						istnienia takiego
						właśnie wskaźnika nie moglibyśmy stosować spokojnie funkcji, nie
						moglibyśmy odwoływać się do pola obiektu, gdybyśmy nie wiedzieli
						jednoznacznie, o który obiekt chodzi.</small>
					<small><b>Wskaźnik this jest pierwszym argumentem konstruktora obiektu.</b>W konstruktorze wskazuje
						on na nie zainicjalizowany fragment pamięci, a rolą konstruktora jest właśnie inicjalizacja na
						rzecz konkretnego obiektu (konkretu).Wskaźnik this jest pierwszym argumentem konstruktora
						obiektu. W konstruktorze
						wskazuje on na nie zainicjalizowany fragment pamięci, a rolą konstruktora jest właśnie
						inicjalizacja na rzecz
						konkretnego obiektu (konkretu).</small>
					<small><b>Wniosek: wskaźnik this jest narzędziem zapewniającym hermetyzację (czyli ochronę) danych w
							obiekcie, bo każdy obiekt ma
							swój i tylko swój wskaźnik this.</b></small>
				</section>


				<section>
					<h3>this - WSKAŹNIK SPECJALNY</h3>
					<small>Program posługuje się automatycznie niejawnym wskaźnikiem do obiektu (ang. implicit pointer).
						Możemy wykorzystać ten
						istniejący, choć do tej pory niewidoczny dla nas pointer posługując się słowem kluczowym
						<b>this</b> (ten). This pointer
						<b>wskazuje na obiekt</b>, do którego należy funkcja. Korzystając z tego wskaźnika funkcja może
						bez cienia
						wątpliwości zidentyfikować właśnie ten obiekt, z którym pracuje
						a nie obiekt przypadkowy.</small>
					<small>FUNKCJE KATEGORII static NIE OTRZYMUJĄ POINTERA this.
						Należy pamiętać, że wskaźnik this istnieje wyłącznie podczas
						wykonywania metod (ang. class member function execution), za
						wyjątkiem funkcji statycznych.</small>
				</section>




				<section>
					<h3>Tablica wirtualna</h3>
					<small>W C++ tablica wirtualna jest specjalnym rodzajem tablicy, która pozwala na dynamiczne
						dziedziczenie i rozstrzyganie
						wywołań funkcji w czasie rzeczywistym podczas działania programu. Jest to związane z mechanizmem
						dziedziczenia
						wielokrotnego, w którym pochodna klasa dziedziczy zarówno po klasie bazowej, jak i po innej
						klasie, która dziedziczy po
						tej samej klasie bazowej.</small>
					<small>Mechanizm ten wymaga użycia specyfikatora <b>virtual</b> podczas dziedziczenia, aby zapewnić
						poprawne wywoływanie metod klasy
						bazowej przez obiekty pochodne.</small>
					<small>Ogólnie rzecz biorąc, tablica wirtualna pozwala na dynamiczne wiązanie metod w czasie
						wykonania programu. Dzięki niej
						możliwe jest zapewnienie poprawnego wywoływania metod z klasy bazowej, nawet gdy są one
						nadpisywane w klasach
						pochodnych.</small>
				</section>
				<section data-auto-animate>
					<h3>Tablica wirtualna</h3>

					<pre style="font-size: 14px" data-id="code-animation">
																																						<code style="max-height: 250px;" class="hljs cpp" data-trim data-line-numbers><script type="text/template">
class KlasaBazowa {
public:
    virtual void metoda() {
        // Implementacja metody w klasie bazowej
    }
};

class KlasaPochodna : public KlasaBazowa {
public:
    void metoda() override {
        // Implementacja przesłoniętej metody w klasie pochodnej
    }
};

int main() {
    KlasaBazowa* wskaznik;

    KlasaBazowa obiektBazowy;
    KlasaPochodna obiektPochodny;

    wskaznik = &obiektBazowy;
    wskaznik->metoda(); // Wywołuje metodę z klasy bazowej

    wskaznik = &obiektPochodny;
    wskaznik->metoda(); // Wywołuje metodę z klasy pochodnej

    return 0;
}
																													</script>
																																						</code>
																																						</pre>
					<small>
						W tym przykładzie, wykorzystując wirtualne funkcje w klasie bazowej i przesłonięcie tych funkcji
						w klasie pochodnej,
						możliwe jest dynamiczne wywoływanie odpowiednich metod w czasie działania programu. Używając
						wskaźnika do obiektu klasy
						bazowej, program może wywoływać metody zarówno z klasy bazowej, jak i pochodnej, w zależności od
						rzeczywistego typu
						obiektu wskazywanego przez wskaźnik.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Tablica wirtualna</h3>

					<pre style="font-size: 14px" data-id="code-animation">
																																						<code style="max-height: 250px;" class="hljs cpp" data-trim data-line-numbers><script type="text/template">
class KlasaBazowa {
public:
    virtual void metoda() {
        // Implementacja metody w klasie bazowej
    }
};

class KlasaPochodna : public KlasaBazowa {
public:
    void metoda() override {
        // Implementacja przesłoniętej metody w klasie pochodnej
    }
};

int main() {
    KlasaBazowa* wskaznik;

    KlasaBazowa obiektBazowy;
    KlasaPochodna obiektPochodny;

    wskaznik = &obiektBazowy;
    wskaznik->metoda(); // Wywołuje metodę z klasy bazowej

    wskaznik = &obiektPochodny;
    wskaznik->metoda(); // Wywołuje metodę z klasy pochodnej

    return 0;
}
																													</script>
																																						</code>
																																						</pre>
					<small>
						Ta elastyczność i zdolność do dynamicznego wiązania
						nazywane są tablicą wirtualną
						(ang. virtual table) - strukturą danych używaną do przechowywania wskaźników do funkcji
						wirtualnych. Ta tabela umożliwia
						wywołanie odpowiednich metod w zależności od rzeczywistego typu obiektu w czasie wykonania
						programu.
					</small>
				</section>

				<section>
					<h3>Tworzenie obiektów</h3>
					<p>
						Kiedy w C++ tworzony jest obiekt zachodzą dwa procesy:
					<ul>
						<li>alokacja pamięci na obiekt</li>
						<li>inicjalizacja obiektu</li>
						</p>
				</section>
				<section>
					<h3>Tworzenie obiektów</h3>
					<small>
						Pierwszy proces może być wykonany na różne sposoby i w różnym czasie:
						<ul>
							<li>Pamięć może zostać przydzielona, zanim zacznie się praca programu –w obrębie obszaru
								danych
								statycznych. Obszar ten
								istnieje przez cały czas działania programu.</li>
							<li>Pamięć może zostać przydzielona na stosie kiedy zostanie osiągnięty określony punkt
								realizacji programu (klamrowy nawias
								otwierający). Jest ona zwalniana po pojawieniu się klamrowego nawiasu zamykającego.
								Tutaj
								potrzebna jest wiedza o
								liczbie i rozmiarze wykorzystywanych zmiennych aby nie przekroczyć rozmiaru stosu.</li>
							<li>Pamięć jest przydzielana na stercie. Jest to proces dynamiczny. Jest on obsługiwany
								odpowiednią funkcją. Czyli
								przydziela ją i zwalnia program (czytaj programista) [malloc(), free() w <cstdlib>, new,
									delete w standardowej
									bibliotece poprzez przestrzeń nazw (namespace)]</li>
					</small>
				</section>
				<section>
					<h3>Klasy abstrakcyjne i interfejsy</h3>
					<small>Zwykle po to tworzymy klasy by tworzyć ich egzemplarze (instancje/obiekty). Okazuje się
						jednak
						często, że definiujemy
						klasy, które z założenia nie będą nigdy miały swoich obiektów. Takie klasy nazywamy klasami
						abstrakcyjnymi. <br />Wbrew temu,
						co mogłoby się wydawać na pierwszy rzut oka, te klasy pełnią bardzo ważną rolę przy
						projektowaniu hierarchii klas.
						Pozwalają bowiem na wyodrębnienie wspólnych cech wielu definiowanych pojęć (klas) i jawne
						wskazanie, że wszystkie
						dziedziczące klasy muszą te cechy posiadać.</small>
				</section>
				<section>
					<h3>Klasy abstrakcyjne i interfejsy</h3>
					<p>Czasami w klasie abstrakcyjnej chcemy opisać tylko interfejs, bez żadnych danych ani
						implementacji metod. Ponieważ takie
						wydzielenie samego interfejsu jest bardzo ważne w Javie nadano mu specjalną postać składniową i
						nazwano ją interfejsem
						(klasa interfejsu).</p>
				</section>
				<footer style="position: absolute; bottom: 0; width: 100%;">
					<small style="font-size: 9px;">
						Materiały do tej prezentacji zostały opracowane w oparciu o skrót materiałów wykładowych
						przedmiotu
						Programowanie
						Obiektowe prowadzonego na WAT. Autor materiałów źródłowych: prof. Andrzej Walczak<br>
						Copyrights Military University of Technology in Warsaw
					</small>
				</footer>

			</section>

<section data-background-gradient="linear-gradient(67deg, #749c19, #bf3045)">

  <section>
    <h2>Jak czytać diagramy klas?</h2>
  </section>

  <section data-auto-animate>
    <p>
      Diagram klas UML służy do <b>modelowania struktury systemu</b>: pokazuje klasy, ich atrybuty,
      metody oraz relacje między nimi. Dobrze narysowany diagram przekłada się bezpośrednio na kod.
    </p>
  </section>

  <section data-auto-animate>
    <h3>Diagram klas</h3>
    <img class="uml-img" src="assets/class_diagram_Zad1.png" alt="Diagram klas (UML)">
  </section>

  <section data-auto-animate>
    <h3>Jak czytać diagramy klas?</h3>

    <img data-id="uml-diagram" src="assets/class_diagram_Zad1.png"
         class="uml-img--small" alt="Diagram klas (pomniejszony)">

    <ul class="poplist">
      <li class="fragment" data-fragment-index="1">
        <b>Klasy</b>: prostokąty reprezentują klasy; nazwa klasy jest w górnym segmencie.
      </li>
      <li class="fragment" data-fragment-index="2">
        <b>Atrybuty</b>: pod nazwą klasy znajdują się pola (typowane), często z widocznością:
        <code>+</code> public, <code>-</code> private, <code>#</code> protected, <code>~</code> package.
      </li>
      <li class="fragment" data-fragment-index="3">
        <b>Metody</b>: w najniższym segmencie — sygnatura <code>nazwa(parametry): typ</code>.
      </li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Widoczność w UML → w kodzie</h3>

    <div class="vis-grid">

      <ul class="vis-list">
        <li class="fragment" data-fragment-index="1"><b>+ public</b> — dostępny wszędzie</li>
        <li class="fragment" data-fragment-index="3"><b>- private</b> — tylko wewnątrz klasy</li>
        <li class="fragment" data-fragment-index="5"><b># protected</b> — klasa i klasy pochodne</li>
        <li class="fragment" data-fragment-index="7"><b>~ package</b> — w obrębie pakietu (Java)</li>
      </ul>

      <div class="code-stack">
        <pre class="fragment code-layer" data-fragment-index="2">
<code class="language-cpp" data-line-numbers="8-11">
class Person {
private:                    // - private
    std::string name;

protected:                  // # protected
    int age;

public:                     // + public
    std::string getName() const;
};
</code>
        </pre>

        <pre class="fragment code-layer" data-fragment-index="4">
<code class="language-cpp" data-line-numbers="2-4">
class Person {
private:                    // - private
    std::string name;

protected:                  // # protected
    int age;

public:                     // + public
    std::string getName() const;
};
</code>
        </pre>

        <pre class="fragment code-layer" data-fragment-index="6">
<code class="language-cpp" data-line-numbers="5-7">
class Person {
private:                    // - private
    std::string name;

protected:                  // # protected
    int age;

public:                     // + public
    std::string getName() const;
};
</code>
        </pre>
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Abstrakcja (klasa/metoda abstrakcyjna)</h3>
    <div class="win-grid">
      <pre class="code-box"><code class="language-text">
abstract class Shape {
  + area(): double
}
      </code></pre>

      <pre class="code-box fragment"><code class="language-java">
// Java
abstract class Shape {
  abstract double area();
}
      </code></pre>
    </div>
    <p class="uml-note">W UML elementy abstrakcyjne często zapisuje się <i>kursywą</i>.</p>
  </section>

  <section data-auto-animate>
    <h3>Elementy statyczne</h3>
    <p>W UML <u>podkreślamy</u> atrybuty/metody statyczne; w kodzie to członkowie <i>static</i>.</p>
    <div class="win-grid">
      <pre class="code-box"><code class="language-text">
class Math {
  + _PI: double
  + _add(a:int, b:int): int
}
      </code></pre>

      <pre class="code-box fragment"><code class="language-java">
// Java
class Math {
  static final double PI = 3.14159;
  static int add(int a, int b) { return a + b; }
}
      </code></pre>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Stereotypy (rola elementu)</h3>
    <ul>
      <li class="fragment"><b>«interface»</b> — interfejs (kontrakt)</li>
      <li class="fragment"><b>«enum»</b> — typ wyliczeniowy</li>
      <li class="fragment"><b>«service»</b> — komponent usługowy/warstwa logiki</li>
    </ul>
    <pre class="code-box fragment"><code class="language-text">
«interface» Drawable {
  + draw(): void
}
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Wielokrotności i role</h3>
    <pre class="code-box"><code class="language-text">
Order 1 ─────────── *  OrderLine     (1 do wielu)
Team  1 ───────── 0..* Player        (0 lub wiele)
Graph 0..1 ─────── 1  Root           (opcjonalny)
    </code></pre>
    <ul>
      <li class="fragment"><b>1..*</b> ⇒ kolekcja (lista/wektor), <b>0..1</b> ⇒ wskaźnik/nullable.</li>
      <li class="fragment">Nazwy końców asocjacji („role”) pomagają czytać kierunek i znaczenie relacji.</li>
    </ul>
  </section>


  <section data-auto-animate>
    <h3>Relacje między klasami — definicje</h3>
    <ul class="poplist">
      <li class="fragment" data-fragment-index="1"><b>Dziedziczenie</b> — relacja <i>is-a</i>: klasa pochodna przejmuje i rozszerza cechy bazowej.</li>
      <li class="fragment" data-fragment-index="2"><b>Asocjacja</b> — „ma referencję do”; trwałe powiązanie obiektów (1↔1, 1↔*, *↔*).</li>
      <li class="fragment" data-fragment-index="3"><b>Zależność</b> — „używa”; powiązanie chwilowe (np. parametr metody).</li>
      <li class="fragment" data-fragment-index="4"><b>Kompozycja</b> — silna całość-część; część żyje i ginie z całością (np. <code>Order</code>–<code>OrderLine</code>).</li>
      <li class="fragment" data-fragment-index="5"><b>Agregacja</b> — słabsza całość-część; część może istnieć niezależnie (np. <code>Team</code>–<code>Player</code>).</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h4>Od diagramu do kodu — mini przykład</h4>

    <div class="win-grid">
      <pre class="code-box code-box--compact"><code class="language-text">
«interface» Repository
+ save(e: Entity): void
+ findById(id: Id): Entity?

UserRepository ─ ─ ─ ─ ─ ─▷ Repository   (realizacja)
UserService ───────────────▶ Repository   (zależność)
Order ◆───────────────────── OrderLine *  (kompozycja 1..*)
      </code></pre>

      <pre class="code-box code-box--compact fragment"><code class="language-java">
// Java (odwzorowanie)
interface Repository<E, ID> {
  void save(E e);
  java.util.Optional<E> findById(ID id);
}

final class UserRepository implements Repository<User, Long> {
  @Override public void save(User e) { /*...*/ }
  @Override public java.util.Optional<User> findById(Long id) {
    return java.util.Optional.empty();
  }
}

final class UserService {
  private final Repository<User, Long> repo; // dependency
  UserService(Repository<User, Long> repo) { this.repo = repo; }
}
      </code></pre>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Podsumowanie</h3>
    <ul>
      <li class="fragment">Czytaj: nazwa → atrybuty → metody → widoczność.</li>
      <li class="fragment">Wielokrotności determinują struktury danych (pojedynczy vs kolekcja).</li>
      <li class="fragment">Dobieraj relację do natury domeny: asocjacja / kompozycja / agregacja / dziedziczenie.</li>
    </ul>
  </section>

</section>

<style>
  /* Obrazy UML – skalowanie */
  .reveal .uml-img{
    display:block; margin:0 auto .6rem auto;
    max-height:58vh; width:auto; object-fit:contain;
  }

  .reveal .uml-img--small{ max-height:34vh; }

  /* Lista „popup” – bieżący punkt powiększony */
  .reveal .poplist{
    font-size: clamp(1.1rem, 2.1vw, 1.6rem);
    line-height: 1.35; margin:.25em 0 0;
  }
  .reveal .poplist li{
    margin:.3em 0; transition: transform .25s ease, opacity .25s ease, filter .25s ease;
    transform-origin: 0 0;
  }
  .reveal .poplist li.fragment{ opacity:.45; transform: scale(.96); }
  .reveal .poplist li.fragment.visible{ opacity:.78; transform: scale(.98); }
  .reveal .poplist li.fragment.current-fragment{ opacity:1; transform: scale(1.35); }

  /* Widoczność: układ i skalowanie kodu */
  .reveal .vis-grid{
    display:grid; grid-template-columns: minmax(360px,.9fr) minmax(420px,1fr);
    gap:1.2rem; align-items:start;
  }
  .reveal pre code {
    font-size: 0.9rem;      /* zmniejsza czcionkę */
    line-height: 1.3;       /* ściślejsze odstępy */
  }
  .reveal .vis-list{ font-size: clamp(1rem, 1.8vw, 1.45rem); line-height:1.35; margin:.2rem 0 0; }
  .reveal .code-stack{ position:relative; min-height:42vh; }
  .reveal .code-stack .code-layer{ position:absolute; inset:0; margin:0; overflow:auto; }
  .reveal .code-stack code{ font-size: .95rem; }

  /* Dwa „okna” na kod/diagram – zawsze mieszczą się w kadrze */
  .reveal .win-grid{
    display:grid; gap:1rem;
    grid-template-columns: repeat(2, minmax(0,1fr));
    align-items:start;
  }
  @media (max-width:1200px){
    .reveal .vis-grid{ grid-template-columns:1fr; }
    .reveal .code-stack{ min-height:38vh; }
    .reveal .win-grid{ grid-template-columns:1fr; }
  }

  /* Pudełka na kod: ograniczenie wysokości + przewijanie + elastyczna czcionka */
  .reveal pre.code-box{ margin:0; max-height:42vh; overflow:auto; }
  .reveal pre.code-box code{ font-size:clamp(.82rem, 1.6vw, 1rem); line-height:1.35; }
  .reveal pre.code-box--compact{ max-height:55vh; }
  .reveal .code-inherit code { font-size: 0.7rem;line-height: 1.25; }

  /* Notatki pod slajdami */
  .reveal .uml-note{
    margin-top:.6rem;
    font-size: clamp(1.0rem, 1.6vw, 1.2rem);
  }
</style>

			<section data-background-gradient="linear-gradient(175deg, #08415c, #202155)">
				<section>
					<h2>Pliki nagłówkowe</h2>
				</section>
				<section>
					<p>
						W języku C++, koncepcja podziału klasy na dwie części: plik nagłówkowy (header file) i plik
						źródłowy (source
						file) ma kilka korzyści:
					</p>
					<small>
						<ol>
							<li>
								<strong>Modularność:</strong> Dzięki rozdzieleniu definicji klasy (deklaracji) od jej
								implementacji, możliwe
								jest tworzenie modułów kodu, które można łatwo łączyć. Plik nagłówkowy zawiera zazwyczaj
								deklaracje klas,
								funkcji i innych elementów interfejsu, natomiast plik źródłowy zawiera implementację
								tych
								elementów.
							</li>

							<li>
								<strong>Hermetyzacja:</strong> Dzięki rozdzieleniu interfejsu od implementacji, można
								ukryć
								szczegóły
								implementacyjne przed użytkownikiem klasy. Użytkownicy mogą korzystać z interfejsu
								dostępnego w pliku
								nagłówkowym, nie będąc zaznajomieni z tym, jak dokładnie działa implementacja, co
								ułatwia
								utrzymanie
								tajemnicy implementacyjnej (hermetyzację).
							</li>

							<li>
								<strong>Szybsze kompilacje:</strong> W przypadku zmian w implementacji klasy, konieczne
								jest
								ponowne
								skompilowanie tylko pliku źródłowego, co pozwala na zaoszczędzenie czasu kompilacji.
								Jeśli
								wszystko
								zostałoby umieszczone w jednym pliku, nawet najmniejsza zmiana wymagałaby ponownego
								kompilowania całego
								programu.
							</li>
						</ol>
					</small>

				</section>

				<section>
					<small>
						Przykładowo, rozdzielenie klasy "MojaKlasa" na plik nagłówkowy (MojaKlasa.h) i plik źródłowy
						(MojaKlasa.cpp)
						może wyglądać tak:
					</small>
					<div class="row">
						<div class="col" style="float: left; width: 50%;">
							<pre style="font-size: 14px;"><code><script type="text/template">#ifndef MOJA_KLASA_H
#define MOJA_KLASA_H

class MojaKlasa {
public:
				// deklaracja konstruktora z parametrem
				MojaKlasa(int zmienna); 
				// deklaracja metody
				void metoda(); 
private:
				// deklaracja prywatnej zmiennej
				int zmienna; 
};

#endif // MOJA_KLASA_H</script></code></pre>
							<small><b>MojaKlasa.h</b></small>

						</div>
						<div class="col" style="float: right; width: 50%;">

							<pre style="font-size: 14px;"><code>
												<script type="text/template">#include "MojaKlasa.h"

// implementacja konstruktora
MojaKlasa::MojaKlasa(int zmienna)
				: zmienna(zmienna) {
}

// implementacja metody
void MojaKlasa::metoda() {
				std::cout << "Zmienna: " 
								<< zmienna << std::endl;
}</script></code></pre>
							<small><b>MojaKlasa.cpp</b></small>

						</div>
					</div>
					<small>
						Następnie, w pliku, w którym chcemy użyć klasy, importuje się plik nagłówkowy (<b>#include
							"MojaKlasa.h"</b>) i
						korzysta z
						zadeklarowanego interfejsu. W przypadku kompilacji, konieczne jest dostarczenie zarówno pliku
						nagłówkowego, jak i
						pliku
						źródłowego do kompilatora.
					</small>
				</section>
				<section>
					<h3>Kod preprocesora</h3>
					<small>
						W języku C++, w plikach nagłówkowych, często używa się dyrektyw preprocesora takich jak
						<b>#ifndef</b>,
						<b>#define</b> i <b>#endif</b>
					</small>
					<small>
						<ul>
							<li><b><em>#ifndef</em>(if not defined):</b> - Ten fragment kodu preprocesora sprawdza, czy
								dany symbol lub makro nie został wcześniej zdefiniowany. Jeśli symbol nie
								jest zdefiniowany, to wykonuje się kod znajdujący się między <b>#ifndef</b> a
								odpowiadającym mu <b>#endif</b>. Jeśli symbol jest już
								zdefiniowany, kod pomiędzy tymi dyrektywami jest pomijany. </li>
							<li><b><em>#define</em></b> - Jeśli warunek w #ifndef jest spełniony (symbol nie jest
								zdefiniowany), to <b>#define</b> służy do zdefiniowania tego symbolu. W
								praktyce jest to najczęściej używane do stworzenia tzw. "strażnika wielokrotnego
								dołączania" (include guard). Działa to
								jako swoisty klucz, który uniemożliwia wielokrotne dołączanie tego samego pliku
								nagłówkowego podczas kompilacji.</li>
							<li><b><em>#endif</em></b> - Oznacza koniec bloku warunkowego rozpoczętego przez
								<b>#ifndef</b>. Kody umieszczone między <b>#ifndef</b> a <b>#endif</b> są kompilowane
								tylko wtedy, gdy warunek nie został spełniony (symbol nie jest zdefiniowany). To zamyka
								blok warunkowy.
							</li>
						</ul>
					</small>
				</section>
			</section>

<section data-background-gradient="linear-gradient(155deg,#1f6c8a,#6b2a6f)">

  <section>
    <h2>Dziedziczenie • Polimorfizm • Przeciążanie</h2>
    <p style="font-size:clamp(1rem,1.7vw,1.25rem)">
      Jak projektować hierarchie klas, rozróżniać <b>override</b> od <b>overload</b> i bezpiecznie używać polimorfizmu.
    </p>
  </section>

  <section data-auto-animate>
    <h3>Definicje</h3>
    <ul class="poplist">
      <li class="fragment" data-fragment-index="1">
        <b>Dziedziczenie</b> — tworzenie klasy pochodnej na bazie klasy bazowej (relacja <i>is-a</i>).
      </li>
      <li class="fragment" data-fragment-index="2">
        <b>Polimorfizm (runtime)</b> — jeden interfejs, wiele implementacji; wywołanie wybierane w trakcie działania
        programu (np. <code>virtual</code> + <code>override</code> w C++).
      </li>
      <li class="fragment" data-fragment-index="3">
        <b>Przeciążanie (compile-time)</b> — kilka funkcji/metod o tej samej nazwie, ale różnych parametrach.
      </li>
    </ul>
  </section>

  <section data-auto-animate>
    <h4>Dziedziczenie — od UML do kodu</h4>
    <div class="win-grid">
      <pre class="code-inherit"><code class="language-text">
+-------------------+         +-------------------+
|     Shape         |◁────────|    Rectangle      |
+-------------------+         +-------------------+
| + area(): double  |         | + area(): double  |
| + name(): string  |         | + name(): string  |
+-------------------+         +-------------------+
                         ◁─────+-------------------+
                              |      Circle        |
                              +-------------------+
                              | + area(): double  |
                              | + name(): string  |
                              +-------------------+
      </code></pre>

      <pre class="code-inherit"><code class="language-cpp">
// C++ (interfejs przez klasę abstrakcyjną)
class Shape {
public:
  virtual ~Shape() = default;
  virtual double area() const = 0;     // metoda czysto wirtualna
  virtual std::string name() const { return "Shape"; }
};

class Rectangle : public Shape {
  double w, h;
public:
  Rectangle(double w, double h) : w(w), h(h) {}
  double area() const override { return w * h; }
  std::string name() const override { return "Rectangle"; }
};

class Circle : public Shape {
  double r;
public:
  explicit Circle(double r) : r(r) {}
  double area() const override { return 3.14159 * r * r; }
  std::string name() const override { return "Circle"; }
};
      </code></pre>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Polimorfizm (runtime): wywołanie przez bazę</h3>
    <div class="win-grid">
      <pre class="code-box"><code class="language-cpp">
std::unique_ptr<Shape> s1 = std::make_unique<Rectangle>(3, 4);
std::unique_ptr<Shape> s2 = std::make_unique<Circle>(2);

auto print = [](const Shape& s){
  std::cout << s.name() << " → area=" << s.area() << "\n";
};

print(*s1);   // Rectangle → area=12
print(*s2);   // Circle    → area=12.56636...
      </code></pre>

      <ul class="poplist" style="margin-top:.2rem">
        <li class="fragment"><b>Warunek polimorfizmu</b>: metody wirtualne + wywołanie przez <i>referencję/wskaznik</i> do bazy.</li>
        <li class="fragment"><b>override</b> ⇒ kompilator weryfikuje podpis metody (chroni przed literówkami).</li>
        <li class="fragment"><b>Wirtualny destruktor</b> w klasie bazowej — niezbędny przy usuwaniu przez wskaźnik do bazy.</li>
      </ul>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Overload ≠ Override</h3>
    <div class="win-grid">
      <pre class="code-box"><code class="language-cpp">
// OVERLOAD (kompilacja): ta sama nazwa, różne parametry
struct Math {
  static int  add(int a, int b);
  static double add(double a, double b); // overload po typach
};

// OVERRIDE (runtime): nowa implementacja metody bazowej
struct Base { virtual void run(int x); };
struct Der  : Base { void run(int x) override; };
      </code></pre>

      <ul class="poplist">
        <li class="fragment"><b>Overload</b> — rozstrzygany w <i>kompilacji</i>; dotyczy sygnatury (parametry/const/reference).</li>
        <li class="fragment"><b>Override</b> — rozstrzygany <i>w czasie działania</i>; wymaga wirtualnej metody w bazie.</li>
        <li class="fragment">Uwaga na <b>name hiding</b>: metoda w klasie pochodnej o tej samej nazwie może ukryć przeciążenia z bazy.
          Rozwiązanie: <code>using Base::run;</code> w klasie pochodnej.
        </li>
      </ul>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Dobre praktyki</h3>
    <ul class="poplist">
      <li class="fragment"><b>LSP (Zasada podstawienia Liskov)</b>: obiekt klasy pochodnej musi być poprawnym substytutem bazy.</li>
      <li class="fragment"><b>Interfejsy wąskie i spójne</b> — nie zmuszaj klas pochodnych do implementowania niepotrzebnych metod.</li>
      <li class="fragment"><b>Preferuj kompozycję nad dziedziczeniem</b>, gdy relacja nie jest „is-a”, tylko „has-a/uses”.</li>
      <li class="fragment"><b>Unikaj wielokrotnego dziedziczenia stanu</b> (diament) — w C++ tylko świadomie (virtual inheritance).</li>
      <li class="fragment"><b>Nie dopuszczaj „slicing”</b>: przechowuj polimorficzne obiekty przez wskaźniki/referencje (np. smart pointers).</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Typowe pułapki</h3>
    <div class="win-grid">
      <pre class="code-inferit"><code class="language-cpp">
// 1) Slicing — utrata części pochodnej
std::vector<Shape> v;    // ❌ Shape nie jest „by value” polimorficzny
v.push_back(Rectangle{2,3}); // część Rectangle jest „ucięta”

// ✅ Zamiast tego:
std::vector<std::unique_ptr<Shape>> vp;
vp.push_back(std::make_unique<Rectangle>(2,3));

// 2) Brak wirtualnego destruktora
struct BadBase { ~BadBase(){} };     // ❌
struct GoodBase{ virtual ~GoodBase() = default; }; // ✅

// 3) Name hiding (ukrywanie przeciążeń)
struct B{ virtual void f(int); void f(double); };
struct D: B { using B::f; void f(int) override; }; // ✅ przywraca overloady z B
      </code></pre>

      <ul class="poplist">
        <li class="fragment"><b>Slicing</b> — utrata części danych/metod pochodnych przy kopiowaniu „by value” do bazy.</li>
        <li class="fragment"><b>Brak virtual dtor</b> — niszczenie przez wskaźnik do bazy nie wywoła destruktora pochodnej.</li>
        <li class="fragment"><b>Ukrywanie nazw</b> — nowa wersja metody w pochodnej ukrywa przeciążenia z bazy.</li>
      </ul>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Polimorfizm w kompilacji: overload + szablony</h3>
    <div class="win-grid">
      <pre class="code-box"><code class="language-cpp">
// Overload — wybór na etapie kompilacji
void log(int x);
void log(std::string_view s);

// Szablon — typ-parametr
template<class T>
T clamp(T v, T lo, T hi){
  return v < lo ? lo : (v > hi ? hi : v);
}

// Użycie:
log(42);              // wybierze log(int)
log("hello"sv);       // wybierze log(string_view)
auto c = clamp(5.2, 0.0, 1.0); // instancjacja clamp<double>
      </code></pre>

      <ul class="poplist">
        <li class="fragment"><b>Overload</b> — różni się listą parametrów i/lub kwalifikatorami (const, &amp;, &&, noexcept…)</li>
        <li class="fragment"><b>Szablony</b> — generują kod dla konkretnych typów; to też forma polimorfizmu (statycznego).</li>
        <li class="fragment"><b>Nie myl</b> overload (ta sama nazwa) z <b>override</b> (dziedziczenie + wirtualne metody).</li>
      </ul>
    </div>
  </section>

  <section data-auto-animate>
    <h4>Od UML do polimorfizmu — mini szkic</h4>
    <div class="win-grid">
      <pre class="code-box"><code class="language-text">
«abstract» Notifier
+ send(msg: string): void

EmailNotifier ──▷ Notifier (realizacja)
SmsNotifier   ──▷ Notifier (realizacja)
      </code></pre>

      <pre class="code-box fragment"><code class="language-cpp">
struct Notifier {
  virtual ~Notifier() = default;
  virtual void send(std::string_view msg) = 0;
};

struct EmailNotifier : Notifier {
  void send(std::string_view msg) override { /* ... */ }
};

struct SmsNotifier : Notifier {
  void send(std::string_view msg) override { /* ... */ }
};

void broadcast(const std::vector<std::unique_ptr<Notifier>>& ns,
               std::string_view msg){
  for (auto& n : ns) n->send(msg);   // runtime-polymorphism here
}
      </code></pre>
    </div>
  </section>

</section>


			<section data-auto-animate data-background-gradient="linear-gradient(90deg, #aFB486, #F46267)">
				<section>
					<h1>Dziedziczenie wielobazowe</h1>
				</section>
				<section data-auto-animate>
					<pre style="font-size: 16px" data-id="code-animation">
								<code class="hljs cpp" data-trim data-line-numbers="3,12,21"><script type="text/template">#include <iostream>


class BazowaA {
protected:
				int licznik;
public:
				void wyswietl() {
								std::cout << "A::wyswietl()" << '\n';
				}
};

class BazowaB {
protected:
				int licznik;
public:
				void wyswietl() {
								std::cout << "B::wyswietl()" << '\n';
				}
};

class Klasa: public BazowaA, public BazowaB {
public:
				void wyzeruj() {
								BazowaA::licznik = 0;
								BazowaB::licznik = 0;
				}
};

int main() {
				Klasa k;

				k.BazowaA::wyswietl();
				k.BazowaB::wyswietl();
}</script>
								</code>
								</pre>
					<small>
						Język C++, w odróżnieniu od wielu popularnych języków, np. Javy, dopuszcza dziedziczenie
						wielobazowe (dziedziczenie
						wielokrotne), tj. klasa może dziedziczyć po więcej niż jednej klasie. To powoduje, że w ogólnym
						przypadku nie mamy do
						czynienia z drzewiastą hierarchią klas, lecz skierowanym grafem acyklicznym dziedziczenia.
					</small>
				</section>
				<section data-auto-animate>
					<pre style="font-size: 16px" data-id="code-animation">
								<code class="hljs cpp" data-trim data-line-numbers="24,25,32,33"><script type="text/template">#include <iostream>

class BazowaA {
protected:
				int licznik;
public:
				void wyswietl() {
								std::cout << "A::wyswietl()" << '\n';
				}
};

class BazowaB {
protected:
				int licznik;
public:
				void wyswietl() {
								std::cout << "B::wyswietl()" << '\n';
				}
};

class Klasa: public BazowaA, public BazowaB {
public:
				void wyzeruj() {
								BazowaA::licznik = 0;
								BazowaB::licznik = 0;
				}
};

int main() {
				Klasa k;

				k.BazowaA::wyswietl();
				k.BazowaB::wyswietl();
}</script>
								</code>
								</pre>
					<small>
						Klasa pochodna ma dostęp do wszystkich pól z klas bazowych oraz udostępnia pola i metody zgodnie
						z podanymi regułami
						widoczności (private/protected/public). Jeśli pola lub metody w klasach bazowych powtarzają się,
						wówczas konieczna jest
						dodatkowa klasyfikacja nazwą klasy, jak w przykładzie poniżej.
					</small>
			
				</section>
				<section>
					<h3>Dziedziczenie wirtualne</h3>
					<small>
						Dziedzicznie wirtualne jest specjalnym przypadkiem w dziedziczeniu wielobazowym, które stosuje
						się, gdy z jakiegoś
						powodu jedna z klas staje się wielokrotnie przodkiem (bezpośrednio lub pośrednio) innej klasy.
						Np.
					</small>
					<pre style="font-size: 16px" data-id="code-animation">
													<code class="hljs cpp" data-trim data-line-numbers="24,25,32,33"><script type="text/template">class Bazowa {
protected:
				void wyswietl() {};
};

class Posrednia: public Bazowa {};

class Klasa: public Bazowa, public Posrednia {};</script>
													</code>
													</pre>
				</section>
				<section>
					<small>
						Tutaj to klasa Bazowa jest przodkiem Klasy: raz bezpośrednio, raz poprzez klasę Pośrednią.
						Oczywiście nie jest to błąd,
						ale niesie ze sobą następujące niedogodności:
						<ul>
							<li>
								Pola z klasy <b>Bazowa</b> powtarzają się 2 razy, skutkiem czego <b>sizeof(Klasa) > 2 *
									sizeof(Bazowa)</b>. To na pierwszy rzut oka
								może wydawać się mało istotne, bo zwykle rozmiar klasy jest niewielki. Jednak co gdy
								przechowujemy tysiące lub miliony
								instancji? Wówczas ten narzut może okazać się znaczący.
							</li>
							<li>
								Zwykle też chcemy, aby to właśnie klasa Bazowa dostarczała pewnych metod lub pól dla
								klas pochodnych, a w tym przypadku
								odwołanie do metody <b>Wyswietl</b> musi być kwalifikowane nazwą klasy nadrzędnej, co
								jest mało wygodne.
							</li>
						</ul>
					</small>
				</section>
				<section>
					<small>
						Zatem jeśli chcemy wyraźnie wskazać, że jakaś klasa jest bazową dla wszystkich potomków, to przy
						w deklaracji musimy
						dodać słowo kluczowe virtual przy nazwie klasy z której dziedziczymy. Wówczas zniknie
						niejednoznaczność odwołań do jej
						składowych, natomiast jej pola zostaną umieszczone w klasie pochodnej tylko raz. W przykładzie
						poniżej rozmiar Klasy to
						1kB + kilka bajtów, bez dziedziczenia wirtualnego byłoby to ponad 2kB, oraz oczywiście wywołanie
						metody wyswietl
						(używając takiego zapisu) byłoby niemożliwe.
					</small>
					<pre style="font-size: 16px" data-id="code-animation">
																							<code class="hljs cpp" data-trim data-line-numbers="24,25,32,33"><script type="text/template">class Bazowa {
				char bufor1kB[1024];
public:
				void wyswietl() {}
};

class Posrednia1: public virtual Bazowa {};

class Posrednia2: public virtual Bazowa {};

class Klasa: public Posrednia1, public Posrednia2 {};

int main() {
				Klasa k;
				std::cout << sizeof(Klasa) << '\n';
				k.wyswietl();
}</script>
																							</code>
																							</pre>
				</section>
			
			</section>
		<!11>
<section data-background-gradient="linear-gradient(195deg, #346beb, #a82c3c)">

  <section>
    <h2>Kompozycja vs Dziedziczenie</h2>
    <p class="fragment" style="opacity:.85">
      <li><b>is-a</b> kontra <b>has-a</b></li><li> Dwa podejścia do budowy klas</li>
    </p>
  </section>

  <section data-auto-animate>
    <p>
      W programowaniu obiektowym mamy dwa sposoby, aby jedna klasa korzystała z drugiej:
    </p>
    <ul class="poplist">
      <li class="fragment" data-fragment-index="1"><b>Dziedziczenie (is-a)</b> — specjalizacja: klasa potomna <i>jest</i> klasą bazową.</li>
      <li class="fragment" data-fragment-index="2"><b>Kompozycja (has-a)</b> — współpraca: klasa <i>ma</i> obiekt innej klasy jako część swojej struktury.</li>
    </ul>
    <p class="fragment">Oba podejścia są poprawne, ale ich konsekwencje projektowe są różne.</p>
  </section>

  <section data-auto-animate>
    <h3>Dziedziczenie (is-a)</h3>
    <pre><code class="language-text">
Vehicle ◁───── Car
Vehicle ◁───── Bike
    </code></pre>
    <p class="fragment">Samochód <b>jest</b> pojazdem, rower <b>jest</b> pojazdem.</p>
    <pre class="fragment"><code class="language-java">
// Java
class Vehicle { void move() { } }
class Car extends Vehicle { void honk() { } }
class Bike extends Vehicle { void pedal() { } }
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Kompozycja (has-a)</h3>
    <pre><code class="language-text">
Car ◆──── Engine
    </code></pre>
    <p class="fragment">Samochód <b>ma</b> silnik — silnik jest częścią samochodu, ale nie każdy silnik jest samochodem.</p>
    <pre class="fragment"><code class="language-cpp">
// C++
struct Engine {
  void start() { std::cout << "Silnik startuje\n"; }
};
struct Car {
  Engine engine;      // kompozycja
  void drive() { engine.start(); }
};
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Problem z nadużywaniem dziedziczenia</h3>
    <p>
      Jeśli wymusimy relację <b>is-a</b> tam, gdzie jej nie ma, powstają sztuczne hierarchie:
    </p>
    <pre><code class="language-java">
class Bird { void fly() { } }
class Penguin extends Bird { } // ups...
    </code></pre>
    <p class="fragment">Pingwin <b>nie lata</b> — dziedziczenie bywa mylące i ogranicza elastyczność.</p>
  </section>

  <section data-auto-animate>
    <h3>Rozwiązanie przez kompozycję</h3>
    <pre><code class="language-java">
interface FlyBehaviour { void fly(); }
class CanFly implements FlyBehaviour { public void fly() { ... } }
class CantFly implements FlyBehaviour { public void fly() { /* nic */ } }

class Bird {
  private FlyBehaviour fb;
  Bird(FlyBehaviour fb){ this.fb = fb; }
  void fly(){ fb.fly(); }
}
    </code></pre>
    <p class="fragment">Teraz pingwin dostaje strategię <code>CantFly</code>, a orzeł — <code>CanFly</code>. Elastyczność bez fałszywego dziedziczenia.</p>
  </section>

  <section data-auto-animate>
    <h3>Kiedy co stosować?</h3>
    <ul class="poplist">
      <li class="fragment"><b>Dziedziczenie</b>: gdy relacja „jest” jest logiczna i stabilna (np. <i>Kwadrat jest Figurą</i>).</li>
      <li class="fragment"><b>Kompozycja</b>: gdy chcemy elastycznej współpracy i możliwości wymiany zachowań w czasie działania.</li>
      <li class="fragment">Zasada praktyczna: <b>preferuj kompozycję</b>, bo ogranicza problemy i daje większą kontrolę.</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Podsumowanie</h3>
    <ul>
      <li class="fragment">Dziedziczenie = silna relacja is-a, dobre dla hierarchii typów.</li>
      <li class="fragment">Kompozycja = elastyczna relacja has-a, lepsza do zmiennych zachowań.</li>
      <li class="fragment">Nowoczesne projektowanie OOP: „<b>Preferuj kompozycję nad dziedziczeniem</b>”.</li>
    </ul>
  </section>

</section>
			<!-- TODO -->
			<section>
				<section>
					<h3>Wzorzec projektowy Singleton</h3>
					<small>
						Wzorzec projektowy Singleton jest jednym z najbardziej popularnych wzorców projektowych w
						programowaniu
						obiektowym. Jego celem jest zapewnienie, że klasa ma tylko jedną instancję i zapewnienie
						globalnego dostępu do
						tej instancji.
					</small>
					<small>
						Wzorzec Singleton jest szczególnie przydatny, gdy chcemy, aby klasa miała tylko jedną instancję
						i chcemy
						zapewnić, że dostęp do tej instancji jest globalny. Może to być przydatne w przypadku, gdy
						chcemy, aby
						klasa reprezentowała globalny stan lub zasób, który jest współdzielony przez całą aplikację.
					</small>
				</section>
				<section>
					<h3>Przykład użycia wzorca projektowego Singleton</h3>
					<small>
						Poniżej znajduje się przykład kodu w języku C++, który pokazuje, jak używać wzorca projektowego
						Singleton:
					</small>
					<pre style="font-size: 16px;"><code>class Singleton {
						private:
								// Prywatny konstruktor, aby zapobiec 
								// tworzeniu instancji za pomocą operatora new
								Singleton() {}
						
								// Prywatny destruktor
								~Singleton() {}
						
								// Usunięcie możliwości kopiowania i przypisywania
								Singleton(const Singleton&) = delete;
								Singleton& operator=(const Singleton&) = delete;
						
						public:
								// Metoda do uzyskania instancji Singleton
								static Singleton& getInstance() {
										static Singleton instance;
										return instance;
								}
						};
						    </code></pre>
					<small>
						W tym przykładzie, klasa <code>Singleton</code> ma prywatny konstruktor i destruktor, co
						zapobiega tworzeniu
						nowych instancji za pomocą operatora <code>new</code> lub <code>delete</code>. Metoda
						<code>getInstance</code>
						zapewnia globalny dostęp do jednej instancji klasy.
					</small>
					<small>
						Ten przykład pokazuje, jak wzorzec Singleton może być używany do zapewnienia, że klasa ma tylko
						jedną instancję,
						a dostęp do tej instancji jest globalny.
					</small>
				</section>
			</section>

<section data-background-gradient="linear-gradient(170deg, #0a6c51, #2b3f8f)">

  <section>
    <h3>Klasy zaprzyjaźnione w C++</h3>
    <p class="fragment" style="opacity:.9">
      Jak i po co używać <code>friend</code>?
    </p>
  </section>

  <section data-auto-animate>
    <h3>Co robi <code>friend</code>?</h3>
    <ul class="poplist">
      <li class="fragment" data-fragment-index="1">
        <b><code>friend</code></b> nadaje wskazanej funkcji lub klasie prawo dostępu do
        <b>prywatnych</b> i <b>chronionych</b> członków innej klasy.
      </li>
      <li class="fragment" data-fragment-index="2">
        To wyjątek od reguł hermetyzacji — bywa potrzebny, ale zwiększa sprzężenie (coupling).
      </li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Deklaracja przyjaźni (klasa → klasa)</h3>
    <p class="fragment" data-fragment-index="1"><small>
      W klasie <code>MyClass</code> deklarujemy, że <code>MyFriendClass</code> jest „insiderem”.
      Dzięki temu ma <b>pełny</b> dostęp do prywatnych pól i metod <code>MyClass</code>.
    </small></p>

    <pre class="fragment" data-fragment-index="2"><code class="language-cpp" data-line-numbers="1-12|6">
class MyClass {
private:
    int myPrivateVar;

    // ↓ Ta linia nadaje przywileje klasie MyFriendClass
    friend class MyFriendClass;
};

class MyFriendClass {
public:
    void changeMyClass(MyClass& obj);
};
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Wykorzystanie dostępu (użycie prywatnego pola)</h3>
    <p class="fragment" data-fragment-index="1"><small>
      W metodzie klasy zaprzyjaźnionej możemy <b>bezpośrednio</b> dotknąć prywatnych składowych
      obiektu pierwotnej klasy — bez getterów/setterów.
    </small></p>

    <pre class="fragment" data-fragment-index="2"><code class="language-cpp" data-line-numbers="1-9|6-7">
class MyFriendClass {
public:
    void changeMyClass(MyClass& obj) {
        // Dostęp „po znajomości” (wynika z friend w MyClass)
        // Uwaga: to obchodzi enkapsulację — używaj świadomie.
        obj.myPrivateVar = 42;
    }
};
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Kiedy używać <code>friend</code>?</h3>
    <ul class="poplist">
      <li class="fragment" data-fragment-index="1">
        Gdy dwie klasy tworzą ścisły, techniczny duet (np. <i>iterator</i> ↔ <i>kolekcja</i>).
      </li>
      <li class="fragment" data-fragment-index="2">
        Gdy testy jednostkowe muszą widzieć szczegóły (czasem lepiej użyć <i>friend test</i>).
      </li>
      <li class="fragment" data-fragment-index="3">
        <b>Alternatywy</b>: węższe API (gettery/metody serwisowe), wzorce (np. <i>Visitor</i>), kompozycja.
      </li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Ćwiczenie: rozbudowane zarządzanie pamięcią</h3>
    <p><small>Zaprojektuj klasy i ich interakcje — najpierw API, potem implementacja.</small></p>
    <ul class="poplist">
      <li class="fragment" data-fragment-index="1">
        Zaimplementuj <code>MyArray</code>: prywatny konstruktor (alokuje tablicę), prywatny destruktor
        (zwalnia pamięć), metody: <code>getSize()</code>, <code>setValue(i,v)</code>, <code>getValue(i)</code>.
      </li>
      <li class="fragment" data-fragment-index="2">
        Zaimplementuj <code>MySingleton</code> przechowujący <code>MyArray</code> i udostępniający
        <code>getArray()</code> (instancja via <code>getInstance()</code>).
      </li>
      <li class="fragment" data-fragment-index="3">
        W <code>main()</code> pobierz tablicę z Singletona i wykonaj operacje: wstaw, odczytaj, zmień —
        zaobserwuj wywołania konstruktora/destruktora.
      </li>
    </ul>

    <div class="hint-box fragment" data-fragment-index="4">
      <p><b>Podpowiedzi jakościowe</b></p>
      <ul>
        <li>Sprawdzenia zakresu indeksu (assert/wyjątki).</li>
        <li>Singleton: ukryty konstruktor, statyczny <code>getInstance()</code>.</li>
        <li>Jeśli to nowoczesny C++, rozważ <code>std::vector</code>/<code>unique_ptr&lt;T[]&gt;</code>
            zamiast surowego <code>new</code>/<code>delete</code>.</li>
      </ul>
    </div>
  </section>

  <section data-background-color="#0b0b0b" data-auto-animate>
    <h3>Zadanie domowe: sortowanie z alokacją dynamiczną</h3>
    <p class="fragment" data-fragment-index="1"><small>
      Klasa przyjmująca dane w konstruktorze, <b>kopiująca</b> je do własnej tablicy (alokacja dynamiczna),
      z metodą sortującą i prostym cache wyniku.
    </small></p>

    <ul class="poplist">
      <li class="fragment" data-fragment-index="2">
        Alokuj pamięć w konstruktorze (<code>new[]</code>) i skopiuj wejście.
      </li>
      <li class="fragment" data-fragment-index="3">
        Zaimplementuj sortowanie (nie bąbelkowe) — możesz użyć <code>std::sort</code>.
      </li>
      <li class="fragment" data-fragment-index="4">
        Przy pierwszym wywołaniu sortuj; przy kolejnych zwracaj wynik z cache (bez ponownego sortu).
      </li>
      <li class="fragment" data-fragment-index="5">
        W destruktorze zwolnij pamięć (<code>delete[]</code>).
      </li>
    </ul>

    <div class="hint-box fragment" data-fragment-index="6">
      <p><b>Rule of Three/Five</b></p>
      <ul>
        <li>Jeżeli zarządzasz surowym zasobem, zdefiniuj kopiowanie/przenoszenie lub je wyłącz.</li>
        <li>Do testów dopisz dwa przypadki: „pierwsze sortowanie” i „ponowne wywołanie (cache)”.</li>
      </ul>
    </div>
  </section>
</section>

<style>
  .reveal .poplist{ font-size:1.35rem; line-height:1.35; margin:.6rem 0 0 0; }
  .reveal .poplist li{ margin:.35rem 0; }

  .reveal pre{ margin:.6rem 0; max-height:48vh; overflow:auto; }
  .reveal pre code{ font-size: clamp(.85rem, 1.6vw, 1rem); line-height:1.38; }

  .reveal .hint-box{
    border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.06);
    padding:.75rem 1rem; border-radius:.75rem; font-size:.95rem;
  }
</style>

			
			<!-- TODO jako zadanie domowe -->
			<section data-background-gradient="linear-gradient(45deg, #c03090, #10a080)">
				<section>
					<h2>Konstruktor - cechy główne</h2>
				</section>
				<section data-auto-animate>
					<h3>Uwagi ogólne do konstruktorów</h3>
					<small>
						<ul>
							<li>Konstruktor <b>NIE MUSI</b> wystąpić w opisie klasy, czyli obiekty nie muszą być
								jawnie wprowadzane
								konstruktorem. Wtedy uruchomi się konstruktor domniemany.</li>
							<li>Nazwa konstruktora może być przeładowana, czyli stosowana wielokrotnie w opisie
								klasy z różnymi
								listami argumentów. Wtedy kompilator odróżnia konstruktory po listach argumentów,
								tak, jak w
								przypadku przeładowanych nazw funkcji. Konstruktorów może więc być wiele.</li>
							<li>Konstruktor może być wywoływany (a nie definiowany!!) bez żadnych argumentów. Jest
								to również tak
								zwany konstruktor domniemany. Czasem nazywamy go domyślnym albo standardowym. Ze
								względu na istotę
								przeładowania nazwy konstruktor domniemany czyli bezargumentowy może wystąpić tylko
								raz. Jeśli nie
								deklarujemy w klasie żadnego konstruktora, to kompilator sam ustanawia właśnie
								konstruktor
								domniemany do obsługi obiektów w programie. Każdy konstruktor z argumentami, którym
								nadamy
								początkowe wartości domyślne czyli już niedefiniowalne jest także konstruktorem
								domniemanym.</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor i jego właściwości</h3>
					<small>
						<ul>
							<li>Konstruktor jest zwykle deklarowany jako publiczny, bo obiekty wprowadzane nim mogą
								być używane
								przez klasy zewnętrzne, a ponadto jest funkcją, która <b>MUSI</b> być dostępna dla
								wszystkich
								składników klasy.</li>
							<li>Dla konstruktora można przewidzieć ochronę za pomocą etykiet <code>private</code>
								lub
								<code>protected</code>. Wówczas konstruowane obiekty będą dostępne tylko w obrębie
								klasy z tym
								konstruktorem jako <code>private</code> albo jako <code>protected</code> tylko w
								zakresie klas
								dziedziczących.
							</li>
							<li>Konstruktor kopiujący zamiast definiować nowe obiekty, podaje kopie obiektów
								zawartych w innej
								klasie.</li>
							<li>Konstruktor konwertujący dokonuje konwersji typu obiektu z jednego w drugi.</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący</h3>
					<small>
						<p>Przyjrzyjmy się wywołaniu konstruktora klasy o nazwie <code>klasa</code>:</p>
						<pre><code data-trim class="cpp">
													MyClass::MyClass(MyClass&)
															</code></pre>
						<p>Jego argumentem jest referencja do obiektu danej klasy. Czyli do elementu, który w chwili
							uruchomienia
							tego konstruktora już istnieje. Taki konstruktor nie konstruuje obiektu tylko tworzy
							kopię innego, który
							już istnieje.</p>
						<p>Przykłady zapisu konstruktora kopiującego:</p>
						<pre><code data-trim class="cpp">
													X::X(X&)
															</code></pre>
						<p>lub</p>
						<pre><code data-trim class="cpp">
													X::X(X&, float=3.1415, int=0)
															</code></pre>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący c.d.</h3>
					<small>
						<p>Taki konstruktor wprowadza obiekty identyczne z już istniejącymi, czyli ich kopie. Może
							być wywołany
							przez program niejawnie:</p>
						<ol>
							<li>W sytuacji, gdy do funkcji jest przez wartość przesyłany obiekt klasy X. Wówczas
								tworzona jest kopia
								tego obiektu, co jest znanym jako kopiowanie płytkie.</li>
							<li>W sytuacji, kiedy funkcja zwraca przez wartość obiekt klasy X. Również wtedy
								tworzona jest kopia
								obiektu, co także jest kopiowaniem płytkim.</li>
						</ol>
						<p>To, że konstruktor kopiujący podaje obiekt kopiowany przez referencję, daje mu możliwość
							zmiany
							zawartości obiektu klasy (np. przesyłanie argumentu do funkcji przez wartość).</p>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący c.d.</h3>
					<small>
						<p>Nie można pominąć referencji w konstruktorze kopiującym, ponieważ gdyby konstruktor
							<code>X</code>
							wywoływał obiekty swojej klasy <code>X</code> przez wartość, to powstawałaby
							nieskończona pętla
							tworzenia kopii.
						</p>
						<p>Konstruktor, z przyczyn logiki języka, otrzymuje więc warunki do tego, aby potencjalnie
							uszkodzić
							oryginał. Aby się przed tym zabezpieczyć, stosujemy następujący zapis (w trybie
							domyślnym):</p>
						<pre><code data-trim class="cpp">
													X::X(const X& obiekt)
															</code></pre>
						<p>Teraz konstruktor <code>X</code> wie, że obiekt klasy <code>X</code> musi być wywoływany
							jako stały.
							Konstruktor kopiujący jest domyślnie obdarzony moderatorem <code>const</code>, czyli nie
							może zmienić
							sam siebie.</p>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Kopiowanie płytkie i głębokie</h3>
					<small>
						<p>Wyróżniamy dwa typy kopiowania obiektów zawierających pola będące wskaźnikami:</p>
						<h4>Kopiowanie płytkie</h4>
						<ul>
							<li>Kopiowanie wszystkich składowych (w tym wskaźników).</li>
							<li>Kopiowane są wskaźniki, a nie to, na co wskazują.</li>
						</ul>
						<h4>Kopiowanie głębokie</h4>
						<ul>
							<li>Alokacja nowej pamięci dla wskaźników.</li>
							<li>Kopiowanie zawartości wskazywanej przez wskaźniki w nowe miejsce.</li>
							<li>Kopiowanie pozostałych pól, nie będących wskaźnikami.</li>
						</ul>
					</small>
				</section>
				<section data-auto-animate>
					<h3>Głębokie kopiowanie</h3>
					<small>
						<p>Kiedy obiekt zawiera wskaźnik do dynamicznie zaalokowanego obszaru, należy zdefiniować
							operator
							przypisania wykonujący głębokie kopiowanie. Dla rozważanej klasy zdefiniowanie operatora
							przypisania
							może wyglądać następująco:</p>
						<pre><code data-trim class="cpp">
													AType&amp; AType::operator=(const AType&amp; otherObj) {
														// Sprawdzić przypisanie obiektu do samego siebie
														if (this == &amp;otherObj) {
															return *this; // do nothing
														}
													
														// Skasować zawartość obiektu docelowego
														delete this->...; // Właściwe czyszczenie zasobów
													
														// Zaalokować pamięć dla kopiowanych wartości
														// ... kod alokacji ...
													
														// Przepisać kopiowane wartości
														// ... kod kopiowania ...
													
														// Zwrócić *this
														return *this;
													}
															</code></pre>
						<p>Operator przypisania powinien uwzględnić przypadki szczególne, takie jak przypisanie
							obiektu do samego
							siebie oraz zarządzanie zasobami.</p>
					</small>
				</section>
				<section>
					<h3>Konstruktor kopiujący vs Operator przypisania</h3>
					<p>Konstruktor kopiujący i operator przypisania mają różne zastosowania i zachowania.</p>
				</section>

				<section>
					<h4>Konstruktor kopiujący</h4>
					<p>Używany do stworzenia nowego obiektu z istniejącego, bez konieczności sprawdzania przypisania
						do samego
						siebie oraz zwalniania poprzedniej zawartości. Jest wywoływany:</p>
					<ul>
						<li>Przy przekazywaniu obiektu przez wartość.</li>
						<li>Przy inicjalizacji nowego obiektu istniejącym.</li>
					</ul>
				</section>

				<section>
					<h4>Operator przypisania</h4>
					<p>Używany do kopiowania wartości między już istniejącymi obiektami, z dodatkowymi krokami jak:
					</p>
					<ul>
						<li>Sprawdzenie przypisania obiektu do samego siebie.</li>
						<li>Zarządzanie zwalnianiem zasobów przed przypisaniem.</li>
					</ul>
				</section>
				<section>
					<h3>Konstruktor kopiujący vs Operator przypisania c.d.</h3>
					<pre><code data-trim contenteditable>
													int main() {
														list a;
														// ...
														list b(a); // copy constructor is called
														list c = a; // copy constructor is called
													};
														</code></pre>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code  
												class="hljs cpp" 
												data-trim 
												data-line-numbers>
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
				</section>

				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="5-10">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Omówienie przykładu: Klasa X</small>
					<small>
						<ul>
							<li>Klasyfikacja <code>public</code>, wskaźnik <code>p</code> i konstruktor
								<code>X(char*)</code>.
							</li>
							<li>Wskaźnik <code>p</code> wskazuje na znaki.</li>
							<li>Konstruktor przyjmuje <code>char*</code> jako argument.</li>
						</ul>
					</small>
				</section>

				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="38-41">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Omówienie przykładu: Konstruktor X</small>
					<br />
					<small>Definicja konstruktora klasy <code>X</code>. Przydziela on pamięć
						dla tablicy
						znaków i kopiuje łańcuch przekazany jako argument tylko jeśli alokacja pamięci się
						powiedzie.</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="13-19">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Omówienie przykładu: Klasa Y</small>
					<small>Analogiczna struktura do klasy X dla klasy Y.</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
																				style="max-height: 250px;" 
																				data-id="code"
																				class="hljs cpp" 
																				data-trim 
																				data-line-numbers="43-51">
																				<script type="text/template">
														#include<iostream>
														#include<string>
														#include<conio.h>
														
														class X {
														public:
														    char *p;
														
														    X(char *);
														};
														
														class Y {
														public:
														    char *p;
														
														    Y(char *);
														
														    Y(Y &); // deklaracja konstruktora kopiującego
														};
														
														void main() {
														    X x("xxx");
														    X j = x; // wywołanie konstruktora kopiującego
														    cout << "\nx=" << x.p << ", j=" << j.p;
														    strcpy(j.p, "111");
														    cout << "\nx=" << x.p << ", j=" << j.p;
														    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
														
														    Y y("yyy");
														    Y d = y; // wywołanie konstruktora kopiującego
														    cout << "\ny=" << y.p << ", d=" << d.p;
														    strcpy(y.p, "222");
														    cout << "\ny=" << y.p << ", d=" << d.p;
														    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
														    getch();
														}
														
														X::X(char *s) {
														    p = new char[80];
														    if (p) strcpy(p, s);
														}
														
														Y::Y(char *s) {
														    p = new char[80];
														    if (p) strcpy(this->p, s);
														}
														
														Y::Y(Y &y) {
														    p = new char[80];
														    if (p) strcpy(p, y.p);
														}
																	</script></code></pre>
					<p>Implementacja konstruktorów klasy Y.</p>
					<small>Konstruktor klasy <code>Y</code>, przydziela pamięć dla tablicy
						znaków i kopiuje
						łańcuch przekazany jako argument.</small>
					<small>Konstruktor kopiujący klasy <code>Y</code>, tworzy nową tablicę
						znaków i kopiuje do
						niej zawartość z innego obiektu klasy <code>Y</code>, umożliwiając kopiowanie głębokie.</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 150px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="48-51">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Konstruktor kopiujący w klasie Y kopiuje wskaźnik do zmiennej znakowej.</small>
					<small>
						<ul>
							<li>Możliwe jest kopiowanie z innej klasy, co jest podstawą kopiowania głębokiego.</li>
							<li>W klasie X, domyślny konstruktor kopiujący (utworzony w trakcie kompilacji) umożliwia
								kopiowanie płytkie.</li>
							<li>Kopiowanie płytkie obejmuje tylko składniki klasy X.</li>
						</ul>
					</small>
					<small>Konstruktor kopiujący klasy Y umożliwia kopiowanie głębokie, w przeciwieństwie do
						konstruktora kopiującego klasy X,
						który jest domyślny i wykonuje kopiowanie płytkie.</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="21,22,23">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Inicjalizacja obiektów klasy X</small>
					<small>Tworzymy dwa obiekty klasy X, x i j, gdzie j jest inicjowany przez skopiowanie x.</small>
					<small>
						<ul>
							<li>x jest inicjowany z ciągiem "xxx".</li>
							<li>Konstruktor kopiujący klasy X jest używany do stworzenia j jako kopii x.</li>
						</ul>
					</small>
				</section>


				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="24-26">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<small>Współdzielenie pamięci przez obiekty</small>
					<small>Wskaźnik p w obu obiektach, x i j, wskazuje na to samo miejsce w pamięci.</small>
					<small>
						<ul>
							<li>Modyfikacja <code>j.p</code> za pomocą <code>strcpy</code> zmienia również wartość
								wskazywaną przez <code>x.p.</code></li>
							<li>Wydruk adresów wskaźników obiektów <code>x</code> i <code>j</code> pokaże ten sam adres.
							</li>
						</ul>
					</small>
				</section>


				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="24-26">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<p>Modyfikacja i wydruk wartości wskaźnika</p>
					<small>Poprzez wskaźnik <code>p</code> wpisujemy wartość "111" do obiektu
						<code>j</code>,
						a zmiany widoczne są również w <code>x</code> ze względu na współdzieloną pamięć. Wydruk
						adresów po
						modyfikacji wskaźnika <code>p</code> w obiekcie <code>j</code> powinien pokazać identyczne
						adresy dla obu
						obiektów.
					</small>
				</section>

				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="29-33">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<p>Konstruktor kopiujący w praktyce - klasa Y</p>
					<small>
						Powtórzenie operacji dla klasy <code>Y</code>, podobne do klasy
						<code>X</code>.
						Inicjacja obiektów <code>y</code> i <code>d</code> klasy
						<code>Y</code>, które są
						odpowiednikami <code>x</code> i <code>j</code> z klasy <code>X</code>.
					</small>
				</section>
				<section data-auto-animate>
					<h3>Konstruktor kopiujący: kopiowanie płytkie vs głębokie</h3>
					<pre style="font-size: 16px"><code 
												style="max-height: 250px;" 
												data-id="code"
												class="hljs cpp" 
												data-trim 
												data-line-numbers="32-33">
												<script type="text/template">
						#include<iostream>
						#include<string>
						#include<conio.h>
						
						class X {
						public:
						    char *p;
						
						    X(char *);
						};
						
						class Y {
						public:
						    char *p;
						
						    Y(char *);
						
						    Y(Y &); // deklaracja konstruktora kopiującego
						};
						
						void main() {
						    X x("xxx");
						    X j = x; // wywołanie konstruktora kopiującego
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    strcpy(j.p, "111");
						    cout << "\nx=" << x.p << ", j=" << j.p;
						    cprintf("\n\rx.p=%p, j.p=%p", x.p, j.p);
						
						    Y y("yyy");
						    Y d = y; // wywołanie konstruktora kopiującego
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    strcpy(y.p, "222");
						    cout << "\ny=" << y.p << ", d=" << d.p;
						    cprintf("\n\ry.p=%p, d.p=%p", y.p, d.p);
						    getch();
						}
						
						X::X(char *s) {
						    p = new char[80];
						    if (p) strcpy(p, s);
						}
						
						Y::Y(char *s) {
						    p = new char[80];
						    if (p) strcpy(this->p, s);
						}
						
						Y::Y(Y &y) {
						    p = new char[80];
						    if (p) strcpy(p, y.p);
						}
									</script></code></pre>
					<p>Modifikacja i sprawdzenie obiektów klasy Y.</p>
					<small>Modyfikacja łańcucha w obiekcie <code>d</code> nie wpływa na obiekt
						<code>y</code>
						dzięki kopiowaniu głębokiemu realizowanemu przez konstruktor klasy <code>Y</code>.</small>
					<small>Adresy obiektów <code>y</code> i <code>d</code> powinny być różne,
						w
						przeciwieństwie do obiektów klasy <code>X</code>.</small>
				</section>


				<section>
					<h3>Wyniki działania programu</h3>
					<pre style="font-size: 16px"><code class="hljs" data-trim>
													  x=xxx, j=xxx
													  x=111, j=111
													  x.p=2707:0004, j.p=2707:0004
													  y=yyy, d=yyy
													  y=yyy, d=222
													  y.p=270D:0004, d.p=2713:0004
														</code></pre>
					<p style="font-size: 0.75em;">Powysze linie demonstrują rezultaty wykonania programu. Zauważamy,
						że obiekty
						<code>x</code> i <code>j</code> dzielą tę samą przestrzeń pamięci, podczas gdy
						<code>y</code> i
						<code>d</code> mają oddzielne lokalizacje, co jest wynikiem kopiowania głębokiego
						zaimplementowanego w
						konstruktorze klasy <code>Y</code>.
					</p>
				</section>
				<section>
					<h3>Metody tworzenia obiektów</h3>
					<div class="row">
						<div class="col" style="float: left; width: 50%; font-size: 0.65em;">
							<ul>
								<li>Zmienne automatyczne:
									<pre
										style="font-size: 16px"><code class="hljs cpp" data-trim>Atype a; // konstruktor domyślny</code></pre>
								</li>
								<li>Zmienne z argumentami:
									<pre
										style="font-size: 16px"><code class="hljs cpp" data-trim>Atype a(3); // konstruktor z parametrem int</code></pre>
								</li>
								<li>Przekazywanie parametrów przez wartość:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
																<script type="text/template">
						void f(Atype b) { ... }
						f(a); // konstruktor kopiujący
														</script></code></pre>
								</li>
							</ul>
						</div>
						<div class="col" style="float: right; width: 50%; font-size: 0.65em;">
							<ul>
								<li>Przypisanie wartości zmiennym:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim>
																<script type="text/template">
						Atype a, b;
						a = b; // operator przypisania
																</script>
																</code></pre>
								</li>
								<li>Inicjalizacja nowych obiektów:
									<pre
										style="font-size: 16px"><code class="hljs cpp" data-trim>Atype a = b; // konstruktor kopiujący</code></pre>
								</li>
								<li>Zwracanie wartości z funkcji:
									<pre style="font-size: 16px"><code class="hljs cpp" data-trim><script type="text/template">
						Atype f() {
						    Atype a;
						    return a; // konstruktor kopiujący
						}
						</script>
														</code></pre>
								</li>
							</ul>
						</div>
					</div>
					<div style="clear: both;"></div>
				</section>
				<section>
					<h3>Cechy poprawnie napisanej klasy</h3>
					<small>Jawny konstruktor gwarantuje, że każdy zadeklarowany egzemplarz
						obiektu zostanie w
						kontrolowany sposób zainicjalizowany.</small>
					<small>Jeżeli obiekt zawiera wskaźniki do dynamicznie zaalokowanej
						pamięci, powinien
						zawierać:</small>
					<small>
						<ul>
							<li><strong>Jawny destruktor:</strong> Zapobiega wyciekom pamięci i zwalnia zasoby podczas
								usuwania obiektu.
							</li>
							<li><strong>Jawny operator przypisania:</strong> Używany przy przypisywaniu nowej wartości
								do istniejącego
								obiektu, zapewniając, że obiekt jest istotnie kopią innego obiektu, a nie jego aliasem.
							</li>
							<li><strong>Jawny konstruktor kopiujący:</strong> Używany podczas kopiowania obiektu przy
								przekazywaniu
								parametrów, zwracaniu wartości i inicjalizacji, zapewniając, że obiekt jest istotnie
								kopią innego
								obiektu, a nie jego aliasem.</li>
						</ul>
					</small>

				</section>
				<section>
					<h3>Lista inicjalizacyjna konstruktora</h3>
					<p>Rozpatrzmy kod:</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
													  class Klasa {
														  const int stala;
														  int& ref;
													  
													  public:
														  Klasa() : stala(1), ref(stala) {
															  // Puste ciało konstruktora
														  }
													  };
														</code></pre>
					<small class="fragment">error: uninitialized member 'Klasa::stala' with
						'const' type
						'const int' [-fpermissive]</small>
					<small class="fragment">error: uninitialized reference member
						'Klasa::ref' [-fpermissive]
					</small>
					<small class="fragment">error: assignment of read-only member
						'Klasa::stala'</small>
				</section>
				<section>
					<h3>Lista inicjalizacyjna konstruktora</h3>
					<small>Niektóre zmienne wymagają inicjalizacji, ponieważ nie można im
						przypisać wartości
						później (np. gdy są to stałe).</small>
					<small>Lista inicjalizacyjna konstruktora służy do nadawania wartości tym
						składowym w
						momencie ich tworzenia, jeszcze przed wejściem do ciała konstruktora.</small>
					<pre><code class="hljs cpp" data-trim contenteditable>
													  class Klasa {
														  const int stala;
														  int& ref;
													  
													  public:
														  Klasa() : stala(1), ref(stala) {
															  // Puste ciało konstruktora
														  }
													  };
														</code></pre>
					<small>Tutaj, zaraz po dwukropku, znajdują się jawne wywołania
						konstruktorów oddzielone
						przecinkami, które inicjalizują składowe klasy.</small>
				</section>
				<section>
					<h3>Składowe tworzone przez kompilator</h3>
					<p>Kompilator może, zwykle dla prostych klas, utworzyć konstruktor
						domyślny,
						kopiujący i operator przypisania (jeśli nie zostały już utworzone):</p>
					<pre style="font-size: 16px"><code class="hljs cpp" data-trim contenteditable>
							<script type="text/template">
						#include <iostream>
						
						class Klasa {
						public:
						    int x;
						};
						
						int main() {
						    Klasa k1;
						    k1.x = 5;
						
						    Klasa k2(k1); // Konstruktor kopiujący
						    std::cout << k1.x << " " << k2.x << std::endl;
						
						    k2.x = 2;
						    k1 = k2; // Operator przypisania
						    std::cout << k1.x << " " << k2.x << std::endl;
						}
						</script></code></pre>

				</section>
				<section data-auto-animate>
					<h3>Elementy składowe klas i struktur</h3>
					<small>Klasa i struktura (Struct) są bardzo podobne. Struktury z
						definicji mają wszystkie
						składowe dostępne (publiczne), a klasy z definicji mają wszystkie składowe prywatne, ukryte
						pod wskaźnikiem
						<code>this</code> (C++) albo odpowiednio zarządzaną referencją (Java).
					</small>
					<small>Klasa lub struktura składa się z jej składowych. Praca wykonywana
						przez klasę jest
						wykonywana przez jej funkcje członkowskie. Stan, który utrzymuje, jest przechowywany w jego
						składowych
						danych. Inicjowanie elementów członkowskich jest wykonywane przez konstruktory, a prace
						oczyszczania, takie
						jak zwalnianie pamięci i zwalnianie zasobów, są wykonywane przez destruktory.</small>
				</section>
				<section data-auto-animate>
					<h3>Elementy składowe klas i struktur</h3>
					<small>W języku C++11 lub nowszym składowe danych mogą (i zwykle powinny)
						być
						zainicjowane w punkcie deklaracji. Konstruktory niejawne, kopiujące, konwertujące,
						przemieszczające oraz
						destruktory definiowane są specjalnie, często niejawnie i nazywane są specjalnymi funkcjami
						składowymi klas.
					</small>
					<small>Funkcje składowe są statyczne lub niestatyczne. Zachowanie
						statycznych funkcji
						członkowskich różni się od innych funkcji członkowskich, ponieważ statyczne funkcje
						członkowskie nie mają
						niejawnego argumentu <code>this</code>. Niestatyczne funkcje członkowskie mają wskaźnik
						<code>this</code>.
						Funkcje członkowskie, zarówno statyczne, jak i niestatyczne, można zdefiniować w obrębie lub
						poza deklaracją
						klasy.
					</small>


				</section>
				<footer style="position: absolute; bottom: 0; width: 100%;">
					<small style="font-size: 9px;">
						Materiały do tej prezentacji zostały opracowane w oparciu o skrót materiałów wykładowych
						przedmiotu
						Programowanie
						Obiektowe prowadzonego na WAT. Autor materiałów źródłowych: prof. Andrzej Walczak<br>
						Copyrights Military University of Technology in Warsaw
					</small>
				</footer>


			</section>

<style>
  .reveal .win-grid{
    display:grid; gap:.75rem; grid-template-columns: repeat(2, minmax(0,1fr));
    align-items:start;
  }
  @media (max-width:1200px){ .reveal .win-grid{ grid-template-columns:1fr; } }

  .reveal pre.code-box{ margin:0; max-height:48vh; overflow:auto; }
  .reveal pre.code-box code{ font-size:clamp(.8rem, 1.6vw, 1rem); line-height:1.35; }

  .reveal pre.code-box--compact{ max-height:44vh; }

  .reveal .poplist{ font-size:1.35rem; line-height:1.35; margin:.5rem 0 0 0; }
</style>

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
		});

	</script>


</body>

</html>
